---
type: instructions
project: 1r0nf1st-website
stack: React, TypeScript, Express, Supabase, Vite
purpose: Development guidelines and coding standards for AI assistants
version: 1.0
---

# Development Instructions for 1r0nf1st Website Project

> **Context for AI Assistants**: These instructions define coding standards, architecture patterns, and development practices for this React + TypeScript + Express + Supabase project. Follow these guidelines when assisting with code changes, reviewing code, or implementing new features.

## Project Overview

**Stack:**
- Frontend: React 19, TypeScript, Vite
- Backend: Express (TypeScript), Node.js
- Database/Auth: Supabase (PostgreSQL + Auth)
- Testing: Vitest, React Testing Library
- Package Manager: pnpm

**Architecture:**
- Frontend: Component-based React SPA with hooks and Context API
- Backend: RESTful API with Express routers and middleware
- Authentication: Supabase Auth with JWT tokens
- Development: Vite dev server with proxy to Express backend

---

## Core Principles

- **Small, focused changes**: Prefer incremental, reviewable edits over large rewrites.
- **Clarity over cleverness**: Optimize for readability and maintainability.
- **Type safety**: Do not introduce `any` in TypeScript or `interface{}` in Go without strong justification.
- **Dependencies**: Avoid adding new libraries unless clearly necessary; prefer standard library and existing utilities.
- **Testing**: Always add tests when creating new features, fixing bugs, or refactoring code. Tests are not optional—they are a core part of the development process.
- **Security**: **NEVER share `.env` tokens, API keys, secrets, or any sensitive credentials** in code, comments, commit messages, or any other form. Environment variables containing sensitive data must remain private and never be exposed in the codebase or shared publicly.
- **SOLID principles**: Follow SOLID principles to create maintainable, scalable code:
  - **Single Responsibility**: Each module, class, or function should have one reason to change.
  - **Open/Closed**: Open for extension, closed for modification. Use composition and interfaces.
  - **Liskov Substitution**: Subtypes must be substitutable for their base types without breaking functionality.
  - **Interface Segregation**: Prefer small, focused interfaces over large, general ones.
  - **Dependency Inversion**: Depend on abstractions (interfaces/types) rather than concrete implementations.
- **Pattern consistency**: Maintain consistency with existing codebase patterns. When adding new code, follow established patterns rather than introducing new approaches unless there's a compelling reason.

---

## React (JS/TS) Conventions

### Component Structure

- **Functional components only**: Use function components and hooks; do not add new class components.
- **Prefer TypeScript**: Use `ts`/`tsx` where possible; keep props and state strongly typed.
- **Component return types**: Use `JSX.Element` as the explicit return type for React components (e.g., `const Component = (): JSX.Element => { ... }`).

### Hooks Rules

- Call hooks only at the top level of React function components or custom hooks.
- Never call hooks conditionally or in loops.
- Keep dependency arrays accurate and stable; follow `react-hooks/exhaustive-deps` guidance by refactoring, not disabling.
- Always clean up side effects in `useEffect`; use cleanup functions and cancellation flags (e.g., `isCancelled`) to prevent memory leaks and race conditions.

### Component Design (Applying SOLID Principles)

- **Single Responsibility**: Keep components small and focused; move complex logic into custom hooks or utilities.
- **Composition over inheritance**: Prefer composition with props and children to customize behavior.
- **Separation of concerns**: Avoid "god components" that handle many responsibilities; split into smaller pieces.
- **Dependency inversion**: Components should depend on props/interfaces, not concrete implementations.
- **Pattern consistency**: Follow existing component patterns (e.g., how Hero, Footer, or InfoCard are structured) when creating new components.

### Custom Hooks

- Extract reusable stateful logic into custom hooks (e.g., `useGitHubRepos`, `useAuth`).
- Custom hooks should return objects or tuples with clear, descriptive property names.
- Include loading and error states in custom hook return values for better UX.
- Standard return pattern: `{ data, isLoading, error }`
- Use `isCancelled` flag for cleanup in `useEffect`
- Support conditional fetching (null params)

**Example:**
```typescript
export function useGitHubRepos(username?: string): GitHubReposState {
  const [state, setState] = useState<GitHubReposState>({
    repos: null,
    isLoading: true,
    error: null,
  });

  useEffect(() => {
    let isCancelled = false;

    getJson<GitHubRepo[]>(url)
      .then((repos) => {
        if (isCancelled) return;
        setState({ repos, isLoading: false, error: null });
      })
      .catch((error: unknown) => {
        if (isCancelled) return;
        setState({ repos: null, isLoading: false, error: message });
      });

    return () => {
      isCancelled = true;
    };
  }, [username]);

  return state;
}
```

### Rendering and Side Effects

- Do not perform side effects inside render; use `useEffect` or event handlers instead.
- Avoid inline object/array literals in props that cause unnecessary re-renders; memoize when performance matters.

### Context API

- Use Context API for shared state that needs to be accessed across multiple components.
- Always provide a custom hook (e.g., `useAuth`) to access context values; throw errors if used outside provider.
- Keep context providers focused on a single concern; avoid creating overly broad contexts.

**Example (AuthContext pattern):**
```typescript
const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }: { children: JSX.Element }): JSX.Element => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Verify token on mount
  useEffect(() => {
    const storedToken = localStorage.getItem('authToken');
    if (storedToken) {
      verifyToken(storedToken);
    } else {
      setIsLoading(false);
    }
  }, []);

  return (
    <AuthContext.Provider value={{ user, isLoading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};
```

---

## React Accessibility and UX

- **Semantic HTML**: Use `button`, `a`, `nav`, `main`, `header`, etc. instead of generic `div`/`span` for interactive elements.
- **Keyboard access**: All interactive elements must be focusable and operable with keyboard only.
- **Labels and ARIA**:
  - Provide meaningful `alt` text for images.
  - Use `aria-label`, `aria-describedby`, and roles where appropriate.
  - Avoid `onClick` on non-interactive elements; use buttons or links instead.
- **Focus styles**: Do not remove focus outlines without providing an accessible alternative that is clearly visible.
- **Predictable UX**: Favor simple, predictable interactions; avoid surprising behavior and heavy animations that hurt usability.

---

## TypeScript / JavaScript Specifics

### Variable Declarations and Types

- **Variable declarations**: Prefer `const`, then `let`; never use `var`.
- **Type imports**: Use `import type` for type-only imports to improve build performance and clarity (e.g., `import type { JSX } from 'react'`).
- **Types**:
  - Avoid `any` and `unknown`; use precise interfaces and types.
  - Use discriminated unions and enums instead of stringly-typed logic.
  - Keep shared types in dedicated modules only when they are truly shared.
  - Use interface extensions for extending existing types (e.g., `interface AuthRequest extends Request`).

### Modules and Structure (Applying SOLID Principles)

- **Single Responsibility**: Keep files cohesive; avoid mixing unrelated concerns.
- **DRY (Don't Repeat Yourself)**: Extract shared utilities instead of duplicating logic.
- **Pattern consistency**: Follow existing module patterns (e.g., how `apiClient.ts` or `config.ts` are structured) when creating new modules.
- **Dependency Inversion**: Modules should depend on abstractions (types/interfaces) rather than concrete implementations.

### Error Handling

- Create custom error classes for domain-specific errors (e.g., `ApiError` with status codes).
- Always handle errors explicitly; avoid silent failures.
- Provide meaningful error messages that help with debugging.

**Example:**
```typescript
export class ApiError extends Error {
  public readonly status: number;
  public readonly url: string;

  constructor(message: string, status: number, url: string) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.url = url;
  }
}
```

### API Client Patterns

- Use a centralized API client function (e.g., `getJson<T>`) for all API calls.
- Automatically inject authentication tokens from localStorage when available.
- Use TypeScript generics for type-safe API responses (e.g., `getJson<UserResponse>`).
- Handle network errors and HTTP errors separately with appropriate error types.

**Example:**
```typescript
export async function getJson<T>(url: string, init?: RequestInit): Promise<T> {
  try {
    const token = localStorage.getItem('authToken');
    const headers: Record<string, string> = {
      Accept: 'application/json',
      ...((init?.headers as Record<string, string>) ?? {}),
    };

    if (token && !headers.Authorization) {
      headers.Authorization = `Bearer ${token}`;
    }

    const response = await fetch(url, { ...init, headers });

    if (!response.ok) {
      const text = await response.text().catch(() => '');
      throw new ApiError(
        text || `Request to ${url} failed with status ${response.status}`,
        response.status,
        url,
      );
    }

    return (await response.json()) as T;
  } catch (error) {
    if (error instanceof ApiError) throw error;
    if (error instanceof TypeError && error.message === 'Failed to fetch') {
      throw new ApiError(
        'Network error: Unable to connect to the server.',
        0,
        url,
      );
    }
    throw error;
  }
}
```

---

## TypeScript Express Server Conventions

### Project Structure (Applying SOLID Principles)

- Keep server code in the `server/` directory with separate `tsconfig.json`.
- Use Express Router for organizing routes (e.g., `authRouter`, `githubRouter`).
- **Single Responsibility**: Separate concerns: routes, middleware, services, and database access should be in distinct modules.
- **Dependency Inversion**: Routes should depend on service interfaces, not concrete implementations.
- **Pattern consistency**: Follow existing patterns (e.g., how `auth.ts` and `github.ts` routes are structured) when adding new routes.

### Route Handlers

- Use async/await for asynchronous operations; handle errors appropriately.
- Return early with proper HTTP status codes and JSON responses.
- Validate input data before processing; return 400 for invalid requests.
- Use middleware for cross-cutting concerns (authentication, logging, etc.).
- **Single Responsibility**: Route handlers should delegate business logic to services, not contain it directly.

### Authentication and Middleware

- Use **Supabase Auth** for authentication; do not implement custom JWT generation or password hashing.
- Create custom middleware functions (e.g., `authenticateToken`) that verify Supabase JWT tokens via `supabase.auth.getUser(token)`.
- Extend Express Request types with custom interfaces (e.g., `AuthRequest extends Request`) for `userId`, `email`, and `user`.
- Auth is email-based (login/register use email + password); optional display name in `user_metadata`.
- Store Supabase credentials in environment variables (`SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY`, `SUPABASE_ANON_KEY`); never expose the service role key to the client.
- **Interface Segregation**: Middleware should have focused, single-purpose responsibilities.

### Services (Applying SOLID Principles)

- **Single Responsibility**: Each service should handle one domain or concern (e.g., `githubService` for GitHub API, auth logic in routes).
- **Dependency Inversion**: Services should accept dependencies (like API clients) as parameters or through interfaces.
- **Open/Closed**: Design services to be extensible without modification (e.g., through configuration or strategy patterns).
- **Pattern consistency**: Follow existing service patterns (e.g., `githubService.ts` structure) when creating new services.

### Error Handling

- Always handle errors in async route handlers; return appropriate HTTP status codes.
- Log errors in development; avoid exposing sensitive information in production responses.
- Use try-catch blocks for async operations; handle database errors gracefully.

### Environment Variables

- Validate required environment variables on startup, especially in production.
- Use a centralized config module to access environment variables.
- Provide clear error messages when required environment variables are missing.

### Database and Auth

- Use Supabase client for database operations; check for client availability before use (`if (!supabase) { ... }`).
- **Auth**: User identity is managed by Supabase Auth (`auth.users`); use Supabase Auth API for sign-up, sign-in, password change, and token verification. Do not maintain a separate users table for credentials.
- Handle database and auth errors appropriately; return user-friendly error messages (e.g., surface Supabase error messages when safe).
- Use parameterized queries and proper error handling for all database operations.
- **Dependency Inversion**: Abstract database access behind interfaces when possible to allow for easier testing and future changes.

---

## Authentication Architecture (Supabase Auth)

### Overview

This project uses **Supabase Auth** exclusively for user authentication. Do not implement custom JWT generation, password hashing, or user credential storage.

### Key Components

**Client Side (`src/contexts/AuthContext.tsx`):**
- Manages authentication state via Supabase Auth API
- Stores JWT tokens in localStorage
- Provides `useAuth()` hook for components
- Functions: `login()`, `register()`, `changePassword()`, `logout()`

**Server Side (`server/middleware/auth.ts`):**
- Verifies JWT tokens via `supabase.auth.getUser(token)`
- Extends Express Request with `userId`, `email`, `user` properties
- Returns 401/403 for invalid/missing tokens

**API Client (`src/lib/apiClient.ts` or `src/apiClient.ts`):**
- Automatically injects `Authorization: Bearer <token>` header
- Fetches token from localStorage
- Type-safe with generics: `getJson<T>()`

### Authentication Flow

1. **Registration**: User submits email + password → Supabase creates user → JWT returned → stored in localStorage
2. **Login**: User submits email + password → Supabase verifies → JWT returned → stored in localStorage
3. **Authenticated Requests**: Frontend reads token from localStorage → adds to Authorization header → backend verifies with Supabase
4. **Token Refresh**: Optional refresh tokens can be stored and used to get new access tokens
5. **Logout**: Remove tokens from localStorage → call logout endpoint (optional server cleanup)

### Environment Variables

**Client (`.env`):**
```bash
# Optional - leave empty in dev (uses Vite proxy)
VITE_API_BASE_URL=
```

**Server (`.env`):**
```bash
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key           # Client-safe
SUPABASE_SERVICE_ROLE_KEY=your-service-key # Server-only, admin privileges
```

### Important Files

- `src/contexts/AuthContext.tsx` - Client auth state management
- `server/middleware/auth.ts` - Token verification middleware
- `server/routes/auth.ts` - Auth endpoints (register, login, verify, change-password, logout)
- `server/db/supabase.ts` - Supabase client initialization
- `src/apiClient.ts` or `src/lib/apiClient.ts` - API client with auto token injection

---

## File Organization

### Frontend Structure

```
src/
├── components/          # Reusable UI components
│   ├── Hero.tsx
│   ├── Footer.tsx
│   ├── InfoCard.tsx
│   ├── ProjectsPage.tsx
│   └── ProtectedRoute.tsx
├── pages/              # Page components
│   ├── HomePage.tsx
│   ├── LoginPage.tsx
│   └── ChangePasswordPage.tsx
├── hooks/              # Custom hooks (root level)
│   ├── useGitHubRepos.ts
│   └── useGitHubCommits.ts
├── contexts/           # React contexts
│   └── AuthContext.tsx
├── lib/               # Utility modules
│   └── apiClient.ts
├── test/              # Test utilities
│   └── setup.ts
├── config.ts          # Frontend configuration
├── main.tsx           # App entry point
└── App.tsx            # Root component with routes
```

### Backend Structure

```
server/
├── routes/            # Express routers
│   ├── auth.ts
│   └── github.ts
├── middleware/        # Custom middleware
│   └── auth.ts
├── services/          # Business logic
│   └── githubService.ts
├── db/               # Database
│   ├── supabase.ts
│   └── migrations/
├── config.ts         # Server configuration
└── index.ts          # Server entry point
```

### Naming Conventions

- **Components**: PascalCase (e.g., `Hero.tsx`, `InfoCard.tsx`)
- **Hooks**: camelCase with `use` prefix (e.g., `useGitHubRepos.ts`)
- **Utilities**: camelCase (e.g., `apiClient.ts`, `config.ts`)
- **Server files**: camelCase (e.g., `auth.ts`, `githubService.ts`)
- **Test files**: Same as source + `.test.ts` or `.test.tsx` extension

### Component Composition Patterns

**Page Pattern:**
```typescript
export const HomePage = (): JSX.Element => {
  return (
    <div className="app-shell">
      <Hero />
      <main className="main">
        {/* Page content */}
      </main>
      <Footer />
    </div>
  );
};
```

**Layout Components:**
- Reusable components that structure content (e.g., `Hero`, `Footer`)
- Should not contain page-specific logic
- Accept children or specific props for customization

**Feature Components:**
- Self-contained components with their own data fetching (e.g., `GitHubProjects`)
- Use custom hooks for data management
- Handle loading and error states internally

---

## Protected Routes

Use `ProtectedRoute` wrapper for routes that require authentication:

```typescript
<Route
  path="/change-password"
  element={
    <ProtectedRoute>
      <ChangePasswordPage />
    </ProtectedRoute>
  }
/>
```

**ProtectedRoute implementation:**
- Shows loading state while checking auth
- Redirects to `/login` if not authenticated
- Renders children if authenticated

---

## Environment Configuration

### Frontend (`src/config.ts`)

```typescript
export interface EnvConfig {
  apiBaseUrl: string;
}

export const env: EnvConfig = {
  apiBaseUrl: import.meta.env.VITE_API_BASE_URL || '',
};
```

### Backend (`server/config.ts`)

```typescript
export const config = {
  port: process.env.PORT ? Number.parseInt(process.env.PORT, 10) : 3001,
  githubToken: process.env.GITHUB_TOKEN,
  githubUsername: process.env.GITHUB_USERNAME,
  nodeEnv: process.env.NODE_ENV || 'development',
  allowedOrigins: process.env.ALLOWED_ORIGINS?.split(',').map(o => o.trim()),
  supabaseUrl: process.env.SUPABASE_URL || '',
  supabaseServiceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY || '',
  supabaseAnonKey: process.env.SUPABASE_ANON_KEY || '',
};
```

### Environment Variables

**Frontend (`.env`):**
```bash
# Leave empty in development (uses Vite proxy to /api)
# Set to full backend URL in production (e.g., https://api.yoursite.com)
VITE_API_BASE_URL=
```

**Backend (`.env`):**
```bash
# Server
PORT=3001
NODE_ENV=development

# GitHub API
GITHUB_USERNAME=your-github-username
GITHUB_TOKEN=ghp_your_token_here

# CORS (production only)
# ALLOWED_ORIGINS=https://yoursite.com,https://www.yoursite.com

# Supabase Auth
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
```

### Production Validation

Server validates required environment variables on startup in production:

```typescript
if (config.nodeEnv === 'production') {
  if (!config.supabaseUrl || !config.supabaseServiceRoleKey) {
    console.error('Missing required Supabase credentials');
    process.exit(1);
  }
}
```

---

## Vite Proxy Configuration

**Development Setup** (`vite.config.ts`):

```typescript
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
        secure: false,
        ws: true,
      },
    },
  },
});
```

**Benefits:**
- No CORS issues in development
- Frontend: `http://localhost:5173` → Backend: `http://localhost:3001`
- Requests to `/api/*` automatically proxied
- Matches production URL structure

---

## Testing

### Test Runner and Setup

- **Test runner**: Use **Vitest** for all tests
- **Test setup**: `src/test/setup.ts` (jest-dom, localStorage mock, fetch mock)
- **Configuration**: `vitest.config.ts`
- **Commands**:
  - `pnpm test` - Run all tests once
  - `pnpm test:watch` - Run tests in watch mode
  - `pnpm test:ui` - Run tests with UI
  - `pnpm test:coverage` - Generate coverage report

### Always Add Tests

When creating new features, components, hooks, utilities, routes, middleware, or services, add corresponding tests. Tests should be written alongside the code, not as an afterthought.

### Test Coverage Expectations

- **New functions, utilities, and API clients**: Unit tests
- **New React components**: Component tests using React Testing Library
- **New custom hooks**: Hook tests using `renderHook` from `@testing-library/react`
- **New server routes and middleware**: Tests covering success and error cases (mock Supabase or external deps)
- **New services and business logic**: Comprehensive tests

### React Testing

- Prefer React Testing Library–style tests focusing on user-visible behavior and DOM output.
- Avoid testing implementation details like internal state when possible.
- Test user interactions, not component internals.
- Use `renderHook` for testing custom hooks.
- Use `happy-dom` as the test environment (configured in Vitest).

**Component Test Example:**
```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { Hero } from './Hero';

describe('Hero', () => {
  it('should render the hero title', () => {
    render(<Hero />);
    expect(screen.getByText('1r0nf1st')).toBeInTheDocument();
  });
});
```

**Hook Test Example:**
```typescript
import { describe, it, expect, vi } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { useGitHubRepos } from './useGitHubRepos';
import { getJson } from './apiClient';

vi.mock('./apiClient');

describe('useGitHubRepos', () => {
  it('should fetch repos successfully', async () => {
    const mockRepos = [{ id: 1, name: 'repo1' }];
    vi.mocked(getJson).mockResolvedValue(mockRepos);

    const { result } = renderHook(() => useGitHubRepos());

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(result.current.repos).toEqual(mockRepos);
    expect(result.current.error).toBeNull();
  });
});
```

### Server Testing

- Test route handlers with proper request/response mocking.
- Test middleware in isolation; mock `../db/supabase` so `supabase.auth.getUser` is controlled.
- Use `.js` extension in server imports when required by Node16 module resolution (e.g., `from './auth.js'`).
- Test error handling and edge cases.
- Use table-driven tests for multiple scenarios when appropriate.

**Middleware Test Example:**
```typescript
import { describe, it, expect, vi } from 'vitest';
import type { Request, Response, NextFunction } from 'express';

vi.mock('../db/supabase', () => ({
  supabase: {
    auth: {
      getUser: vi.fn(),
    },
  },
}));

import { authenticateToken } from './auth.js';
import { supabase } from '../db/supabase.js';

describe('authenticateToken', () => {
  it('should return 401 if no authorization header', async () => {
    const mockReq = { headers: {} } as Request;
    const mockRes = {
      status: vi.fn().mockReturnThis(),
      json: vi.fn(),
    } as unknown as Response;
    const mockNext = vi.fn();

    await authenticateToken(mockReq, mockRes, mockNext);

    expect(mockRes.status).toHaveBeenCalledWith(401);
    expect(mockNext).not.toHaveBeenCalled();
  });

  it('should call next() if token is valid', async () => {
    const mockUser = { id: '123', email: 'test@example.com' };
    vi.mocked(supabase!.auth.getUser).mockResolvedValue({
      data: { user: mockUser },
      error: null,
    } as never);

    const mockReq = {
      headers: { authorization: 'Bearer valid-token' },
    } as Request;
    const mockRes = {} as Response;
    const mockNext = vi.fn();

    await authenticateToken(mockReq, mockRes, mockNext);

    expect(mockNext).toHaveBeenCalled();
    expect(mockReq.userId).toBe('123');
  });
});
```

### Test Quality

- Cover error paths and edge cases, not just happy paths.
- Tests should be independent and not rely on execution order.
- Use descriptive test names that explain what is being tested.
- Mock external dependencies (APIs, Supabase, localStorage, fetch, etc.).

### Bug Fixes and Refactoring

- **Bug fixes**: When fixing a bug, add or update a test that would fail without the fix. This ensures the bug doesn't regress.
- **Refactoring**: When refactoring, ensure existing tests still pass. If tests break, update them to match the new implementation while preserving test intent.

### Test Location

Place test files next to the code they test with `.test.ts` or `.test.tsx` extensions (e.g., `apiClient.test.ts` next to `apiClient.ts`).

---

## ESLint Expectations

### Tooling Contract

- Assume ESLint is configured with recommended rule sets (core, TypeScript, React, React Hooks, JSX a11y, and project-specific rules).
- Do not introduce new ESLint errors or warnings; code should be clean after edits.
- Avoid `eslint-disable` comments; if absolutely necessary, scope them narrowly and include a clear justification.

### Typical Code-Quality Checks

- No unused variables, parameters, or imports.
- No unreachable code, duplicate cases, or duplicate keys.
- No accidental globals, `eval`, `with`, or similar dangerous constructs.
- Use strict equality (`===`/`!==`) instead of `==`/`!=` except where explicitly intended.
- Consistent return types from functions; avoid branches that return different kinds of values.
- No direct mutation of React state; use state setters and immutable updates.

### Style and Consistency Checks

- Consistent indentation, spacing, brace style, and line breaks.
- Consistent quote style, semicolons, and trailing commas as defined by the config.
- Stable import ordering and no duplicate imports.

> **Note**: ESLint has a large and evolving rule set. Treat the project ESLint configuration (e.g. `eslint.config.js`) as the single source of truth, and ensure there are zero ESLint violations after changes.

---

## Prettier Expectations

### Single Source of Formatting Truth

- Treat Prettier as the canonical formatter; do not hand-format code against Prettier.
- Always format changed files with Prettier (or an equivalent editor integration) before committing.

### Respect Project Configuration

- Follow the project `.prettierrc*` configuration if present.
- If no configuration is present, assume Prettier defaults and keep formatting consistent.

### No Conflicting Tools

- Avoid introducing other formatters or code style tools that conflict with Prettier.
- Do not change Prettier settings without a clear, documented project decision.

---

## Project Structure and Build Tools

### Package Management

- Use `pnpm` as the package manager; respect `packageManager` field in `package.json`.

### Build System

- **Frontend**: Vite with React SWC plugin for fast builds and HMR.
- **Backend**: `tsx` for development and TypeScript compiler for production builds.
- **Concurrent Development**: Use `concurrently` to run client and server together.

### Type Checking

- Run `pnpm type-check` to validate both client and server TypeScript configurations.

### Separate Configurations

- **Client TypeScript** (`tsconfig.json`): Uses `bundler` module resolution and `react-jsx`.
- **Server TypeScript** (`server/tsconfig.json`): Uses `node16` module resolution for Node.js compatibility.
- Respect the different module systems and target environments.

---

## Tooling and Workflow

### After Non-Trivial Edits

1. Run ESLint for affected files: `pnpm lint`
2. Run Prettier on changed files: `pnpm format`
3. Run type checking: `pnpm type-check`
4. Run tests: `pnpm test` to ensure all tests pass, including new ones

### When Adding New Code

1. Write tests alongside the implementation, not after
2. Run `pnpm test:watch` during development for immediate feedback
3. Ensure new tests pass before considering the feature complete

### Development Workflow

- Use `pnpm dev` to start both client and server concurrently
- Client runs on port 5173 with Vite proxy to server API on port 3001
- Server runs on port 3001; configure via `PORT` environment variable

### Refactoring Approach

- Preserve behavior first, then improve structure and naming
- Prefer small, safe refactors over large risky rewrites
- Apply SOLID principles during refactoring to improve code quality
- Maintain pattern consistency—refactor to match existing patterns rather than introducing new ones

### Commits and Reviewability

- Keep commits logically grouped and well described
- Prefer conventional commit style: `feat:`, `fix:`, `docs:`, `chore:`, `test:`
- Avoid mixing unrelated formatting-only changes with behavioral changes

---

## Go Conventions

> **Note**: This project primarily uses TypeScript, but Go conventions are included for completeness.

### Formatting and Imports

- Always run `gofmt` and `goimports`; treat unformatted code as a bug.
- Group imports as `stdlib`, third-party, then local modules.

### Package Design

- Prefer small, focused packages with clear responsibilities.
- Minimize exported surface area; export only what other packages need.

### Context and I/O

- Accept `context.Context` as the first parameter in functions that do I/O, RPC, or long-running work.
- Propagate contexts instead of creating new background contexts.

### Error Handling

- Never ignore returned errors; handle or propagate them.
- Wrap errors with context using `fmt.Errorf("...: %w", err)` instead of losing the original error.

### State and Concurrency

- Avoid global mutable state; use dependency injection and interfaces.
- Prevent goroutine leaks by honoring context cancellation and using `WaitGroup` or channels for coordination.
- Prefer strong types (`time.Duration`, custom types) over bare integers and strings when appropriate.

---

## Quick Reference

### Common Commands

```bash
# Development
pnpm dev              # Start both client and server
pnpm dev:client       # Start only frontend
pnpm dev:server       # Start only backend

# Building
pnpm build            # Build both client and server
pnpm build:client     # Build frontend
pnpm build:server     # Build backend

# Testing
pnpm test             # Run all tests
pnpm test:watch       # Run tests in watch mode
pnpm test:ui          # Run tests with UI
pnpm test:coverage    # Generate coverage report

# Code Quality
pnpm lint             # Run ESLint
pnpm format           # Format with Prettier
pnpm type-check       # TypeScript type checking
```

### Key File Locations

**Frontend:**
- Entry: `src/main.tsx`
- Config: `vite.config.ts`, `tsconfig.json`
- Auth: `src/contexts/AuthContext.tsx`
- API Client: `src/apiClient.ts`

**Backend:**
- Entry: `server/index.ts`
- Config: `server/config.ts`, `server/tsconfig.json`
- Auth Middleware: `server/middleware/auth.ts`
- Routes: `server/routes/auth.ts`, `server/routes/github.ts`
- Supabase: `server/db/supabase.ts`

**Testing:**
- Config: `vitest.config.ts`
- Setup: `src/test/setup.ts`

---

## Summary for AI Assistants

When working on this project:

1. **Always follow SOLID principles** and maintain pattern consistency
2. **Write tests** for all new features, components, hooks, routes, and services
3. **Use TypeScript** with strict typing; avoid `any`
4. **Use Supabase Auth exclusively** for authentication (no custom JWT/hashing)
5. **Follow React hooks rules** including cleanup with `isCancelled` flags
6. **Keep components small and focused** with single responsibilities
7. **Use custom hooks** for reusable stateful logic with standard return pattern `{ data, isLoading, error }`
8. **Handle errors explicitly** with custom error classes and meaningful messages
9. **Test thoroughly** with Vitest, React Testing Library, and proper mocking
10. **Run linting, formatting, and type-checking** before considering work complete

This project values **readability, maintainability, and type safety** above all else. When in doubt, favor clarity and consistency with existing patterns.
