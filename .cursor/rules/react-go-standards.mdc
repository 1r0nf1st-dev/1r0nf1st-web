---
description: Core Cursor rules for React, TypeScript Express server, ESLint, and Prettier in this project
alwaysApply: true
---

### Purpose

These rules guide the AI when working on this repository, focusing on React frontends, TypeScript Express servers, and alignment with ESLint and Prettier. Always keep changes compatible with existing tooling and project patterns.

### General principles

- **Small, focused changes**: Prefer incremental, reviewable edits over large rewrites.
- **Clarity over cleverness**: Optimize for readability and maintainability.
- **Type safety**: Do not introduce `any` in TypeScript or `interface{}` in Go without strong justification.
- **Dependencies**: Avoid adding new libraries unless clearly necessary; prefer standard library and existing utilities.
- **Testing**: Always add tests when creating new features, fixing bugs, or refactoring code. Tests are not optional—they are a core part of the development process.
- **Security**: **NEVER share `.env` tokens, API keys, secrets, or any sensitive credentials** in code, comments, commit messages, or any other form. Environment variables containing sensitive data must remain private and never be exposed in the codebase or shared publicly.
- **SOLID principles**: Follow SOLID principles to create maintainable, scalable code:
  - **Single Responsibility**: Each module, class, or function should have one reason to change.
  - **Open/Closed**: Open for extension, closed for modification. Use composition and interfaces.
  - **Liskov Substitution**: Subtypes must be substitutable for their base types without breaking functionality.
  - **Interface Segregation**: Prefer small, focused interfaces over large, general ones.
  - **Dependency Inversion**: Depend on abstractions (interfaces/types) rather than concrete implementations.
- **Pattern consistency**: Maintain consistency with existing codebase patterns. When adding new code, follow established patterns rather than introducing new approaches unless there's a compelling reason.

### React (JS/TS) conventions

- **Functional components only**: Use function components and hooks; do not add new class components.
- **Prefer TypeScript**: Use `ts`/`tsx` where possible; keep props and state strongly typed.
- **Component return types**: Use `JSX.Element` as the explicit return type for React components (e.g., `const Component = (): JSX.Element => { ... }`).
- **Hooks rules**:
  - Call hooks only at the top level of React function components or custom hooks.
  - Never call hooks conditionally or in loops.
  - Keep dependency arrays accurate and stable; follow `react-hooks/exhaustive-deps` guidance by refactoring, not disabling.
  - Always clean up side effects in `useEffect`; use cleanup functions and cancellation flags (e.g., `isCancelled`) to prevent memory leaks and race conditions.
- **Component design** (applying SOLID principles):
  - **Single Responsibility**: Keep components small and focused; move complex logic into custom hooks or utilities.
  - **Composition over inheritance**: Prefer composition with props and children to customize behavior.
  - **Separation of concerns**: Avoid "god components" that handle many responsibilities; split into smaller pieces.
  - **Dependency inversion**: Components should depend on props/interfaces, not concrete implementations.
  - **Pattern consistency**: Follow existing component patterns (e.g., how Hero, Footer, or InfoCard are structured) when creating new components.
- **Custom hooks**:
  - Extract reusable stateful logic into custom hooks (e.g., `useGitHubRepos`, `useAuth`).
  - Custom hooks should return objects or tuples with clear, descriptive property names.
  - Include loading and error states in custom hook return values for better UX.
- **Rendering and side effects**:
  - Do not perform side effects inside render; use `useEffect` or event handlers instead.
  - Avoid inline object/array literals in props that cause unnecessary re-renders; memoize when performance matters.
- **Context API**:
  - Use Context API for shared state that needs to be accessed across multiple components.
  - Always provide a custom hook (e.g., `useAuth`) to access context values; throw errors if used outside provider.
  - Keep context providers focused on a single concern; avoid creating overly broad contexts.

### React accessibility and UX

- **Semantic HTML**: Use `button`, `a`, `nav`, `main`, `header`, etc. instead of generic `div`/`span` for interactive elements.
- **Keyboard access**: All interactive elements must be focusable and operable with keyboard only.
- **Labels and ARIA**:
  - Provide meaningful `alt` text for images.
  - Use `aria-label`, `aria-describedby`, and roles where appropriate.
  - Avoid `onClick` on non-interactive elements; use buttons or links instead.
- **Focus styles**: Do not remove focus outlines without providing an accessible alternative that is clearly visible.
- **Predictable UX**: Favor simple, predictable interactions; avoid surprising behavior and heavy animations that hurt usability.

### TypeScript / JavaScript specifics

- **Variable declarations**: Prefer `const`, then `let`; never use `var`.
- **Type imports**: Use `import type` for type-only imports to improve build performance and clarity (e.g., `import type { JSX } from 'react'`).
- **Types**:
  - Avoid `any` and `unknown`; use precise interfaces and types.
  - Use discriminated unions and enums instead of stringly-typed logic.
  - Keep shared types in dedicated modules only when they are truly shared.
  - Use interface extensions for extending existing types (e.g., `interface AuthRequest extends Request`).
- **Modules and structure** (applying SOLID principles):
  - **Single Responsibility**: Keep files cohesive; avoid mixing unrelated concerns.
  - **DRY (Don't Repeat Yourself)**: Extract shared utilities instead of duplicating logic.
  - **Pattern consistency**: Follow existing module patterns (e.g., how `apiClient.ts` or `config.ts` are structured) when creating new modules.
  - **Dependency Inversion**: Modules should depend on abstractions (types/interfaces) rather than concrete implementations.
- **Error handling**:
  - Create custom error classes for domain-specific errors (e.g., `ApiError` with status codes).
  - Always handle errors explicitly; avoid silent failures.
  - Provide meaningful error messages that help with debugging.
- **API client patterns**:
  - Use a centralized API client function (e.g., `getJson<T>`) for all API calls.
  - Automatically inject authentication tokens from localStorage when available.
  - Use TypeScript generics for type-safe API responses (e.g., `getJson<UserResponse>`).
  - Handle network errors and HTTP errors separately with appropriate error types.

### TypeScript Express Server conventions

- **Project structure** (applying SOLID principles):
  - Keep server code in the `server/` directory with separate `tsconfig.json`.
  - Use Express Router for organizing routes (e.g., `authRouter`, `githubRouter`).
  - **Single Responsibility**: Separate concerns: routes, middleware, services, and database access should be in distinct modules.
  - **Dependency Inversion**: Routes should depend on service interfaces, not concrete implementations.
  - **Pattern consistency**: Follow existing patterns (e.g., how `auth.ts` and `github.ts` routes are structured) when adding new routes.
- **Route handlers**:
  - Use async/await for asynchronous operations; handle errors appropriately.
  - Return early with proper HTTP status codes and JSON responses.
  - Validate input data before processing; return 400 for invalid requests.
  - Use middleware for cross-cutting concerns (authentication, logging, etc.).
  - **Single Responsibility**: Route handlers should delegate business logic to services, not contain it directly.
- **Authentication and middleware**:
  - Create custom middleware functions (e.g., `authenticateToken`) for protected routes.
  - Extend Express Request types with custom interfaces (e.g., `AuthRequest extends Request`).
  - Use JWT tokens for authentication; store secrets securely in environment variables.
  - **Interface Segregation**: Middleware should have focused, single-purpose responsibilities.
- **Services** (applying SOLID principles):
  - **Single Responsibility**: Each service should handle one domain or concern (e.g., `githubService` for GitHub API, auth logic in routes).
  - **Dependency Inversion**: Services should accept dependencies (like API clients) as parameters or through interfaces.
  - **Open/Closed**: Design services to be extensible without modification (e.g., through configuration or strategy patterns).
  - **Pattern consistency**: Follow existing service patterns (e.g., `githubService.ts` structure) when creating new services.
- **Error handling**:
  - Always handle errors in async route handlers; return appropriate HTTP status codes.
  - Log errors in development; avoid exposing sensitive information in production responses.
  - Use try-catch blocks for async operations; handle database errors gracefully.
- **Environment variables**:
  - Validate required environment variables on startup, especially in production.
  - Use a centralized config module to access environment variables.
  - Provide clear error messages when required environment variables are missing.
- **Database access**:
  - Use Supabase client for database operations; check for client availability before use.
  - Handle database errors appropriately; return user-friendly error messages.
  - Use parameterized queries and proper error handling for all database operations.
  - **Dependency Inversion**: Abstract database access behind interfaces when possible to allow for easier testing and future changes.

### Go conventions

- **Formatting and imports**:
  - Always run `gofmt` and `goimports`; treat unformatted code as a bug.
  - Group imports as `stdlib`, third-party, then local modules.
- **Package design**:
  - Prefer small, focused packages with clear responsibilities.
  - Minimize exported surface area; export only what other packages need.
- **Context and I/O**:
  - Accept `context.Context` as the first parameter in functions that do I/O, RPC, or long-running work.
  - Propagate contexts instead of creating new background contexts.
- **Error handling**:
  - Never ignore returned errors; handle or propagate them.
  - Wrap errors with context using `fmt.Errorf("...: %w", err)` instead of losing the original error.
- **State and concurrency**:
  - Avoid global mutable state; use dependency injection and interfaces.
  - Prevent goroutine leaks by honoring context cancellation and using `WaitGroup` or channels for coordination.
  - Prefer strong types (`time.Duration`, custom types) over bare integers and strings when appropriate.

### Testing

- **Always add tests**: When creating new features, components, hooks, utilities, routes, middleware, or services, add corresponding tests. Tests should be written alongside the code, not as an afterthought.
- **Test coverage expectations**:
  - New functions, utilities, and API clients should have unit tests.
  - New React components should have component tests using React Testing Library.
  - New custom hooks should have hook tests using `renderHook`.
  - New server routes and middleware should have tests covering success and error cases.
  - New services and business logic should have comprehensive tests.
- **React testing**:
  - Prefer React Testing Library–style tests focusing on user-visible behavior and DOM output.
  - Avoid testing implementation details like internal state when possible.
  - Test user interactions, not component internals.
  - Use `renderHook` for testing custom hooks.
- **Server testing**:
  - Test route handlers with proper request/response mocking.
  - Test middleware functions in isolation.
  - Test error handling and edge cases.
  - Use table-driven tests for multiple scenarios.
- **Test quality**:
  - Cover error paths and edge cases, not just happy paths.
  - Tests should be independent and not rely on execution order.
  - Use descriptive test names that explain what is being tested.
  - Mock external dependencies (APIs, databases, localStorage, etc.).
- **Bug fixes**: When fixing a bug, add or update a test that would fail without the fix. This ensures the bug doesn't regress.
- **Refactoring**: When refactoring, ensure existing tests still pass. If tests break, update them to match the new implementation while preserving test intent.
- **Test location**: Place test files next to the code they test with `.test.ts` or `.test.tsx` extensions (e.g., `apiClient.test.ts` next to `apiClient.ts`).

### ESLint expectations (summary)

- **Tooling contract**:
  - Assume ESLint is configured with recommended rule sets (core, TypeScript, React, React Hooks, JSX a11y, and project-specific rules).
  - Do not introduce new ESLint errors or warnings; code should be clean after edits.
  - Avoid `eslint-disable` comments; if absolutely necessary, scope them narrowly and include a clear justification.
- **Typical code-quality checks to respect**:
  - No unused variables, parameters, or imports.
  - No unreachable code, duplicate cases, or duplicate keys.
  - No accidental globals, `eval`, `with`, or similar dangerous constructs.
  - Use strict equality (`===`/`!==`) instead of `==`/`!=` except where explicitly intended.
  - Consistent return types from functions; avoid branches that return different kinds of values.
  - No direct mutation of React state; use state setters and immutable updates.
- **Typical style and consistency checks**:
  - Consistent indentation, spacing, brace style, and line breaks.
  - Consistent quote style, semicolons, and trailing commas as defined by the config.
  - Stable import ordering and no duplicate imports.

> ESLint has a large and evolving rule set. Treat the project `.eslintrc*` configuration as the single source of truth, and ensure there are zero ESLint violations after changes.

### Prettier expectations (summary)

- **Single source of formatting truth**:
  - Treat Prettier as the canonical formatter; do not hand-format code against Prettier.
  - Always format changed files with Prettier (or an equivalent editor integration) before committing.
- **Respect project configuration**:
  - Follow the project `.prettierrc*` configuration if present.
  - If no configuration is present, assume Prettier defaults and keep formatting consistent.
- **No conflicting tools**:
  - Avoid introducing other formatters or code style tools that conflict with Prettier.
  - Do not change Prettier settings without a clear, documented project decision.

### Project structure and build tools

- **Package management**: Use `pnpm` as the package manager; respect `packageManager` field in `package.json`.
- **Build system**:
  - Frontend uses Vite with React SWC plugin for fast builds and HMR.
  - Server uses `tsx` for development and TypeScript compiler for production builds.
  - Use `concurrently` to run client and server together in development.
- **Type checking**: Run `pnpm type-check` to validate both client and server TypeScript configurations.
- **Separate configurations**:
  - Client TypeScript config (`tsconfig.json`) uses `bundler` module resolution and `react-jsx`.
  - Server TypeScript config (`server/tsconfig.json`) uses `node16` module resolution for Node.js compatibility.
  - Respect the different module systems and target environments.

### Tooling and workflow

- **After non-trivial edits**:
  - Run ESLint for affected JS/TS/React files: `pnpm lint`.
  - Run Prettier or the editor formatter on changed files: `pnpm format`.
  - Run type checking: `pnpm type-check`.
  - Run tests: `pnpm test` to ensure all tests pass, including new ones.
  - For Go changes, run `go test ./...` or at least tests for affected packages.
- **When adding new code**:
  - Write tests alongside the implementation, not after.
  - Run `pnpm test:watch` during development to get immediate feedback.
  - Ensure new tests pass before considering the feature complete.
- **Development workflow**:
  - Use `pnpm dev` to start both client and server concurrently.
  - Client runs on port 5173 with Vite proxy to server API on port 3001.
  - Server runs on port 3001; configure via `PORT` environment variable.
- **Refactoring approach**:
  - Preserve behavior first, then improve structure and naming.
  - Prefer small, safe refactors over large risky rewrites.
  - Apply SOLID principles during refactoring to improve code quality.
  - Maintain pattern consistency—refactor to match existing patterns rather than introducing new ones.
- **Commits and reviewability**:
  - Keep commits logically grouped and well described.
  - Avoid mixing unrelated formatting-only changes with behavioral changes.

