---
description: Core Cursor rules for React, Go, ESLint, and Prettier in this project
alwaysApply: true
---

### Purpose

These rules guide the AI when working on this repository, focusing on React frontends, Go services, and alignment with ESLint and Prettier. Always keep changes compatible with existing tooling and project patterns.

### General principles

- **Small, focused changes**: Prefer incremental, reviewable edits over large rewrites.
- **Clarity over cleverness**: Optimize for readability and maintainability.
- **Type safety**: Do not introduce `any` in TypeScript or `interface{}` in Go without strong justification.
- **Dependencies**: Avoid adding new libraries unless clearly necessary; prefer standard library and existing utilities.

### React (JS/TS) conventions

- **Functional components only**: Use function components and hooks; do not add new class components.
- **Prefer TypeScript**: Use `ts`/`tsx` where possible; keep props and state strongly typed.
- **Hooks rules**:
  - Call hooks only at the top level of React function components or custom hooks.
  - Never call hooks conditionally or in loops.
  - Keep dependency arrays accurate and stable; follow `react-hooks/exhaustive-deps` guidance by refactoring, not disabling.
- **Component design**:
  - Keep components small and focused; move complex logic into custom hooks or utilities.
  - Prefer composition over inheritance; use props and children to customize behavior.
  - Avoid "god components" that handle many responsibilities; split into smaller pieces.
- **Rendering and side effects**:
  - Do not perform side effects inside render; use `useEffect` or event handlers instead.
  - Avoid inline object/array literals in props that cause unnecessary re-renders; memoize when performance matters.

### React accessibility and UX

- **Semantic HTML**: Use `button`, `a`, `nav`, `main`, `header`, etc. instead of generic `div`/`span` for interactive elements.
- **Keyboard access**: All interactive elements must be focusable and operable with keyboard only.
- **Labels and ARIA**:
  - Provide meaningful `alt` text for images.
  - Use `aria-label`, `aria-describedby`, and roles where appropriate.
  - Avoid `onClick` on non-interactive elements; use buttons or links instead.
- **Focus styles**: Do not remove focus outlines without providing an accessible alternative that is clearly visible.
- **Predictable UX**: Favor simple, predictable interactions; avoid surprising behavior and heavy animations that hurt usability.

### TypeScript / JavaScript specifics

- **Variable declarations**: Prefer `const`, then `let`; never use `var`.
- **Types**:
  - Avoid `any` and `unknown`; use precise interfaces and types.
  - Use discriminated unions and enums instead of stringly-typed logic.
  - Keep shared types in dedicated modules only when they are truly shared.
- **Modules and structure**:
  - Keep files cohesive; avoid mixing unrelated concerns.
  - Extract shared utilities instead of duplicating logic.

### Go conventions

- **Formatting and imports**:
  - Always run `gofmt` and `goimports`; treat unformatted code as a bug.
  - Group imports as `stdlib`, third-party, then local modules.
- **Package design**:
  - Prefer small, focused packages with clear responsibilities.
  - Minimize exported surface area; export only what other packages need.
- **Context and I/O**:
  - Accept `context.Context` as the first parameter in functions that do I/O, RPC, or long-running work.
  - Propagate contexts instead of creating new background contexts.
- **Error handling**:
  - Never ignore returned errors; handle or propagate them.
  - Wrap errors with context using `fmt.Errorf("...: %w", err)` instead of losing the original error.
- **State and concurrency**:
  - Avoid global mutable state; use dependency injection and interfaces.
  - Prevent goroutine leaks by honoring context cancellation and using `WaitGroup` or channels for coordination.
  - Prefer strong types (`time.Duration`, custom types) over bare integers and strings when appropriate.

### Testing

- **React**:
  - Prefer React Testing Libraryâ€“style tests focusing on user-visible behavior and DOM output.
  - Avoid testing implementation details like internal state when possible.
- **Go**:
  - Use table-driven tests and keep test data close to tests.
  - Cover error paths and edge cases, not just happy paths.
- **Bug fixes**: When fixing a bug, add or update a test that would fail without the fix.

### ESLint expectations (summary)

- **Tooling contract**:
  - Assume ESLint is configured with recommended rule sets (core, TypeScript, React, React Hooks, JSX a11y, and project-specific rules).
  - Do not introduce new ESLint errors or warnings; code should be clean after edits.
  - Avoid `eslint-disable` comments; if absolutely necessary, scope them narrowly and include a clear justification.
- **Typical code-quality checks to respect**:
  - No unused variables, parameters, or imports.
  - No unreachable code, duplicate cases, or duplicate keys.
  - No accidental globals, `eval`, `with`, or similar dangerous constructs.
  - Use strict equality (`===`/`!==`) instead of `==`/`!=` except where explicitly intended.
  - Consistent return types from functions; avoid branches that return different kinds of values.
  - No direct mutation of React state; use state setters and immutable updates.
- **Typical style and consistency checks**:
  - Consistent indentation, spacing, brace style, and line breaks.
  - Consistent quote style, semicolons, and trailing commas as defined by the config.
  - Stable import ordering and no duplicate imports.

> ESLint has a large and evolving rule set. Treat the project `.eslintrc*` configuration as the single source of truth, and ensure there are zero ESLint violations after changes.

### Prettier expectations (summary)

- **Single source of formatting truth**:
  - Treat Prettier as the canonical formatter; do not hand-format code against Prettier.
  - Always format changed files with Prettier (or an equivalent editor integration) before committing.
- **Respect project configuration**:
  - Follow the project `.prettierrc*` configuration if present.
  - If no configuration is present, assume Prettier defaults and keep formatting consistent.
- **No conflicting tools**:
  - Avoid introducing other formatters or code style tools that conflict with Prettier.
  - Do not change Prettier settings without a clear, documented project decision.

### Tooling and workflow

- **After non-trivial edits**:
  - Run ESLint for affected JS/TS/React files.
  - Run Prettier or the editor formatter on changed files.
  - For Go changes, run `go test ./...` or at least tests for affected packages.
- **Refactoring approach**:
  - Preserve behavior first, then improve structure and naming.
  - Prefer small, safe refactors over large risky rewrites.
- **Commits and reviewability**:
  - Keep commits logically grouped and well described.
  - Avoid mixing unrelated formatting-only changes with behavioral changes.

