"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-tables@1.8.5";
exports.ids = ["vendor-chunks/prosemirror-tables@1.8.5"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/prosemirror-tables@1.8.5/node_modules/prosemirror-tables/dist/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/prosemirror-tables@1.8.5/node_modules/prosemirror-tables/dist/index.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellBookmark: () => (/* binding */ CellBookmark),\n/* harmony export */   CellSelection: () => (/* binding */ CellSelection),\n/* harmony export */   ResizeState: () => (/* binding */ ResizeState),\n/* harmony export */   TableMap: () => (/* binding */ TableMap),\n/* harmony export */   TableView: () => (/* binding */ TableView),\n/* harmony export */   __clipCells: () => (/* binding */ clipCells),\n/* harmony export */   __insertCells: () => (/* binding */ insertCells),\n/* harmony export */   __pastedCells: () => (/* binding */ pastedCells),\n/* harmony export */   addColSpan: () => (/* binding */ addColSpan),\n/* harmony export */   addColumn: () => (/* binding */ addColumn),\n/* harmony export */   addColumnAfter: () => (/* binding */ addColumnAfter),\n/* harmony export */   addColumnBefore: () => (/* binding */ addColumnBefore),\n/* harmony export */   addRow: () => (/* binding */ addRow),\n/* harmony export */   addRowAfter: () => (/* binding */ addRowAfter),\n/* harmony export */   addRowBefore: () => (/* binding */ addRowBefore),\n/* harmony export */   cellAround: () => (/* binding */ cellAround),\n/* harmony export */   cellNear: () => (/* binding */ cellNear),\n/* harmony export */   colCount: () => (/* binding */ colCount),\n/* harmony export */   columnIsHeader: () => (/* binding */ columnIsHeader),\n/* harmony export */   columnResizing: () => (/* binding */ columnResizing),\n/* harmony export */   columnResizingPluginKey: () => (/* binding */ columnResizingPluginKey),\n/* harmony export */   deleteCellSelection: () => (/* binding */ deleteCellSelection),\n/* harmony export */   deleteColumn: () => (/* binding */ deleteColumn),\n/* harmony export */   deleteRow: () => (/* binding */ deleteRow),\n/* harmony export */   deleteTable: () => (/* binding */ deleteTable),\n/* harmony export */   findCell: () => (/* binding */ findCell),\n/* harmony export */   findCellPos: () => (/* binding */ findCellPos),\n/* harmony export */   findCellRange: () => (/* binding */ findCellRange),\n/* harmony export */   findTable: () => (/* binding */ findTable),\n/* harmony export */   fixTables: () => (/* binding */ fixTables),\n/* harmony export */   fixTablesKey: () => (/* binding */ fixTablesKey),\n/* harmony export */   goToNextCell: () => (/* binding */ goToNextCell),\n/* harmony export */   handlePaste: () => (/* binding */ handlePaste),\n/* harmony export */   inSameTable: () => (/* binding */ inSameTable),\n/* harmony export */   isInTable: () => (/* binding */ isInTable),\n/* harmony export */   mergeCells: () => (/* binding */ mergeCells),\n/* harmony export */   moveCellForward: () => (/* binding */ moveCellForward),\n/* harmony export */   moveTableColumn: () => (/* binding */ moveTableColumn),\n/* harmony export */   moveTableRow: () => (/* binding */ moveTableRow),\n/* harmony export */   nextCell: () => (/* binding */ nextCell),\n/* harmony export */   pointsAtCell: () => (/* binding */ pointsAtCell),\n/* harmony export */   removeColSpan: () => (/* binding */ removeColSpan),\n/* harmony export */   removeColumn: () => (/* binding */ removeColumn),\n/* harmony export */   removeRow: () => (/* binding */ removeRow),\n/* harmony export */   rowIsHeader: () => (/* binding */ rowIsHeader),\n/* harmony export */   selectedRect: () => (/* binding */ selectedRect),\n/* harmony export */   selectionCell: () => (/* binding */ selectionCell),\n/* harmony export */   setCellAttr: () => (/* binding */ setCellAttr),\n/* harmony export */   splitCell: () => (/* binding */ splitCell),\n/* harmony export */   splitCellWithType: () => (/* binding */ splitCellWithType),\n/* harmony export */   tableEditing: () => (/* binding */ tableEditing),\n/* harmony export */   tableEditingKey: () => (/* binding */ tableEditingKey),\n/* harmony export */   tableNodeTypes: () => (/* binding */ tableNodeTypes),\n/* harmony export */   tableNodes: () => (/* binding */ tableNodes),\n/* harmony export */   toggleHeader: () => (/* binding */ toggleHeader),\n/* harmony export */   toggleHeaderCell: () => (/* binding */ toggleHeaderCell),\n/* harmony export */   toggleHeaderColumn: () => (/* binding */ toggleHeaderColumn),\n/* harmony export */   toggleHeaderRow: () => (/* binding */ toggleHeaderRow),\n/* harmony export */   updateColumnsOnResize: () => (/* binding */ updateColumnsOnResize)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/.pnpm/prosemirror-state@1.4.4/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/.pnpm/prosemirror-model@1.25.4/node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/.pnpm/prosemirror-view@1.41.6/node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/.pnpm/prosemirror-keymap@1.2.3/node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/.pnpm/prosemirror-transform@1.11.0/node_modules/prosemirror-transform/dist/index.js\");\n\n\n\n\n\n\n//#region src/tablemap.ts\nlet readFromCache;\nlet addToCache;\nif (typeof WeakMap != \"undefined\") {\n\tlet cache = /* @__PURE__ */ new WeakMap();\n\treadFromCache = (key) => cache.get(key);\n\taddToCache = (key, value) => {\n\t\tcache.set(key, value);\n\t\treturn value;\n\t};\n} else {\n\tconst cache = [];\n\tconst cacheSize = 10;\n\tlet cachePos = 0;\n\treadFromCache = (key) => {\n\t\tfor (let i = 0; i < cache.length; i += 2) if (cache[i] == key) return cache[i + 1];\n\t};\n\taddToCache = (key, value) => {\n\t\tif (cachePos == cacheSize) cachePos = 0;\n\t\tcache[cachePos++] = key;\n\t\treturn cache[cachePos++] = value;\n\t};\n}\n/**\n* A table map describes the structure of a given table. To avoid\n* recomputing them all the time, they are cached per table node. To\n* be able to do that, positions saved in the map are relative to the\n* start of the table, rather than the start of the document.\n*\n* @public\n*/\nvar TableMap = class {\n\tconstructor(width, height, map, problems) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.map = map;\n\t\tthis.problems = problems;\n\t}\n\tfindCell(pos) {\n\t\tfor (let i = 0; i < this.map.length; i++) {\n\t\t\tconst curPos = this.map[i];\n\t\t\tif (curPos != pos) continue;\n\t\t\tconst left = i % this.width;\n\t\t\tconst top = i / this.width | 0;\n\t\t\tlet right = left + 1;\n\t\t\tlet bottom = top + 1;\n\t\t\tfor (let j = 1; right < this.width && this.map[i + j] == curPos; j++) right++;\n\t\t\tfor (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) bottom++;\n\t\t\treturn {\n\t\t\t\tleft,\n\t\t\t\ttop,\n\t\t\t\tright,\n\t\t\t\tbottom\n\t\t\t};\n\t\t}\n\t\tthrow new RangeError(`No cell with offset ${pos} found`);\n\t}\n\tcolCount(pos) {\n\t\tfor (let i = 0; i < this.map.length; i++) if (this.map[i] == pos) return i % this.width;\n\t\tthrow new RangeError(`No cell with offset ${pos} found`);\n\t}\n\tnextCell(pos, axis, dir) {\n\t\tconst { left, right, top, bottom } = this.findCell(pos);\n\t\tif (axis == \"horiz\") {\n\t\t\tif (dir < 0 ? left == 0 : right == this.width) return null;\n\t\t\treturn this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n\t\t} else {\n\t\t\tif (dir < 0 ? top == 0 : bottom == this.height) return null;\n\t\t\treturn this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n\t\t}\n\t}\n\trectBetween(a, b) {\n\t\tconst { left: leftA, right: rightA, top: topA, bottom: bottomA } = this.findCell(a);\n\t\tconst { left: leftB, right: rightB, top: topB, bottom: bottomB } = this.findCell(b);\n\t\treturn {\n\t\t\tleft: Math.min(leftA, leftB),\n\t\t\ttop: Math.min(topA, topB),\n\t\t\tright: Math.max(rightA, rightB),\n\t\t\tbottom: Math.max(bottomA, bottomB)\n\t\t};\n\t}\n\tcellsInRect(rect) {\n\t\tconst result = [];\n\t\tconst seen = {};\n\t\tfor (let row = rect.top; row < rect.bottom; row++) for (let col = rect.left; col < rect.right; col++) {\n\t\t\tconst index = row * this.width + col;\n\t\t\tconst pos = this.map[index];\n\t\t\tif (seen[pos]) continue;\n\t\t\tseen[pos] = true;\n\t\t\tif (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) continue;\n\t\t\tresult.push(pos);\n\t\t}\n\t\treturn result;\n\t}\n\tpositionAt(row, col, table) {\n\t\tfor (let i = 0, rowStart = 0;; i++) {\n\t\t\tconst rowEnd = rowStart + table.child(i).nodeSize;\n\t\t\tif (i == row) {\n\t\t\t\tlet index = col + row * this.width;\n\t\t\t\tconst rowEndIndex = (row + 1) * this.width;\n\t\t\t\twhile (index < rowEndIndex && this.map[index] < rowStart) index++;\n\t\t\t\treturn index == rowEndIndex ? rowEnd - 1 : this.map[index];\n\t\t\t}\n\t\t\trowStart = rowEnd;\n\t\t}\n\t}\n\tstatic get(table) {\n\t\treturn readFromCache(table) || addToCache(table, computeMap(table));\n\t}\n};\nfunction computeMap(table) {\n\tif (table.type.spec.tableRole != \"table\") throw new RangeError(\"Not a table node: \" + table.type.name);\n\tconst width = findWidth(table), height = table.childCount;\n\tconst map = [];\n\tlet mapPos = 0;\n\tlet problems = null;\n\tconst colWidths = [];\n\tfor (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n\tfor (let row = 0, pos = 0; row < height; row++) {\n\t\tconst rowNode = table.child(row);\n\t\tpos++;\n\t\tfor (let i = 0;; i++) {\n\t\t\twhile (mapPos < map.length && map[mapPos] != 0) mapPos++;\n\t\t\tif (i == rowNode.childCount) break;\n\t\t\tconst cellNode = rowNode.child(i);\n\t\t\tconst { colspan, rowspan, colwidth } = cellNode.attrs;\n\t\t\tfor (let h = 0; h < rowspan; h++) {\n\t\t\t\tif (h + row >= height) {\n\t\t\t\t\t(problems || (problems = [])).push({\n\t\t\t\t\t\ttype: \"overlong_rowspan\",\n\t\t\t\t\t\tpos,\n\t\t\t\t\t\tn: rowspan - h\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst start = mapPos + h * width;\n\t\t\t\tfor (let w = 0; w < colspan; w++) {\n\t\t\t\t\tif (map[start + w] == 0) map[start + w] = pos;\n\t\t\t\t\telse (problems || (problems = [])).push({\n\t\t\t\t\t\ttype: \"collision\",\n\t\t\t\t\t\trow,\n\t\t\t\t\t\tpos,\n\t\t\t\t\t\tn: colspan - w\n\t\t\t\t\t});\n\t\t\t\t\tconst colW = colwidth && colwidth[w];\n\t\t\t\t\tif (colW) {\n\t\t\t\t\t\tconst widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n\t\t\t\t\t\tif (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n\t\t\t\t\t\t\tcolWidths[widthIndex] = colW;\n\t\t\t\t\t\t\tcolWidths[widthIndex + 1] = 1;\n\t\t\t\t\t\t} else if (prev == colW) colWidths[widthIndex + 1]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapPos += colspan;\n\t\t\tpos += cellNode.nodeSize;\n\t\t}\n\t\tconst expectedPos = (row + 1) * width;\n\t\tlet missing = 0;\n\t\twhile (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n\t\tif (missing) (problems || (problems = [])).push({\n\t\t\ttype: \"missing\",\n\t\t\trow,\n\t\t\tn: missing\n\t\t});\n\t\tpos++;\n\t}\n\tif (width === 0 || height === 0) (problems || (problems = [])).push({ type: \"zero_sized\" });\n\tconst tableMap = new TableMap(width, height, map, problems);\n\tlet badWidths = false;\n\tfor (let i = 0; !badWidths && i < colWidths.length; i += 2) if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n\tif (badWidths) findBadColWidths(tableMap, colWidths, table);\n\treturn tableMap;\n}\nfunction findWidth(table) {\n\tlet width = -1;\n\tlet hasRowSpan = false;\n\tfor (let row = 0; row < table.childCount; row++) {\n\t\tconst rowNode = table.child(row);\n\t\tlet rowWidth = 0;\n\t\tif (hasRowSpan) for (let j = 0; j < row; j++) {\n\t\t\tconst prevRow = table.child(j);\n\t\t\tfor (let i = 0; i < prevRow.childCount; i++) {\n\t\t\t\tconst cell = prevRow.child(i);\n\t\t\t\tif (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < rowNode.childCount; i++) {\n\t\t\tconst cell = rowNode.child(i);\n\t\t\trowWidth += cell.attrs.colspan;\n\t\t\tif (cell.attrs.rowspan > 1) hasRowSpan = true;\n\t\t}\n\t\tif (width == -1) width = rowWidth;\n\t\telse if (width != rowWidth) width = Math.max(width, rowWidth);\n\t}\n\treturn width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n\tif (!map.problems) map.problems = [];\n\tconst seen = {};\n\tfor (let i = 0; i < map.map.length; i++) {\n\t\tconst pos = map.map[i];\n\t\tif (seen[pos]) continue;\n\t\tseen[pos] = true;\n\t\tconst node = table.nodeAt(pos);\n\t\tif (!node) throw new RangeError(`No cell with offset ${pos} found`);\n\t\tlet updated = null;\n\t\tconst attrs = node.attrs;\n\t\tfor (let j = 0; j < attrs.colspan; j++) {\n\t\t\tconst colWidth = colWidths[(i + j) % map.width * 2];\n\t\t\tif (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth)) (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n\t\t}\n\t\tif (updated) map.problems.unshift({\n\t\t\ttype: \"colwidth mismatch\",\n\t\t\tpos,\n\t\t\tcolwidth: updated\n\t\t});\n\t}\n}\nfunction freshColWidth(attrs) {\n\tif (attrs.colwidth) return attrs.colwidth.slice();\n\tconst result = [];\n\tfor (let i = 0; i < attrs.colspan; i++) result.push(0);\n\treturn result;\n}\n\n//#endregion\n//#region src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n\tif (typeof dom === \"string\") return {};\n\tconst widthAttr = dom.getAttribute(\"data-colwidth\");\n\tconst widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n\tconst colspan = Number(dom.getAttribute(\"colspan\") || 1);\n\tconst result = {\n\t\tcolspan,\n\t\trowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n\t\tcolwidth: widths && widths.length == colspan ? widths : null\n\t};\n\tfor (const prop in extraAttrs) {\n\t\tconst getter = extraAttrs[prop].getFromDOM;\n\t\tconst value = getter && getter(dom);\n\t\tif (value != null) result[prop] = value;\n\t}\n\treturn result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n\tconst attrs = {};\n\tif (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n\tif (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n\tif (node.attrs.colwidth) attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n\tfor (const prop in extraAttrs) {\n\t\tconst setter = extraAttrs[prop].setDOMAttr;\n\t\tif (setter) setter(node.attrs[prop], attrs);\n\t}\n\treturn attrs;\n}\nfunction validateColwidth(value) {\n\tif (value === null) return;\n\tif (!Array.isArray(value)) throw new TypeError(\"colwidth must be null or an array\");\n\tfor (const item of value) if (typeof item !== \"number\") throw new TypeError(\"colwidth must be null or an array of numbers\");\n}\n/**\n* This function creates a set of [node\n* specs](http://prosemirror.net/docs/ref/#model.SchemaSpec.nodes) for\n* `table`, `table_row`, and `table_cell` nodes types as used by this\n* module. The result can then be added to the set of nodes when\n* creating a schema.\n*\n* @public\n*/\nfunction tableNodes(options) {\n\tconst extraAttrs = options.cellAttributes || {};\n\tconst cellAttrs = {\n\t\tcolspan: {\n\t\t\tdefault: 1,\n\t\t\tvalidate: \"number\"\n\t\t},\n\t\trowspan: {\n\t\t\tdefault: 1,\n\t\t\tvalidate: \"number\"\n\t\t},\n\t\tcolwidth: {\n\t\t\tdefault: null,\n\t\t\tvalidate: validateColwidth\n\t\t}\n\t};\n\tfor (const prop in extraAttrs) cellAttrs[prop] = {\n\t\tdefault: extraAttrs[prop].default,\n\t\tvalidate: extraAttrs[prop].validate\n\t};\n\treturn {\n\t\ttable: {\n\t\t\tcontent: \"table_row+\",\n\t\t\ttableRole: \"table\",\n\t\t\tisolating: true,\n\t\t\tgroup: options.tableGroup,\n\t\t\tparseDOM: [{ tag: \"table\" }],\n\t\t\ttoDOM() {\n\t\t\t\treturn [\"table\", [\"tbody\", 0]];\n\t\t\t}\n\t\t},\n\t\ttable_row: {\n\t\t\tcontent: \"(table_cell | table_header)*\",\n\t\t\ttableRole: \"row\",\n\t\t\tparseDOM: [{ tag: \"tr\" }],\n\t\t\ttoDOM() {\n\t\t\t\treturn [\"tr\", 0];\n\t\t\t}\n\t\t},\n\t\ttable_cell: {\n\t\t\tcontent: options.cellContent,\n\t\t\tattrs: cellAttrs,\n\t\t\ttableRole: \"cell\",\n\t\t\tisolating: true,\n\t\t\tparseDOM: [{\n\t\t\t\ttag: \"td\",\n\t\t\t\tgetAttrs: (dom) => getCellAttrs(dom, extraAttrs)\n\t\t\t}],\n\t\t\ttoDOM(node) {\n\t\t\t\treturn [\n\t\t\t\t\t\"td\",\n\t\t\t\t\tsetCellAttrs(node, extraAttrs),\n\t\t\t\t\t0\n\t\t\t\t];\n\t\t\t}\n\t\t},\n\t\ttable_header: {\n\t\t\tcontent: options.cellContent,\n\t\t\tattrs: cellAttrs,\n\t\t\ttableRole: \"header_cell\",\n\t\t\tisolating: true,\n\t\t\tparseDOM: [{\n\t\t\t\ttag: \"th\",\n\t\t\t\tgetAttrs: (dom) => getCellAttrs(dom, extraAttrs)\n\t\t\t}],\n\t\t\ttoDOM(node) {\n\t\t\t\treturn [\n\t\t\t\t\t\"th\",\n\t\t\t\t\tsetCellAttrs(node, extraAttrs),\n\t\t\t\t\t0\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t};\n}\n/**\n* @public\n*/\nfunction tableNodeTypes(schema) {\n\tlet result = schema.cached.tableNodeTypes;\n\tif (!result) {\n\t\tresult = schema.cached.tableNodeTypes = {};\n\t\tfor (const name in schema.nodes) {\n\t\t\tconst type = schema.nodes[name], role = type.spec.tableRole;\n\t\t\tif (role) result[role] = type;\n\t\t}\n\t}\n\treturn result;\n}\n\n//#endregion\n//#region src/util.ts\n/**\n* @public\n*/\nconst tableEditingKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"selectingCells\");\n/**\n* @public\n*/\nfunction cellAround($pos) {\n\tfor (let d = $pos.depth - 1; d > 0; d--) if ($pos.node(d).type.spec.tableRole == \"row\") return $pos.node(0).resolve($pos.before(d + 1));\n\treturn null;\n}\nfunction cellWrapping($pos) {\n\tfor (let d = $pos.depth; d > 0; d--) {\n\t\tconst role = $pos.node(d).type.spec.tableRole;\n\t\tif (role === \"cell\" || role === \"header_cell\") return $pos.node(d);\n\t}\n\treturn null;\n}\n/**\n* @public\n*/\nfunction isInTable(state) {\n\tconst $head = state.selection.$head;\n\tfor (let d = $head.depth; d > 0; d--) if ($head.node(d).type.spec.tableRole == \"row\") return true;\n\treturn false;\n}\n/**\n* @internal\n*/\nfunction selectionCell(state) {\n\tconst sel = state.selection;\n\tif (\"$anchorCell\" in sel && sel.$anchorCell) return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n\telse if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") return sel.$anchor;\n\tconst $cell = cellAround(sel.$head) || cellNear(sel.$head);\n\tif ($cell) return $cell;\n\tthrow new RangeError(`No cell found around position ${sel.head}`);\n}\n/**\n* @public\n*/\nfunction cellNear($pos) {\n\tfor (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n\t\tconst role = after.type.spec.tableRole;\n\t\tif (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos);\n\t}\n\tfor (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n\t\tconst role = before.type.spec.tableRole;\n\t\tif (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos - before.nodeSize);\n\t}\n}\n/**\n* @public\n*/\nfunction pointsAtCell($pos) {\n\treturn $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\n/**\n* @public\n*/\nfunction moveCellForward($pos) {\n\treturn $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\n/**\n* @internal\n*/\nfunction inSameTable($cellA, $cellB) {\n\treturn $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\n/**\n* @public\n*/\nfunction findCell($pos) {\n\treturn TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\n/**\n* @public\n*/\nfunction colCount($pos) {\n\treturn TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\n/**\n* @public\n*/\nfunction nextCell($pos, axis, dir) {\n\tconst table = $pos.node(-1);\n\tconst map = TableMap.get(table);\n\tconst tableStart = $pos.start(-1);\n\tconst moved = map.nextCell($pos.pos - tableStart, axis, dir);\n\treturn moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\n/**\n* @public\n*/\nfunction removeColSpan(attrs, pos, n = 1) {\n\tconst result = {\n\t\t...attrs,\n\t\tcolspan: attrs.colspan - n\n\t};\n\tif (result.colwidth) {\n\t\tresult.colwidth = result.colwidth.slice();\n\t\tresult.colwidth.splice(pos, n);\n\t\tif (!result.colwidth.some((w) => w > 0)) result.colwidth = null;\n\t}\n\treturn result;\n}\n/**\n* @public\n*/\nfunction addColSpan(attrs, pos, n = 1) {\n\tconst result = {\n\t\t...attrs,\n\t\tcolspan: attrs.colspan + n\n\t};\n\tif (result.colwidth) {\n\t\tresult.colwidth = result.colwidth.slice();\n\t\tfor (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n\t}\n\treturn result;\n}\n/**\n* @public\n*/\nfunction columnIsHeader(map, table, col) {\n\tconst headerCell = tableNodeTypes(table.type.schema).header_cell;\n\tfor (let row = 0; row < map.height; row++) if (table.nodeAt(map.map[col + row * map.width]).type != headerCell) return false;\n\treturn true;\n}\n\n//#endregion\n//#region src/cellselection.ts\n/**\n* A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)\n* subclass that represents a cell selection spanning part of a table.\n* With the plugin enabled, these will be created when the user\n* selects across cells, and will be drawn by giving selected cells a\n* `selectedCell` CSS class.\n*\n* @public\n*/\nvar CellSelection = class CellSelection extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection {\n\tconstructor($anchorCell, $headCell = $anchorCell) {\n\t\tconst table = $anchorCell.node(-1);\n\t\tconst map = TableMap.get(table);\n\t\tconst tableStart = $anchorCell.start(-1);\n\t\tconst rect = map.rectBetween($anchorCell.pos - tableStart, $headCell.pos - tableStart);\n\t\tconst doc = $anchorCell.node(0);\n\t\tconst cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n\t\tcells.unshift($headCell.pos - tableStart);\n\t\tconst ranges = cells.map((pos) => {\n\t\t\tconst cell = table.nodeAt(pos);\n\t\t\tif (!cell) throw new RangeError(`No cell with offset ${pos} found`);\n\t\t\tconst from = tableStart + pos + 1;\n\t\t\treturn new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size));\n\t\t});\n\t\tsuper(ranges[0].$from, ranges[0].$to, ranges);\n\t\tthis.$anchorCell = $anchorCell;\n\t\tthis.$headCell = $headCell;\n\t}\n\tmap(doc, mapping) {\n\t\tconst $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n\t\tconst $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n\t\tif (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n\t\t\tconst tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n\t\t\tif (tableChanged && this.isRowSelection()) return CellSelection.rowSelection($anchorCell, $headCell);\n\t\t\telse if (tableChanged && this.isColSelection()) return CellSelection.colSelection($anchorCell, $headCell);\n\t\t\telse return new CellSelection($anchorCell, $headCell);\n\t\t}\n\t\treturn prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.between($anchorCell, $headCell);\n\t}\n\tcontent() {\n\t\tconst table = this.$anchorCell.node(-1);\n\t\tconst map = TableMap.get(table);\n\t\tconst tableStart = this.$anchorCell.start(-1);\n\t\tconst rect = map.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart);\n\t\tconst seen = {};\n\t\tconst rows = [];\n\t\tfor (let row = rect.top; row < rect.bottom; row++) {\n\t\t\tconst rowContent = [];\n\t\t\tfor (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n\t\t\t\tconst pos = map.map[index];\n\t\t\t\tif (seen[pos]) continue;\n\t\t\t\tseen[pos] = true;\n\t\t\t\tconst cellRect = map.findCell(pos);\n\t\t\t\tlet cell = table.nodeAt(pos);\n\t\t\t\tif (!cell) throw new RangeError(`No cell with offset ${pos} found`);\n\t\t\t\tconst extraLeft = rect.left - cellRect.left;\n\t\t\t\tconst extraRight = cellRect.right - rect.right;\n\t\t\t\tif (extraLeft > 0 || extraRight > 0) {\n\t\t\t\t\tlet attrs = cell.attrs;\n\t\t\t\t\tif (extraLeft > 0) attrs = removeColSpan(attrs, 0, extraLeft);\n\t\t\t\t\tif (extraRight > 0) attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);\n\t\t\t\t\tif (cellRect.left < rect.left) {\n\t\t\t\t\t\tcell = cell.type.createAndFill(attrs);\n\t\t\t\t\t\tif (!cell) throw new RangeError(`Could not create cell with attrs ${JSON.stringify(attrs)}`);\n\t\t\t\t\t} else cell = cell.type.create(attrs, cell.content);\n\t\t\t\t}\n\t\t\t\tif (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n\t\t\t\t\tconst attrs = {\n\t\t\t\t\t\t...cell.attrs,\n\t\t\t\t\t\trowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n\t\t\t\t\t};\n\t\t\t\t\tif (cellRect.top < rect.top) cell = cell.type.createAndFill(attrs);\n\t\t\t\t\telse cell = cell.type.create(attrs, cell.content);\n\t\t\t\t}\n\t\t\t\trowContent.push(cell);\n\t\t\t}\n\t\t\trows.push(table.child(row).copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(rowContent)));\n\t\t}\n\t\tconst fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n\t\treturn new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(fragment), 1, 1);\n\t}\n\treplace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty) {\n\t\tconst mapFrom = tr.steps.length, ranges = this.ranges;\n\t\tfor (let i = 0; i < ranges.length; i++) {\n\t\t\tconst { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n\t\t\ttr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty : content);\n\t\t}\n\t\tconst sel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);\n\t\tif (sel) tr.setSelection(sel);\n\t}\n\treplaceWith(tr, node) {\n\t\tthis.replace(tr, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node), 0, 0));\n\t}\n\tforEachCell(f) {\n\t\tconst table = this.$anchorCell.node(-1);\n\t\tconst map = TableMap.get(table);\n\t\tconst tableStart = this.$anchorCell.start(-1);\n\t\tconst cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart));\n\t\tfor (let i = 0; i < cells.length; i++) f(table.nodeAt(cells[i]), tableStart + cells[i]);\n\t}\n\tisColSelection() {\n\t\tconst anchorTop = this.$anchorCell.index(-1);\n\t\tconst headTop = this.$headCell.index(-1);\n\t\tif (Math.min(anchorTop, headTop) > 0) return false;\n\t\tconst anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n\t\tconst headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n\t\treturn Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n\t}\n\tstatic colSelection($anchorCell, $headCell = $anchorCell) {\n\t\tconst table = $anchorCell.node(-1);\n\t\tconst map = TableMap.get(table);\n\t\tconst tableStart = $anchorCell.start(-1);\n\t\tconst anchorRect = map.findCell($anchorCell.pos - tableStart);\n\t\tconst headRect = map.findCell($headCell.pos - tableStart);\n\t\tconst doc = $anchorCell.node(0);\n\t\tif (anchorRect.top <= headRect.top) {\n\t\t\tif (anchorRect.top > 0) $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n\t\t\tif (headRect.bottom < map.height) $headCell = doc.resolve(tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]);\n\t\t} else {\n\t\t\tif (headRect.top > 0) $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n\t\t\tif (anchorRect.bottom < map.height) $anchorCell = doc.resolve(tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]);\n\t\t}\n\t\treturn new CellSelection($anchorCell, $headCell);\n\t}\n\tisRowSelection() {\n\t\tconst table = this.$anchorCell.node(-1);\n\t\tconst map = TableMap.get(table);\n\t\tconst tableStart = this.$anchorCell.start(-1);\n\t\tconst anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n\t\tconst headLeft = map.colCount(this.$headCell.pos - tableStart);\n\t\tif (Math.min(anchorLeft, headLeft) > 0) return false;\n\t\tconst anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n\t\tconst headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n\t\treturn Math.max(anchorRight, headRight) == map.width;\n\t}\n\teq(other) {\n\t\treturn other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n\t}\n\tstatic rowSelection($anchorCell, $headCell = $anchorCell) {\n\t\tconst table = $anchorCell.node(-1);\n\t\tconst map = TableMap.get(table);\n\t\tconst tableStart = $anchorCell.start(-1);\n\t\tconst anchorRect = map.findCell($anchorCell.pos - tableStart);\n\t\tconst headRect = map.findCell($headCell.pos - tableStart);\n\t\tconst doc = $anchorCell.node(0);\n\t\tif (anchorRect.left <= headRect.left) {\n\t\t\tif (anchorRect.left > 0) $anchorCell = doc.resolve(tableStart + map.map[anchorRect.top * map.width]);\n\t\t\tif (headRect.right < map.width) $headCell = doc.resolve(tableStart + map.map[map.width * (headRect.top + 1) - 1]);\n\t\t} else {\n\t\t\tif (headRect.left > 0) $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n\t\t\tif (anchorRect.right < map.width) $anchorCell = doc.resolve(tableStart + map.map[map.width * (anchorRect.top + 1) - 1]);\n\t\t}\n\t\treturn new CellSelection($anchorCell, $headCell);\n\t}\n\ttoJSON() {\n\t\treturn {\n\t\t\ttype: \"cell\",\n\t\t\tanchor: this.$anchorCell.pos,\n\t\t\thead: this.$headCell.pos\n\t\t};\n\t}\n\tstatic fromJSON(doc, json) {\n\t\treturn new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n\t}\n\tstatic create(doc, anchorCell, headCell = anchorCell) {\n\t\treturn new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n\t}\n\tgetBookmark() {\n\t\treturn new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n\t}\n};\nCellSelection.prototype.visible = false;\nprosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID(\"cell\", CellSelection);\n/**\n* @public\n*/\nvar CellBookmark = class CellBookmark {\n\tconstructor(anchor, head) {\n\t\tthis.anchor = anchor;\n\t\tthis.head = head;\n\t}\n\tmap(mapping) {\n\t\treturn new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n\t}\n\tresolve(doc) {\n\t\tconst $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n\t\tif ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) return new CellSelection($anchorCell, $headCell);\n\t\telse return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($headCell, 1);\n\t}\n};\nfunction drawCellSelection(state) {\n\tif (!(state.selection instanceof CellSelection)) return null;\n\tconst cells = [];\n\tstate.selection.forEachCell((node, pos) => {\n\t\tcells.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" }));\n\t});\n\treturn prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n\tif ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;\n\tlet afterFrom = $from.pos;\n\tlet beforeTo = $to.pos;\n\tlet depth = $from.depth;\n\tfor (; depth >= 0; depth--, afterFrom++) if ($from.after(depth + 1) < $from.end(depth)) break;\n\tfor (let d = $to.depth; d >= 0; d--, beforeTo--) if ($to.before(d + 1) > $to.start(d)) break;\n\treturn afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n\tlet fromCellBoundaryNode;\n\tlet toCellBoundaryNode;\n\tfor (let i = $from.depth; i > 0; i--) {\n\t\tconst node = $from.node(i);\n\t\tif (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n\t\t\tfromCellBoundaryNode = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (let i = $to.depth; i > 0; i--) {\n\t\tconst node = $to.node(i);\n\t\tif (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n\t\t\ttoCellBoundaryNode = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n\tconst sel = (tr || state).selection;\n\tconst doc = (tr || state).doc;\n\tlet normalize;\n\tlet role;\n\tif (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && (role = sel.node.type.spec.tableRole)) {\n\t\tif (role == \"cell\" || role == \"header_cell\") normalize = CellSelection.create(doc, sel.from);\n\t\telse if (role == \"row\") {\n\t\t\tconst $cell = doc.resolve(sel.from + 1);\n\t\t\tnormalize = CellSelection.rowSelection($cell, $cell);\n\t\t} else if (!allowTableNodeSelection) {\n\t\t\tconst map = TableMap.get(sel.node);\n\t\t\tconst start = sel.from + 1;\n\t\t\tconst lastCell = start + map.map[map.width * map.height - 1];\n\t\t\tnormalize = CellSelection.create(doc, start + 1, lastCell);\n\t\t}\n\t} else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && isCellBoundarySelection(sel)) normalize = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, sel.from);\n\telse if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && isTextSelectionAcrossCells(sel)) normalize = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n\tif (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n\treturn tr;\n}\n\n//#endregion\n//#region src/fixtables.ts\n/**\n* @public\n*/\nconst fixTablesKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"fix-tables\");\n/**\n* Helper for iterating through the nodes in a document that changed\n* compared to the given previous document. Useful for avoiding\n* duplicate work on each transaction.\n*\n* @public\n*/\nfunction changedDescendants(old, cur, offset, f) {\n\tconst oldSize = old.childCount, curSize = cur.childCount;\n\touter: for (let i = 0, j = 0; i < curSize; i++) {\n\t\tconst child = cur.child(i);\n\t\tfor (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) if (old.child(scan) == child) {\n\t\t\tj = scan + 1;\n\t\t\toffset += child.nodeSize;\n\t\t\tcontinue outer;\n\t\t}\n\t\tf(child, offset);\n\t\tif (j < oldSize && old.child(j).sameMarkup(child)) changedDescendants(old.child(j), child, offset + 1, f);\n\t\telse child.nodesBetween(0, child.content.size, f, offset + 1);\n\t\toffset += child.nodeSize;\n\t}\n}\n/**\n* Inspect all tables in the given state's document and return a\n* transaction that fixes them, if necessary. If `oldState` was\n* provided, that is assumed to hold a previous, known-good state,\n* which will be used to avoid re-scanning unchanged parts of the\n* document.\n*\n* @public\n*/\nfunction fixTables(state, oldState) {\n\tlet tr;\n\tconst check = (node, pos) => {\n\t\tif (node.type.spec.tableRole == \"table\") tr = fixTable(state, node, pos, tr);\n\t};\n\tif (!oldState) state.doc.descendants(check);\n\telse if (oldState.doc != state.doc) changedDescendants(oldState.doc, state.doc, 0, check);\n\treturn tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n\tconst map = TableMap.get(table);\n\tif (!map.problems) return tr;\n\tif (!tr) tr = state.tr;\n\tconst mustAdd = [];\n\tfor (let i = 0; i < map.height; i++) mustAdd.push(0);\n\tfor (let i = 0; i < map.problems.length; i++) {\n\t\tconst prob = map.problems[i];\n\t\tif (prob.type == \"collision\") {\n\t\t\tconst cell = table.nodeAt(prob.pos);\n\t\t\tif (!cell) continue;\n\t\t\tconst attrs = cell.attrs;\n\t\t\tfor (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n\t\t\ttr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(attrs, attrs.colspan - prob.n, prob.n));\n\t\t} else if (prob.type == \"missing\") mustAdd[prob.row] += prob.n;\n\t\telse if (prob.type == \"overlong_rowspan\") {\n\t\t\tconst cell = table.nodeAt(prob.pos);\n\t\t\tif (!cell) continue;\n\t\t\ttr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n\t\t\t\t...cell.attrs,\n\t\t\t\trowspan: cell.attrs.rowspan - prob.n\n\t\t\t});\n\t\t} else if (prob.type == \"colwidth mismatch\") {\n\t\t\tconst cell = table.nodeAt(prob.pos);\n\t\t\tif (!cell) continue;\n\t\t\ttr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n\t\t\t\t...cell.attrs,\n\t\t\t\tcolwidth: prob.colwidth\n\t\t\t});\n\t\t} else if (prob.type == \"zero_sized\") {\n\t\t\tconst pos = tr.mapping.map(tablePos);\n\t\t\ttr.delete(pos, pos + table.nodeSize);\n\t\t}\n\t}\n\tlet first, last;\n\tfor (let i = 0; i < mustAdd.length; i++) if (mustAdd[i]) {\n\t\tif (first == null) first = i;\n\t\tlast = i;\n\t}\n\tfor (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n\t\tconst row = table.child(i);\n\t\tconst end = pos + row.nodeSize;\n\t\tconst add = mustAdd[i];\n\t\tif (add > 0) {\n\t\t\tlet role = \"cell\";\n\t\t\tif (row.firstChild) role = row.firstChild.type.spec.tableRole;\n\t\t\tconst nodes = [];\n\t\t\tfor (let j = 0; j < add; j++) {\n\t\t\t\tconst node = tableNodeTypes(state.schema)[role].createAndFill();\n\t\t\t\tif (node) nodes.push(node);\n\t\t\t}\n\t\t\tconst side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n\t\t\ttr.insert(tr.mapping.map(side), nodes);\n\t\t}\n\t\tpos = end;\n\t}\n\treturn tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n//#endregion\n//#region src/utils/convert.ts\n/**\n* This function will transform the table node into a matrix of rows and columns\n* respecting merged cells, for example this table:\n*\n* ```\n* ┌──────┬──────┬─────────────┐\n* │  A1  │  B1  │     C1      │\n* ├──────┼──────┴──────┬──────┤\n* │  A2  │     B2      │      │\n* ├──────┼─────────────┤  D1  │\n* │  A3  │  B3  │  C3  │      │\n* └──────┴──────┴──────┴──────┘\n* ```\n*\n* will be converted to the below:\n*\n* ```javascript\n* [\n*   [A1, B1, C1, null],\n*   [A2, B2, null, D1],\n*   [A3, B3, C3, null],\n* ]\n* ```\n* @internal\n*/\nfunction convertTableNodeToArrayOfRows(tableNode) {\n\tconst map = TableMap.get(tableNode);\n\tconst rows = [];\n\tconst rowCount = map.height;\n\tconst colCount$1 = map.width;\n\tfor (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n\t\tconst row = [];\n\t\tfor (let colIndex = 0; colIndex < colCount$1; colIndex++) {\n\t\t\tconst cellIndex = rowIndex * colCount$1 + colIndex;\n\t\t\tconst cellPos = map.map[cellIndex];\n\t\t\tif (rowIndex > 0) {\n\t\t\t\tconst topCellIndex = cellIndex - colCount$1;\n\t\t\t\tif (cellPos === map.map[topCellIndex]) {\n\t\t\t\t\trow.push(null);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (colIndex > 0) {\n\t\t\t\tconst leftCellIndex = cellIndex - 1;\n\t\t\t\tif (cellPos === map.map[leftCellIndex]) {\n\t\t\t\t\trow.push(null);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\trow.push(tableNode.nodeAt(cellPos));\n\t\t}\n\t\trows.push(row);\n\t}\n\treturn rows;\n}\n/**\n* Convert an array of rows to a table node.\n*\n* @internal\n*/\nfunction convertArrayOfRowsToTableNode(tableNode, arrayOfNodes) {\n\tconst newRows = [];\n\tconst map = TableMap.get(tableNode);\n\tconst rowCount = map.height;\n\tconst colCount$1 = map.width;\n\tfor (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n\t\tconst oldRow = tableNode.child(rowIndex);\n\t\tconst newCells = [];\n\t\tfor (let colIndex = 0; colIndex < colCount$1; colIndex++) {\n\t\t\tconst cell = arrayOfNodes[rowIndex][colIndex];\n\t\t\tif (!cell) continue;\n\t\t\tconst cellPos = map.map[rowIndex * map.width + colIndex];\n\t\t\tconst oldCell = tableNode.nodeAt(cellPos);\n\t\t\tif (!oldCell) continue;\n\t\t\tconst newCell = oldCell.type.createChecked(cell.attrs, cell.content, cell.marks);\n\t\t\tnewCells.push(newCell);\n\t\t}\n\t\tconst newRow = oldRow.type.createChecked(oldRow.attrs, newCells, oldRow.marks);\n\t\tnewRows.push(newRow);\n\t}\n\treturn tableNode.type.createChecked(tableNode.attrs, newRows, tableNode.marks);\n}\n\n//#endregion\n//#region src/utils/move-row-in-array-of-rows.ts\n/**\n* Move a row in an array of rows.\n*\n* @internal\n*/\nfunction moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, directionOverride) {\n\tconst direction = indexesOrigin[0] > indexesTarget[0] ? -1 : 1;\n\tconst rowsExtracted = rows.splice(indexesOrigin[0], indexesOrigin.length);\n\tconst positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0;\n\tlet target;\n\tif (directionOverride === -1 && direction === 1) target = indexesTarget[0] - 1;\n\telse if (directionOverride === 1 && direction === -1) target = indexesTarget[indexesTarget.length - 1] - positionOffset + 1;\n\telse target = direction === -1 ? indexesTarget[0] : indexesTarget[indexesTarget.length - 1] - positionOffset;\n\trows.splice(target, 0, ...rowsExtracted);\n\treturn rows;\n}\n\n//#endregion\n//#region src/utils/query.ts\n/**\n* Checks if the given object is a `CellSelection` instance.\n*\n* @internal\n*/\nfunction isCellSelection(value) {\n\treturn value instanceof CellSelection;\n}\n/**\n* Find the closest table node for a given position.\n*\n* @public\n*/\nfunction findTable($pos) {\n\treturn findParentNode((node) => node.type.spec.tableRole === \"table\", $pos);\n}\n/**\n* Try to find the anchor and head cell in the same table by using the given\n* anchor and head as hit points, or fallback to the selection's anchor and\n* head.\n*\n* @public\n*/\nfunction findCellRange(selection, anchorHit, headHit) {\n\tvar _ref, _ref2;\n\tif (anchorHit == null && headHit == null && isCellSelection(selection)) return [selection.$anchorCell, selection.$headCell];\n\tconst anchor = (_ref = anchorHit !== null && anchorHit !== void 0 ? anchorHit : headHit) !== null && _ref !== void 0 ? _ref : selection.anchor;\n\tconst head = (_ref2 = headHit !== null && headHit !== void 0 ? headHit : anchorHit) !== null && _ref2 !== void 0 ? _ref2 : selection.head;\n\tconst doc = selection.$head.doc;\n\tconst $anchorCell = findCellPos(doc, anchor);\n\tconst $headCell = findCellPos(doc, head);\n\tif ($anchorCell && $headCell && inSameTable($anchorCell, $headCell)) return [$anchorCell, $headCell];\n\treturn null;\n}\n/**\n* Try to find a resolved pos of a cell by using the given pos as a hit point.\n*\n* @public\n*/\nfunction findCellPos(doc, pos) {\n\tconst $pos = doc.resolve(pos);\n\treturn cellAround($pos) || cellNear($pos);\n}\n/**\n* Find the closest parent node that satisfies the predicate.\n*\n* @internal\n*/\nfunction findParentNode(predicate, $pos) {\n\tfor (let depth = $pos.depth; depth >= 0; depth -= 1) {\n\t\tconst node = $pos.node(depth);\n\t\tif (predicate(node)) return {\n\t\t\tnode,\n\t\t\tpos: depth === 0 ? 0 : $pos.before(depth),\n\t\t\tstart: $pos.start(depth),\n\t\t\tdepth\n\t\t};\n\t}\n\treturn null;\n}\n\n//#endregion\n//#region src/utils/get-cells.ts\n/**\n* Returns an array of cells in a column at the specified column index.\n*\n* @internal\n*/\nfunction getCellsInColumn(columnIndex, selection) {\n\tconst table = findTable(selection.$from);\n\tif (!table) return;\n\tconst map = TableMap.get(table.node);\n\tif (columnIndex < 0 || columnIndex > map.width - 1) return;\n\treturn map.cellsInRect({\n\t\tleft: columnIndex,\n\t\tright: columnIndex + 1,\n\t\ttop: 0,\n\t\tbottom: map.height\n\t}).map((nodePos) => {\n\t\tconst node = table.node.nodeAt(nodePos);\n\t\tconst pos = nodePos + table.start;\n\t\treturn {\n\t\t\tpos,\n\t\t\tstart: pos + 1,\n\t\t\tnode,\n\t\t\tdepth: table.depth + 2\n\t\t};\n\t});\n}\n/**\n* Returns an array of cells in a row at the specified row index.\n*\n* @internal\n*/\nfunction getCellsInRow(rowIndex, selection) {\n\tconst table = findTable(selection.$from);\n\tif (!table) return;\n\tconst map = TableMap.get(table.node);\n\tif (rowIndex < 0 || rowIndex > map.height - 1) return;\n\treturn map.cellsInRect({\n\t\tleft: 0,\n\t\tright: map.width,\n\t\ttop: rowIndex,\n\t\tbottom: rowIndex + 1\n\t}).map((nodePos) => {\n\t\tconst node = table.node.nodeAt(nodePos);\n\t\tconst pos = nodePos + table.start;\n\t\treturn {\n\t\t\tpos,\n\t\t\tstart: pos + 1,\n\t\t\tnode,\n\t\t\tdepth: table.depth + 2\n\t\t};\n\t});\n}\n\n//#endregion\n//#region src/utils/selection-range.ts\n/**\n* Returns a range of rectangular selection spanning all merged cells around a\n* column at index `columnIndex`.\n*\n* Original implementation from Atlassian (Apache License 2.0)\n*\n* https://bitbucket.org/atlassian/atlassian-frontend-mirror/src/5f91cb871e8248bc3bae5ddc30bb9fd9200fadbb/editor/editor-tables/src/utils/get-selection-range-in-column.ts#editor/editor-tables/src/utils/get-selection-range-in-column.ts\n*\n* @internal\n*/\nfunction getSelectionRangeInColumn(tr, startColIndex, endColIndex = startColIndex) {\n\tlet startIndex = startColIndex;\n\tlet endIndex = endColIndex;\n\tfor (let i = startColIndex; i >= 0; i--) {\n\t\tconst cells = getCellsInColumn(i, tr.selection);\n\t\tif (cells) cells.forEach((cell) => {\n\t\t\tconst maybeEndIndex = cell.node.attrs.colspan + i - 1;\n\t\t\tif (maybeEndIndex >= startIndex) startIndex = i;\n\t\t\tif (maybeEndIndex > endIndex) endIndex = maybeEndIndex;\n\t\t});\n\t}\n\tfor (let i = startColIndex; i <= endIndex; i++) {\n\t\tconst cells = getCellsInColumn(i, tr.selection);\n\t\tif (cells) cells.forEach((cell) => {\n\t\t\tconst maybeEndIndex = cell.node.attrs.colspan + i - 1;\n\t\t\tif (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex) endIndex = maybeEndIndex;\n\t\t});\n\t}\n\tconst indexes = [];\n\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\tconst maybeCells = getCellsInColumn(i, tr.selection);\n\t\tif (maybeCells && maybeCells.length > 0) indexes.push(i);\n\t}\n\tstartIndex = indexes[0];\n\tendIndex = indexes[indexes.length - 1];\n\tconst firstSelectedColumnCells = getCellsInColumn(startIndex, tr.selection);\n\tconst firstRowCells = getCellsInRow(0, tr.selection);\n\tif (!firstSelectedColumnCells || !firstRowCells) return;\n\tconst $anchor = tr.doc.resolve(firstSelectedColumnCells[firstSelectedColumnCells.length - 1].pos);\n\tlet headCell;\n\tfor (let i = endIndex; i >= startIndex; i--) {\n\t\tconst columnCells = getCellsInColumn(i, tr.selection);\n\t\tif (columnCells && columnCells.length > 0) {\n\t\t\tfor (let j = firstRowCells.length - 1; j >= 0; j--) if (firstRowCells[j].pos === columnCells[0].pos) {\n\t\t\t\theadCell = columnCells[0];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (headCell) break;\n\t\t}\n\t}\n\tif (!headCell) return;\n\treturn {\n\t\t$anchor,\n\t\t$head: tr.doc.resolve(headCell.pos),\n\t\tindexes\n\t};\n}\n/**\n* Returns a range of rectangular selection spanning all merged cells around a\n* row at index `rowIndex`.\n*\n* Original implementation from Atlassian (Apache License 2.0)\n*\n* https://bitbucket.org/atlassian/atlassian-frontend-mirror/src/5f91cb871e8248bc3bae5ddc30bb9fd9200fadbb/editor/editor-tables/src/utils/get-selection-range-in-row.ts#editor/editor-tables/src/utils/get-selection-range-in-row.ts\n*\n* @internal\n*/\nfunction getSelectionRangeInRow(tr, startRowIndex, endRowIndex = startRowIndex) {\n\tlet startIndex = startRowIndex;\n\tlet endIndex = endRowIndex;\n\tfor (let i = startRowIndex; i >= 0; i--) {\n\t\tconst cells = getCellsInRow(i, tr.selection);\n\t\tif (cells) cells.forEach((cell) => {\n\t\t\tconst maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n\t\t\tif (maybeEndIndex >= startIndex) startIndex = i;\n\t\t\tif (maybeEndIndex > endIndex) endIndex = maybeEndIndex;\n\t\t});\n\t}\n\tfor (let i = startRowIndex; i <= endIndex; i++) {\n\t\tconst cells = getCellsInRow(i, tr.selection);\n\t\tif (cells) cells.forEach((cell) => {\n\t\t\tconst maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n\t\t\tif (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex) endIndex = maybeEndIndex;\n\t\t});\n\t}\n\tconst indexes = [];\n\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\tconst maybeCells = getCellsInRow(i, tr.selection);\n\t\tif (maybeCells && maybeCells.length > 0) indexes.push(i);\n\t}\n\tstartIndex = indexes[0];\n\tendIndex = indexes[indexes.length - 1];\n\tconst firstSelectedRowCells = getCellsInRow(startIndex, tr.selection);\n\tconst firstColumnCells = getCellsInColumn(0, tr.selection);\n\tif (!firstSelectedRowCells || !firstColumnCells) return;\n\tconst $anchor = tr.doc.resolve(firstSelectedRowCells[firstSelectedRowCells.length - 1].pos);\n\tlet headCell;\n\tfor (let i = endIndex; i >= startIndex; i--) {\n\t\tconst rowCells = getCellsInRow(i, tr.selection);\n\t\tif (rowCells && rowCells.length > 0) {\n\t\t\tfor (let j = firstColumnCells.length - 1; j >= 0; j--) if (firstColumnCells[j].pos === rowCells[0].pos) {\n\t\t\t\theadCell = rowCells[0];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (headCell) break;\n\t\t}\n\t}\n\tif (!headCell) return;\n\treturn {\n\t\t$anchor,\n\t\t$head: tr.doc.resolve(headCell.pos),\n\t\tindexes\n\t};\n}\n\n//#endregion\n//#region src/utils/transpose.ts\n/**\n* Transposes a 2D array by flipping columns to rows.\n*\n* Transposition is a familiar algebra concept where the matrix is flipped\n* along its diagonal. For more details, see:\n* https://en.wikipedia.org/wiki/Transpose\n*\n* @example\n* ```javascript\n* const arr = [\n*   ['a1', 'a2', 'a3'],\n*   ['b1', 'b2', 'b3'],\n*   ['c1', 'c2', 'c3'],\n*   ['d1', 'd2', 'd3'],\n* ];\n*\n* const result = transpose(arr);\n* result === [\n*   ['a1', 'b1', 'c1', 'd1'],\n*   ['a2', 'b2', 'c2', 'd2'],\n*   ['a3', 'b3', 'c3', 'd3'],\n* ]\n* ```\n*/\nfunction transpose(array) {\n\treturn array[0].map((_, i) => {\n\t\treturn array.map((column) => column[i]);\n\t});\n}\n\n//#endregion\n//#region src/utils/move-column.ts\n/**\n* Move a column from index `origin` to index `target`.\n*\n* @internal\n*/\nfunction moveColumn(moveColParams) {\n\tvar _getSelectionRangeInC, _getSelectionRangeInC2;\n\tconst { tr, originIndex, targetIndex, select, pos } = moveColParams;\n\tconst table = findTable(tr.doc.resolve(pos));\n\tif (!table) return false;\n\tconst indexesOriginColumn = (_getSelectionRangeInC = getSelectionRangeInColumn(tr, originIndex)) === null || _getSelectionRangeInC === void 0 ? void 0 : _getSelectionRangeInC.indexes;\n\tconst indexesTargetColumn = (_getSelectionRangeInC2 = getSelectionRangeInColumn(tr, targetIndex)) === null || _getSelectionRangeInC2 === void 0 ? void 0 : _getSelectionRangeInC2.indexes;\n\tif (!indexesOriginColumn || !indexesTargetColumn) return false;\n\tif (indexesOriginColumn.includes(targetIndex)) return false;\n\tconst newTable = moveTableColumn$1(table.node, indexesOriginColumn, indexesTargetColumn, 0);\n\ttr.replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);\n\tif (!select) return true;\n\tconst map = TableMap.get(newTable);\n\tconst start = table.start;\n\tconst index = targetIndex;\n\tconst lastCell = map.positionAt(map.height - 1, index, newTable);\n\tconst $lastCell = tr.doc.resolve(start + lastCell);\n\tconst firstCell = map.positionAt(0, index, newTable);\n\tconst $firstCell = tr.doc.resolve(start + firstCell);\n\ttr.setSelection(CellSelection.colSelection($lastCell, $firstCell));\n\treturn true;\n}\nfunction moveTableColumn$1(table, indexesOrigin, indexesTarget, direction) {\n\tlet rows = transpose(convertTableNodeToArrayOfRows(table));\n\trows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n\trows = transpose(rows);\n\treturn convertArrayOfRowsToTableNode(table, rows);\n}\n\n//#endregion\n//#region src/utils/move-row.ts\n/**\n* Move a row from index `origin` to index `target`.\n*\n* @internal\n*/\nfunction moveRow(moveRowParams) {\n\tvar _getSelectionRangeInR, _getSelectionRangeInR2;\n\tconst { tr, originIndex, targetIndex, select, pos } = moveRowParams;\n\tconst table = findTable(tr.doc.resolve(pos));\n\tif (!table) return false;\n\tconst indexesOriginRow = (_getSelectionRangeInR = getSelectionRangeInRow(tr, originIndex)) === null || _getSelectionRangeInR === void 0 ? void 0 : _getSelectionRangeInR.indexes;\n\tconst indexesTargetRow = (_getSelectionRangeInR2 = getSelectionRangeInRow(tr, targetIndex)) === null || _getSelectionRangeInR2 === void 0 ? void 0 : _getSelectionRangeInR2.indexes;\n\tif (!indexesOriginRow || !indexesTargetRow) return false;\n\tif (indexesOriginRow.includes(targetIndex)) return false;\n\tconst newTable = moveTableRow$1(table.node, indexesOriginRow, indexesTargetRow, 0);\n\ttr.replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);\n\tif (!select) return true;\n\tconst map = TableMap.get(newTable);\n\tconst start = table.start;\n\tconst index = targetIndex;\n\tconst lastCell = map.positionAt(index, map.width - 1, newTable);\n\tconst $lastCell = tr.doc.resolve(start + lastCell);\n\tconst firstCell = map.positionAt(index, 0, newTable);\n\tconst $firstCell = tr.doc.resolve(start + firstCell);\n\ttr.setSelection(CellSelection.rowSelection($lastCell, $firstCell));\n\treturn true;\n}\nfunction moveTableRow$1(table, indexesOrigin, indexesTarget, direction) {\n\tlet rows = convertTableNodeToArrayOfRows(table);\n\trows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n\treturn convertArrayOfRowsToTableNode(table, rows);\n}\n\n//#endregion\n//#region src/commands.ts\n/**\n* Helper to get the selected rectangle in a table, if any. Adds table\n* map, table node, and table start offset to the object for\n* convenience.\n*\n* @public\n*/\nfunction selectedRect(state) {\n\tconst sel = state.selection;\n\tconst $pos = selectionCell(state);\n\tconst table = $pos.node(-1);\n\tconst tableStart = $pos.start(-1);\n\tconst map = TableMap.get(table);\n\treturn {\n\t\t...sel instanceof CellSelection ? map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart) : map.findCell($pos.pos - tableStart),\n\t\ttableStart,\n\t\tmap,\n\t\ttable\n\t};\n}\n/**\n* Add a column at the given position in a table.\n*\n* @public\n*/\nfunction addColumn(tr, { map, tableStart, table }, col) {\n\tlet refColumn = col > 0 ? -1 : 0;\n\tif (columnIsHeader(map, table, col + refColumn)) refColumn = col == 0 || col == map.width ? null : 0;\n\tfor (let row = 0; row < map.height; row++) {\n\t\tconst index = row * map.width + col;\n\t\tif (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n\t\t\tconst pos = map.map[index];\n\t\t\tconst cell = table.nodeAt(pos);\n\t\t\ttr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map.colCount(pos)));\n\t\t\trow += cell.attrs.rowspan - 1;\n\t\t} else {\n\t\t\tconst type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n\t\t\tconst pos = map.positionAt(row, col, table);\n\t\t\ttr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n\t\t}\n\t}\n\treturn tr;\n}\n/**\n* Command to add a column before the column with the selection.\n*\n* @public\n*/\nfunction addColumnBefore(state, dispatch) {\n\tif (!isInTable(state)) return false;\n\tif (dispatch) {\n\t\tconst rect = selectedRect(state);\n\t\tdispatch(addColumn(state.tr, rect, rect.left));\n\t}\n\treturn true;\n}\n/**\n* Command to add a column after the column with the selection.\n*\n* @public\n*/\nfunction addColumnAfter(state, dispatch) {\n\tif (!isInTable(state)) return false;\n\tif (dispatch) {\n\t\tconst rect = selectedRect(state);\n\t\tdispatch(addColumn(state.tr, rect, rect.right));\n\t}\n\treturn true;\n}\n/**\n* @public\n*/\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n\tconst mapStart = tr.mapping.maps.length;\n\tfor (let row = 0; row < map.height;) {\n\t\tconst index = row * map.width + col;\n\t\tconst pos = map.map[index];\n\t\tconst cell = table.nodeAt(pos);\n\t\tconst attrs = cell.attrs;\n\t\tif (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(attrs, col - map.colCount(pos)));\n\t\telse {\n\t\t\tconst start = tr.mapping.slice(mapStart).map(tableStart + pos);\n\t\t\ttr.delete(start, start + cell.nodeSize);\n\t\t}\n\t\trow += attrs.rowspan;\n\t}\n}\n/**\n* Command function that removes the selected columns from a table.\n*\n* @public\n*/\nfunction deleteColumn(state, dispatch) {\n\tif (!isInTable(state)) return false;\n\tif (dispatch) {\n\t\tconst rect = selectedRect(state);\n\t\tconst tr = state.tr;\n\t\tif (rect.left == 0 && rect.right == rect.map.width) return false;\n\t\tfor (let i = rect.right - 1;; i--) {\n\t\t\tremoveColumn(tr, rect, i);\n\t\t\tif (i == rect.left) break;\n\t\t\tconst table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n\t\t\tif (!table) throw new RangeError(\"No table found\");\n\t\t\trect.table = table;\n\t\t\trect.map = TableMap.get(table);\n\t\t}\n\t\tdispatch(tr);\n\t}\n\treturn true;\n}\n/**\n* @public\n*/\nfunction rowIsHeader(map, table, row) {\n\tvar _table$nodeAt;\n\tconst headerCell = tableNodeTypes(table.type.schema).header_cell;\n\tfor (let col = 0; col < map.width; col++) if (((_table$nodeAt = table.nodeAt(map.map[col + row * map.width])) === null || _table$nodeAt === void 0 ? void 0 : _table$nodeAt.type) != headerCell) return false;\n\treturn true;\n}\n/**\n* @public\n*/\nfunction addRow(tr, { map, tableStart, table }, row) {\n\tlet rowPos = tableStart;\n\tfor (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n\tconst cells = [];\n\tlet refRow = row > 0 ? -1 : 0;\n\tif (rowIsHeader(map, table, row + refRow)) refRow = row == 0 || row == map.height ? null : 0;\n\tfor (let col = 0, index = map.width * row; col < map.width; col++, index++) if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n\t\tconst pos = map.map[index];\n\t\tconst attrs = table.nodeAt(pos).attrs;\n\t\ttr.setNodeMarkup(tableStart + pos, null, {\n\t\t\t...attrs,\n\t\t\trowspan: attrs.rowspan + 1\n\t\t});\n\t\tcol += attrs.colspan - 1;\n\t} else {\n\t\tvar _table$nodeAt2;\n\t\tconst type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_table$nodeAt2 = table.nodeAt(map.map[index + refRow * map.width])) === null || _table$nodeAt2 === void 0 ? void 0 : _table$nodeAt2.type;\n\t\tconst node = type === null || type === void 0 ? void 0 : type.createAndFill();\n\t\tif (node) cells.push(node);\n\t}\n\ttr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n\treturn tr;\n}\n/**\n* Add a table row before the selection.\n*\n* @public\n*/\nfunction addRowBefore(state, dispatch) {\n\tif (!isInTable(state)) return false;\n\tif (dispatch) {\n\t\tconst rect = selectedRect(state);\n\t\tdispatch(addRow(state.tr, rect, rect.top));\n\t}\n\treturn true;\n}\n/**\n* Add a table row after the selection.\n*\n* @public\n*/\nfunction addRowAfter(state, dispatch) {\n\tif (!isInTable(state)) return false;\n\tif (dispatch) {\n\t\tconst rect = selectedRect(state);\n\t\tdispatch(addRow(state.tr, rect, rect.bottom));\n\t}\n\treturn true;\n}\n/**\n* @public\n*/\nfunction removeRow(tr, { map, table, tableStart }, row) {\n\tlet rowPos = 0;\n\tfor (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n\tconst nextRow = rowPos + table.child(row).nodeSize;\n\tconst mapFrom = tr.mapping.maps.length;\n\ttr.delete(rowPos + tableStart, nextRow + tableStart);\n\tconst seen = /* @__PURE__ */ new Set();\n\tfor (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n\t\tconst pos = map.map[index];\n\t\tif (seen.has(pos)) continue;\n\t\tseen.add(pos);\n\t\tif (row > 0 && pos == map.map[index - map.width]) {\n\t\t\tconst attrs = table.nodeAt(pos).attrs;\n\t\t\ttr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n\t\t\t\t...attrs,\n\t\t\t\trowspan: attrs.rowspan - 1\n\t\t\t});\n\t\t\tcol += attrs.colspan - 1;\n\t\t} else if (row < map.height && pos == map.map[index + map.width]) {\n\t\t\tconst cell = table.nodeAt(pos);\n\t\t\tconst attrs = cell.attrs;\n\t\t\tconst copy = cell.type.create({\n\t\t\t\t...attrs,\n\t\t\t\trowspan: cell.attrs.rowspan - 1\n\t\t\t}, cell.content);\n\t\t\tconst newPos = map.positionAt(row + 1, col, table);\n\t\t\ttr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n\t\t\tcol += attrs.colspan - 1;\n\t\t}\n\t}\n}\n/**\n* Remove the selected rows from a table.\n*\n* @public\n*/\nfunction deleteRow(state, dispatch) {\n\tif (!isInTable(state)) return false;\n\tif (dispatch) {\n\t\tconst rect = selectedRect(state), tr = state.tr;\n\t\tif (rect.top == 0 && rect.bottom == rect.map.height) return false;\n\t\tfor (let i = rect.bottom - 1;; i--) {\n\t\t\tremoveRow(tr, rect, i);\n\t\t\tif (i == rect.top) break;\n\t\t\tconst table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n\t\t\tif (!table) throw new RangeError(\"No table found\");\n\t\t\trect.table = table;\n\t\t\trect.map = TableMap.get(rect.table);\n\t\t}\n\t\tdispatch(tr);\n\t}\n\treturn true;\n}\nfunction isEmpty(cell) {\n\tconst c = cell.content;\n\treturn c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n\tlet indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n\tlet indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n\tfor (let i = rect.top; i < rect.bottom; i++) {\n\t\tif (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1]) return true;\n\t\tindexLeft += width;\n\t\tindexRight += width;\n\t}\n\tfor (let i = rect.left; i < rect.right; i++) {\n\t\tif (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width]) return true;\n\t\tindexTop++;\n\t\tindexBottom++;\n\t}\n\treturn false;\n}\n/**\n* Merge the selected cells into a single cell. Only available when\n* the selected cells' outline forms a rectangle.\n*\n* @public\n*/\nfunction mergeCells(state, dispatch) {\n\tconst sel = state.selection;\n\tif (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) return false;\n\tconst rect = selectedRect(state), { map } = rect;\n\tif (cellsOverlapRectangle(map, rect)) return false;\n\tif (dispatch) {\n\t\tconst tr = state.tr;\n\t\tconst seen = {};\n\t\tlet content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n\t\tlet mergedPos;\n\t\tlet mergedCell;\n\t\tfor (let row = rect.top; row < rect.bottom; row++) for (let col = rect.left; col < rect.right; col++) {\n\t\t\tconst cellPos = map.map[row * map.width + col];\n\t\t\tconst cell = rect.table.nodeAt(cellPos);\n\t\t\tif (seen[cellPos] || !cell) continue;\n\t\t\tseen[cellPos] = true;\n\t\t\tif (mergedPos == null) {\n\t\t\t\tmergedPos = cellPos;\n\t\t\t\tmergedCell = cell;\n\t\t\t} else {\n\t\t\t\tif (!isEmpty(cell)) content = content.append(cell.content);\n\t\t\t\tconst mapped = tr.mapping.map(cellPos + rect.tableStart);\n\t\t\t\ttr.delete(mapped, mapped + cell.nodeSize);\n\t\t\t}\n\t\t}\n\t\tif (mergedPos == null || mergedCell == null) return true;\n\t\ttr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n\t\t\t...addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan),\n\t\t\trowspan: rect.bottom - rect.top\n\t\t});\n\t\tif (content.size > 0) {\n\t\t\tconst end = mergedPos + 1 + mergedCell.content.size;\n\t\t\tconst start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n\t\t\ttr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n\t\t}\n\t\ttr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));\n\t\tdispatch(tr);\n\t}\n\treturn true;\n}\n/**\n* Split a selected cell, whose rowpan or colspan is greater than one,\n* into smaller cells. Use the first cell type for the new cells.\n*\n* @public\n*/\nfunction splitCell(state, dispatch) {\n\tconst nodeTypes = tableNodeTypes(state.schema);\n\treturn splitCellWithType(({ node }) => {\n\t\treturn nodeTypes[node.type.spec.tableRole];\n\t})(state, dispatch);\n}\n/**\n* Split a selected cell, whose rowpan or colspan is greater than one,\n* into smaller cells with the cell type (th, td) returned by getType function.\n*\n* @public\n*/\nfunction splitCellWithType(getCellType) {\n\treturn (state, dispatch) => {\n\t\tconst sel = state.selection;\n\t\tlet cellNode;\n\t\tlet cellPos;\n\t\tif (!(sel instanceof CellSelection)) {\n\t\t\tvar _cellAround;\n\t\t\tcellNode = cellWrapping(sel.$from);\n\t\t\tif (!cellNode) return false;\n\t\t\tcellPos = (_cellAround = cellAround(sel.$from)) === null || _cellAround === void 0 ? void 0 : _cellAround.pos;\n\t\t} else {\n\t\t\tif (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n\t\t\tcellNode = sel.$anchorCell.nodeAfter;\n\t\t\tcellPos = sel.$anchorCell.pos;\n\t\t}\n\t\tif (cellNode == null || cellPos == null) return false;\n\t\tif (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) return false;\n\t\tif (dispatch) {\n\t\t\tlet baseAttrs = cellNode.attrs;\n\t\t\tconst attrs = [];\n\t\t\tconst colwidth = baseAttrs.colwidth;\n\t\t\tif (baseAttrs.rowspan > 1) baseAttrs = {\n\t\t\t\t...baseAttrs,\n\t\t\t\trowspan: 1\n\t\t\t};\n\t\t\tif (baseAttrs.colspan > 1) baseAttrs = {\n\t\t\t\t...baseAttrs,\n\t\t\t\tcolspan: 1\n\t\t\t};\n\t\t\tconst rect = selectedRect(state), tr = state.tr;\n\t\t\tfor (let i = 0; i < rect.right - rect.left; i++) attrs.push(colwidth ? {\n\t\t\t\t...baseAttrs,\n\t\t\t\tcolwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n\t\t\t} : baseAttrs);\n\t\t\tlet lastCell;\n\t\t\tfor (let row = rect.top; row < rect.bottom; row++) {\n\t\t\t\tlet pos = rect.map.positionAt(row, rect.left, rect.table);\n\t\t\t\tif (row == rect.top) pos += cellNode.nodeSize;\n\t\t\t\tfor (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n\t\t\t\t\tif (col == rect.left && row == rect.top) continue;\n\t\t\t\t\ttr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({\n\t\t\t\t\t\tnode: cellNode,\n\t\t\t\t\t\trow,\n\t\t\t\t\t\tcol\n\t\t\t\t\t}).createAndFill(attrs[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttr.setNodeMarkup(cellPos, getCellType({\n\t\t\t\tnode: cellNode,\n\t\t\t\trow: rect.top,\n\t\t\t\tcol: rect.left\n\t\t\t}), attrs[0]);\n\t\t\tif (sel instanceof CellSelection) tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell ? tr.doc.resolve(lastCell) : void 0));\n\t\t\tdispatch(tr);\n\t\t}\n\t\treturn true;\n\t};\n}\n/**\n* Returns a command that sets the given attribute to the given value,\n* and is only available when the currently selected cell doesn't\n* already have that attribute set to that value.\n*\n* @public\n*/\nfunction setCellAttr(name, value) {\n\treturn function(state, dispatch) {\n\t\tif (!isInTable(state)) return false;\n\t\tconst $cell = selectionCell(state);\n\t\tif ($cell.nodeAfter.attrs[name] === value) return false;\n\t\tif (dispatch) {\n\t\t\tconst tr = state.tr;\n\t\t\tif (state.selection instanceof CellSelection) state.selection.forEachCell((node, pos) => {\n\t\t\t\tif (node.attrs[name] !== value) tr.setNodeMarkup(pos, null, {\n\t\t\t\t\t...node.attrs,\n\t\t\t\t\t[name]: value\n\t\t\t\t});\n\t\t\t});\n\t\t\telse tr.setNodeMarkup($cell.pos, null, {\n\t\t\t\t...$cell.nodeAfter.attrs,\n\t\t\t\t[name]: value\n\t\t\t});\n\t\t\tdispatch(tr);\n\t\t}\n\t\treturn true;\n\t};\n}\nfunction deprecated_toggleHeader(type) {\n\treturn function(state, dispatch) {\n\t\tif (!isInTable(state)) return false;\n\t\tif (dispatch) {\n\t\t\tconst types = tableNodeTypes(state.schema);\n\t\t\tconst rect = selectedRect(state), tr = state.tr;\n\t\t\tconst cells = rect.map.cellsInRect(type == \"column\" ? {\n\t\t\t\tleft: rect.left,\n\t\t\t\ttop: 0,\n\t\t\t\tright: rect.right,\n\t\t\t\tbottom: rect.map.height\n\t\t\t} : type == \"row\" ? {\n\t\t\t\tleft: 0,\n\t\t\t\ttop: rect.top,\n\t\t\t\tright: rect.map.width,\n\t\t\t\tbottom: rect.bottom\n\t\t\t} : rect);\n\t\t\tconst nodes = cells.map((pos) => rect.table.nodeAt(pos));\n\t\t\tfor (let i = 0; i < cells.length; i++) if (nodes[i].type == types.header_cell) tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs);\n\t\t\tif (tr.steps.length === 0) for (let i = 0; i < cells.length; i++) tr.setNodeMarkup(rect.tableStart + cells[i], types.header_cell, nodes[i].attrs);\n\t\t\tdispatch(tr);\n\t\t}\n\t\treturn true;\n\t};\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n\tconst cellPositions = rect.map.cellsInRect({\n\t\tleft: 0,\n\t\ttop: 0,\n\t\tright: type == \"row\" ? rect.map.width : 1,\n\t\tbottom: type == \"column\" ? rect.map.height : 1\n\t});\n\tfor (let i = 0; i < cellPositions.length; i++) {\n\t\tconst cell = rect.table.nodeAt(cellPositions[i]);\n\t\tif (cell && cell.type !== types.header_cell) return false;\n\t}\n\treturn true;\n}\n/**\n* Toggles between row/column header and normal cells (Only applies to first row/column).\n* For deprecated behavior pass `useDeprecatedLogic` in options with true.\n*\n* @public\n*/\nfunction toggleHeader(type, options) {\n\toptions = options || { useDeprecatedLogic: false };\n\tif (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n\treturn function(state, dispatch) {\n\t\tif (!isInTable(state)) return false;\n\t\tif (dispatch) {\n\t\t\tconst types = tableNodeTypes(state.schema);\n\t\t\tconst rect = selectedRect(state), tr = state.tr;\n\t\t\tconst isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n\t\t\tconst isHeaderColumnEnabled = isHeaderEnabledByType(\"column\", rect, types);\n\t\t\tconst selectionStartsAt = (type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false) ? 1 : 0;\n\t\t\tconst cellsRect = type == \"column\" ? {\n\t\t\t\tleft: 0,\n\t\t\t\ttop: selectionStartsAt,\n\t\t\t\tright: 1,\n\t\t\t\tbottom: rect.map.height\n\t\t\t} : type == \"row\" ? {\n\t\t\t\tleft: selectionStartsAt,\n\t\t\t\ttop: 0,\n\t\t\t\tright: rect.map.width,\n\t\t\t\tbottom: 1\n\t\t\t} : rect;\n\t\t\tconst newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n\t\t\trect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n\t\t\t\tconst cellPos = relativeCellPos + rect.tableStart;\n\t\t\t\tconst cell = tr.doc.nodeAt(cellPos);\n\t\t\t\tif (cell) tr.setNodeMarkup(cellPos, newType, cell.attrs);\n\t\t\t});\n\t\t\tdispatch(tr);\n\t\t}\n\t\treturn true;\n\t};\n}\n/**\n* Toggles whether the selected row contains header cells.\n*\n* @public\n*/\nconst toggleHeaderRow = toggleHeader(\"row\", { useDeprecatedLogic: true });\n/**\n* Toggles whether the selected column contains header cells.\n*\n* @public\n*/\nconst toggleHeaderColumn = toggleHeader(\"column\", { useDeprecatedLogic: true });\n/**\n* Toggles whether the selected cells are header cells.\n*\n* @public\n*/\nconst toggleHeaderCell = toggleHeader(\"cell\", { useDeprecatedLogic: true });\nfunction findNextCell($cell, dir) {\n\tif (dir < 0) {\n\t\tconst before = $cell.nodeBefore;\n\t\tif (before) return $cell.pos - before.nodeSize;\n\t\tfor (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n\t\t\tconst rowNode = $cell.node(-1).child(row);\n\t\t\tconst lastChild = rowNode.lastChild;\n\t\t\tif (lastChild) return rowEnd - 1 - lastChild.nodeSize;\n\t\t\trowEnd -= rowNode.nodeSize;\n\t\t}\n\t} else {\n\t\tif ($cell.index() < $cell.parent.childCount - 1) return $cell.pos + $cell.nodeAfter.nodeSize;\n\t\tconst table = $cell.node(-1);\n\t\tfor (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n\t\t\tconst rowNode = table.child(row);\n\t\t\tif (rowNode.childCount) return rowStart + 1;\n\t\t\trowStart += rowNode.nodeSize;\n\t\t}\n\t}\n\treturn null;\n}\n/**\n* Returns a command for selecting the next (direction=1) or previous\n* (direction=-1) cell in a table.\n*\n* @public\n*/\nfunction goToNextCell(direction) {\n\treturn function(state, dispatch) {\n\t\tif (!isInTable(state)) return false;\n\t\tconst cell = findNextCell(selectionCell(state), direction);\n\t\tif (cell == null) return false;\n\t\tif (dispatch) {\n\t\t\tconst $cell = state.doc.resolve(cell);\n\t\t\tdispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());\n\t\t}\n\t\treturn true;\n\t};\n}\n/**\n* Deletes the table around the selection, if any.\n*\n* @public\n*/\nfunction deleteTable(state, dispatch) {\n\tconst $pos = state.selection.$anchor;\n\tfor (let d = $pos.depth; d > 0; d--) if ($pos.node(d).type.spec.tableRole == \"table\") {\n\t\tif (dispatch) dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());\n\t\treturn true;\n\t}\n\treturn false;\n}\n/**\n* Deletes the content of the selected cells, if they are not empty.\n*\n* @public\n*/\nfunction deleteCellSelection(state, dispatch) {\n\tconst sel = state.selection;\n\tif (!(sel instanceof CellSelection)) return false;\n\tif (dispatch) {\n\t\tconst tr = state.tr;\n\t\tconst baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n\t\tsel.forEachCell((cell, pos) => {\n\t\t\tif (!cell.content.eq(baseContent)) tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(baseContent, 0, 0));\n\t\t});\n\t\tif (tr.docChanged) dispatch(tr);\n\t}\n\treturn true;\n}\n/**\n* Move a table row from index `from` to index `to`.\n*\n* @public\n*/\nfunction moveTableRow(options) {\n\treturn (state, dispatch) => {\n\t\tconst { from: originIndex, to: targetIndex, select = true, pos = state.selection.from } = options;\n\t\tconst tr = state.tr;\n\t\tif (moveRow({\n\t\t\ttr,\n\t\t\toriginIndex,\n\t\t\ttargetIndex,\n\t\t\tselect,\n\t\t\tpos\n\t\t})) {\n\t\t\tdispatch === null || dispatch === void 0 || dispatch(tr);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n}\n/**\n* Move a table column from index `from` to index `to`.\n*\n* @public\n*/\nfunction moveTableColumn(options) {\n\treturn (state, dispatch) => {\n\t\tconst { from: originIndex, to: targetIndex, select = true, pos = state.selection.from } = options;\n\t\tconst tr = state.tr;\n\t\tif (moveColumn({\n\t\t\ttr,\n\t\t\toriginIndex,\n\t\t\ttargetIndex,\n\t\t\tselect,\n\t\t\tpos\n\t\t})) {\n\t\t\tdispatch === null || dispatch === void 0 || dispatch(tr);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n}\n\n//#endregion\n//#region src/copypaste.ts\n/**\n* Get a rectangular area of cells from a slice, or null if the outer\n* nodes of the slice aren't table cells or rows.\n*\n* @internal\n*/\nfunction pastedCells(slice) {\n\tif (slice.size === 0) return null;\n\tlet { content, openStart, openEnd } = slice;\n\twhile (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n\t\topenStart--;\n\t\topenEnd--;\n\t\tcontent = content.child(0).content;\n\t}\n\tconst first = content.child(0);\n\tconst role = first.type.spec.tableRole;\n\tconst schema = first.type.schema, rows = [];\n\tif (role == \"row\") for (let i = 0; i < content.childCount; i++) {\n\t\tlet cells = content.child(i).content;\n\t\tconst left = i ? 0 : Math.max(0, openStart - 1);\n\t\tconst right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n\t\tif (left || right) cells = fitSlice(tableNodeTypes(schema).row, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(cells, left, right)).content;\n\t\trows.push(cells);\n\t}\n\telse if (role == \"cell\" || role == \"header_cell\") rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, openStart, openEnd)).content : content);\n\telse return null;\n\treturn ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n\tconst widths = [];\n\tfor (let i = 0; i < rows.length; i++) {\n\t\tconst row = rows[i];\n\t\tfor (let j = row.childCount - 1; j >= 0; j--) {\n\t\t\tconst { rowspan, colspan } = row.child(j).attrs;\n\t\t\tfor (let r = i; r < i + rowspan; r++) widths[r] = (widths[r] || 0) + colspan;\n\t\t}\n\t}\n\tlet width = 0;\n\tfor (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n\tfor (let r = 0; r < widths.length; r++) {\n\t\tif (r >= rows.length) rows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty);\n\t\tif (widths[r] < width) {\n\t\t\tconst empty = tableNodeTypes(schema).cell.createAndFill();\n\t\t\tconst cells = [];\n\t\t\tfor (let i = widths[r]; i < width; i++) cells.push(empty);\n\t\t\trows[r] = rows[r].append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n\t\t}\n\t}\n\treturn {\n\t\theight: rows.length,\n\t\twidth,\n\t\trows\n\t};\n}\nfunction fitSlice(nodeType, slice) {\n\tconst node = nodeType.createAndFill();\n\treturn new prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.Transform(node).replace(0, node.content.size, slice).doc;\n}\n/**\n* Clip or extend (repeat) the given set of cells to cover the given\n* width and height. Will clip rowspan/colspan cells at the edges when\n* they stick out.\n*\n* @internal\n*/\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n\tif (width != newWidth) {\n\t\tconst added = [];\n\t\tconst newRows = [];\n\t\tfor (let row = 0; row < rows.length; row++) {\n\t\t\tconst frag = rows[row], cells = [];\n\t\t\tfor (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n\t\t\t\tlet cell = frag.child(i % frag.childCount);\n\t\t\t\tif (col + cell.attrs.colspan > newWidth) cell = cell.type.createChecked(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);\n\t\t\t\tcells.push(cell);\n\t\t\t\tcol += cell.attrs.colspan;\n\t\t\t\tfor (let j = 1; j < cell.attrs.rowspan; j++) added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n\t\t\t}\n\t\t\tnewRows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n\t\t}\n\t\trows = newRows;\n\t\twidth = newWidth;\n\t}\n\tif (height != newHeight) {\n\t\tconst newRows = [];\n\t\tfor (let row = 0, i = 0; row < newHeight; row++, i++) {\n\t\t\tconst cells = [], source = rows[i % height];\n\t\t\tfor (let j = 0; j < source.childCount; j++) {\n\t\t\t\tlet cell = source.child(j);\n\t\t\t\tif (row + cell.attrs.rowspan > newHeight) cell = cell.type.create({\n\t\t\t\t\t...cell.attrs,\n\t\t\t\t\trowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n\t\t\t\t}, cell.content);\n\t\t\t\tcells.push(cell);\n\t\t\t}\n\t\t\tnewRows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n\t\t}\n\t\trows = newRows;\n\t\theight = newHeight;\n\t}\n\treturn {\n\t\twidth,\n\t\theight,\n\t\trows\n\t};\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n\tconst schema = tr.doc.type.schema;\n\tconst types = tableNodeTypes(schema);\n\tlet empty;\n\tlet emptyHead;\n\tif (width > map.width) for (let row = 0, rowEnd = 0; row < map.height; row++) {\n\t\tconst rowNode = table.child(row);\n\t\trowEnd += rowNode.nodeSize;\n\t\tconst cells = [];\n\t\tlet add;\n\t\tif (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) add = empty || (empty = types.cell.createAndFill());\n\t\telse add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n\t\tfor (let i = map.width; i < width; i++) cells.push(add);\n\t\ttr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n\t}\n\tif (height > map.height) {\n\t\tconst cells = [];\n\t\tfor (let i = 0, start$1 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n\t\t\tconst header = i >= map.width ? false : table.nodeAt(map.map[start$1 + i]).type == types.header_cell;\n\t\t\tcells.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill()));\n\t\t}\n\t\tconst emptyRow = types.row.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells)), rows = [];\n\t\tfor (let i = map.height; i < height; i++) rows.push(emptyRow);\n\t\ttr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n\t}\n\treturn !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n\tif (top == 0 || top == map.height) return false;\n\tlet found = false;\n\tfor (let col = left; col < right; col++) {\n\t\tconst index = top * map.width + col, pos = map.map[index];\n\t\tif (map.map[index - map.width] == pos) {\n\t\t\tfound = true;\n\t\t\tconst cell = table.nodeAt(pos);\n\t\t\tconst { top: cellTop, left: cellLeft } = map.findCell(pos);\n\t\t\ttr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n\t\t\t\t...cell.attrs,\n\t\t\t\trowspan: top - cellTop\n\t\t\t});\n\t\t\ttr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)), cell.type.createAndFill({\n\t\t\t\t...cell.attrs,\n\t\t\t\trowspan: cellTop + cell.attrs.rowspan - top\n\t\t\t}));\n\t\t\tcol += cell.attrs.colspan - 1;\n\t\t}\n\t}\n\treturn found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n\tif (left == 0 || left == map.width) return false;\n\tlet found = false;\n\tfor (let row = top; row < bottom; row++) {\n\t\tconst index = row * map.width + left, pos = map.map[index];\n\t\tif (map.map[index - 1] == pos) {\n\t\t\tfound = true;\n\t\t\tconst cell = table.nodeAt(pos);\n\t\t\tconst cellLeft = map.colCount(pos);\n\t\t\tconst updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n\t\t\ttr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));\n\t\t\ttr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));\n\t\t\trow += cell.attrs.rowspan - 1;\n\t\t}\n\t}\n\treturn found;\n}\n/**\n* Insert the given set of cells (as returned by `pastedCells`) into a\n* table, at the position pointed at by rect.\n*\n* @internal\n*/\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n\tlet table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n\tif (!table) throw new Error(\"No table found\");\n\tlet map = TableMap.get(table);\n\tconst { top, left } = rect;\n\tconst right = left + cells.width, bottom = top + cells.height;\n\tconst tr = state.tr;\n\tlet mapFrom = 0;\n\tfunction recomp() {\n\t\ttable = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n\t\tif (!table) throw new Error(\"No table found\");\n\t\tmap = TableMap.get(table);\n\t\tmapFrom = tr.mapping.maps.length;\n\t}\n\tif (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n\tif (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) recomp();\n\tif (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) recomp();\n\tif (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) recomp();\n\tif (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) recomp();\n\tfor (let row = top; row < bottom; row++) {\n\t\tconst from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n\t\ttr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(cells.rows[row - top], 0, 0));\n\t}\n\trecomp();\n\ttr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)), tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))));\n\tdispatch(tr);\n}\n\n//#endregion\n//#region src/input.ts\nconst handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_4__.keydownHandler)({\n\tArrowLeft: arrow(\"horiz\", -1),\n\tArrowRight: arrow(\"horiz\", 1),\n\tArrowUp: arrow(\"vert\", -1),\n\tArrowDown: arrow(\"vert\", 1),\n\t\"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n\t\"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n\t\"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n\t\"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n\tBackspace: deleteCellSelection,\n\t\"Mod-Backspace\": deleteCellSelection,\n\tDelete: deleteCellSelection,\n\t\"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n\tif (selection.eq(state.selection)) return false;\n\tif (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n\treturn true;\n}\n/**\n* @internal\n*/\nfunction arrow(axis, dir) {\n\treturn (state, dispatch, view) => {\n\t\tif (!view) return false;\n\t\tconst sel = state.selection;\n\t\tif (sel instanceof CellSelection) return maybeSetSelection(state, dispatch, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(sel.$headCell, dir));\n\t\tif (axis != \"horiz\" && !sel.empty) return false;\n\t\tconst end = atEndOfCell(view, axis, dir);\n\t\tif (end == null) return false;\n\t\tif (axis == \"horiz\") return maybeSetSelection(state, dispatch, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve(sel.head + dir), dir));\n\t\telse {\n\t\t\tconst $cell = state.doc.resolve(end);\n\t\t\tconst $next = nextCell($cell, axis, dir);\n\t\t\tlet newSel;\n\t\t\tif ($next) newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($next, 1);\n\t\t\telse if (dir < 0) newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve($cell.before(-1)), -1);\n\t\t\telse newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve($cell.after(-1)), 1);\n\t\t\treturn maybeSetSelection(state, dispatch, newSel);\n\t\t}\n\t};\n}\nfunction shiftArrow(axis, dir) {\n\treturn (state, dispatch, view) => {\n\t\tif (!view) return false;\n\t\tconst sel = state.selection;\n\t\tlet cellSel;\n\t\tif (sel instanceof CellSelection) cellSel = sel;\n\t\telse {\n\t\t\tconst end = atEndOfCell(view, axis, dir);\n\t\t\tif (end == null) return false;\n\t\t\tcellSel = new CellSelection(state.doc.resolve(end));\n\t\t}\n\t\tconst $head = nextCell(cellSel.$headCell, axis, dir);\n\t\tif (!$head) return false;\n\t\treturn maybeSetSelection(state, dispatch, new CellSelection(cellSel.$anchorCell, $head));\n\t};\n}\nfunction handleTripleClick(view, pos) {\n\tconst doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n\tif (!$cell) return false;\n\tview.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n\treturn true;\n}\n/**\n* @public\n*/\nfunction handlePaste(view, _, slice) {\n\tif (!isInTable(view.state)) return false;\n\tlet cells = pastedCells(slice);\n\tconst sel = view.state.selection;\n\tif (sel instanceof CellSelection) {\n\t\tif (!cells) cells = {\n\t\t\twidth: 1,\n\t\t\theight: 1,\n\t\t\trows: [prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]\n\t\t};\n\t\tconst table = sel.$anchorCell.node(-1);\n\t\tconst start = sel.$anchorCell.start(-1);\n\t\tconst rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);\n\t\tcells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n\t\tinsertCells(view.state, view.dispatch, start, rect, cells);\n\t\treturn true;\n\t} else if (cells) {\n\t\tconst $cell = selectionCell(view.state);\n\t\tconst start = $cell.start(-1);\n\t\tinsertCells(view.state, view.dispatch, start, TableMap.get($cell.node(-1)).findCell($cell.pos - start), cells);\n\t\treturn true;\n\t} else return false;\n}\nfunction handleMouseDown$1(view, startEvent) {\n\tvar _cellUnderMouse;\n\tif (startEvent.button != 0) return;\n\tif (startEvent.ctrlKey || startEvent.metaKey) return;\n\tconst startDOMCell = domInCell(view, startEvent.target);\n\tlet $anchor;\n\tif (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n\t\tsetCellSelection(view.state.selection.$anchorCell, startEvent);\n\t\tstartEvent.preventDefault();\n\t} else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_cellUnderMouse = cellUnderMouse(view, startEvent)) === null || _cellUnderMouse === void 0 ? void 0 : _cellUnderMouse.pos) != $anchor.pos) {\n\t\tsetCellSelection($anchor, startEvent);\n\t\tstartEvent.preventDefault();\n\t} else if (!startDOMCell) return;\n\tfunction setCellSelection($anchor$1, event) {\n\t\tlet $head = cellUnderMouse(view, event);\n\t\tconst starting = tableEditingKey.getState(view.state) == null;\n\t\tif (!$head || !inSameTable($anchor$1, $head)) if (starting) $head = $anchor$1;\n\t\telse return;\n\t\tconst selection = new CellSelection($anchor$1, $head);\n\t\tif (starting || !view.state.selection.eq(selection)) {\n\t\t\tconst tr = view.state.tr.setSelection(selection);\n\t\t\tif (starting) tr.setMeta(tableEditingKey, $anchor$1.pos);\n\t\t\tview.dispatch(tr);\n\t\t}\n\t}\n\tfunction stop() {\n\t\tview.root.removeEventListener(\"mouseup\", stop);\n\t\tview.root.removeEventListener(\"dragstart\", stop);\n\t\tview.root.removeEventListener(\"mousemove\", move);\n\t\tif (tableEditingKey.getState(view.state) != null) view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n\t}\n\tfunction move(_event) {\n\t\tconst event = _event;\n\t\tconst anchor = tableEditingKey.getState(view.state);\n\t\tlet $anchor$1;\n\t\tif (anchor != null) $anchor$1 = view.state.doc.resolve(anchor);\n\t\telse if (domInCell(view, event.target) != startDOMCell) {\n\t\t\t$anchor$1 = cellUnderMouse(view, startEvent);\n\t\t\tif (!$anchor$1) return stop();\n\t\t}\n\t\tif ($anchor$1) setCellSelection($anchor$1, event);\n\t}\n\tview.root.addEventListener(\"mouseup\", stop);\n\tview.root.addEventListener(\"dragstart\", stop);\n\tview.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n\tif (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection)) return null;\n\tconst { $head } = view.state.selection;\n\tfor (let d = $head.depth - 1; d >= 0; d--) {\n\t\tconst parent = $head.node(d);\n\t\tif ((dir < 0 ? $head.index(d) : $head.indexAfter(d)) != (dir < 0 ? 0 : parent.childCount)) return null;\n\t\tif (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n\t\t\tconst cellPos = $head.before(d);\n\t\t\tconst dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n\t\t\treturn view.endOfTextblock(dirStr) ? cellPos : null;\n\t\t}\n\t}\n\treturn null;\n}\nfunction domInCell(view, dom) {\n\tfor (; dom && dom != view.dom; dom = dom.parentNode) if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") return dom;\n\treturn null;\n}\nfunction cellUnderMouse(view, event) {\n\tconst mousePos = view.posAtCoords({\n\t\tleft: event.clientX,\n\t\ttop: event.clientY\n\t});\n\tif (!mousePos) return null;\n\tlet { inside, pos } = mousePos;\n\treturn inside >= 0 && cellAround(view.state.doc.resolve(inside)) || cellAround(view.state.doc.resolve(pos));\n}\n\n//#endregion\n//#region src/tableview.ts\n/**\n* @public\n*/\nvar TableView = class {\n\tconstructor(node, defaultCellMinWidth) {\n\t\tthis.node = node;\n\t\tthis.defaultCellMinWidth = defaultCellMinWidth;\n\t\tthis.dom = document.createElement(\"div\");\n\t\tthis.dom.className = \"tableWrapper\";\n\t\tthis.table = this.dom.appendChild(document.createElement(\"table\"));\n\t\tthis.table.style.setProperty(\"--default-cell-min-width\", `${defaultCellMinWidth}px`);\n\t\tthis.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n\t\tupdateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);\n\t\tthis.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n\t}\n\tupdate(node) {\n\t\tif (node.type != this.node.type) return false;\n\t\tthis.node = node;\n\t\tupdateColumnsOnResize(node, this.colgroup, this.table, this.defaultCellMinWidth);\n\t\treturn true;\n\t}\n\tignoreMutation(record) {\n\t\treturn record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n\t}\n};\n/**\n* @public\n*/\nfunction updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {\n\tlet totalWidth = 0;\n\tlet fixedWidth = true;\n\tlet nextDOM = colgroup.firstChild;\n\tconst row = node.firstChild;\n\tif (!row) return;\n\tfor (let i = 0, col = 0; i < row.childCount; i++) {\n\t\tconst { colspan, colwidth } = row.child(i).attrs;\n\t\tfor (let j = 0; j < colspan; j++, col++) {\n\t\t\tconst hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n\t\t\tconst cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n\t\t\ttotalWidth += hasWidth || defaultCellMinWidth;\n\t\t\tif (!hasWidth) fixedWidth = false;\n\t\t\tif (!nextDOM) {\n\t\t\t\tconst col$1 = document.createElement(\"col\");\n\t\t\t\tcol$1.style.width = cssWidth;\n\t\t\t\tcolgroup.appendChild(col$1);\n\t\t\t} else {\n\t\t\t\tif (nextDOM.style.width != cssWidth) nextDOM.style.width = cssWidth;\n\t\t\t\tnextDOM = nextDOM.nextSibling;\n\t\t\t}\n\t\t}\n\t}\n\twhile (nextDOM) {\n\t\tvar _nextDOM$parentNode;\n\t\tconst after = nextDOM.nextSibling;\n\t\t(_nextDOM$parentNode = nextDOM.parentNode) === null || _nextDOM$parentNode === void 0 || _nextDOM$parentNode.removeChild(nextDOM);\n\t\tnextDOM = after;\n\t}\n\tif (fixedWidth) {\n\t\ttable.style.width = totalWidth + \"px\";\n\t\ttable.style.minWidth = \"\";\n\t} else {\n\t\ttable.style.width = \"\";\n\t\ttable.style.minWidth = totalWidth + \"px\";\n\t}\n}\n\n//#endregion\n//#region src/columnresizing.ts\n/**\n* @public\n*/\nconst columnResizingPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tableColumnResizing\");\n/**\n* @public\n*/\nfunction columnResizing({ handleWidth = 5, cellMinWidth = 25, defaultCellMinWidth = 100, View = TableView, lastColumnResizable = true } = {}) {\n\tconst plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n\t\tkey: columnResizingPluginKey,\n\t\tstate: {\n\t\t\tinit(_, state) {\n\t\t\t\tvar _plugin$spec;\n\t\t\t\tconst nodeViews = (_plugin$spec = plugin.spec) === null || _plugin$spec === void 0 || (_plugin$spec = _plugin$spec.props) === null || _plugin$spec === void 0 ? void 0 : _plugin$spec.nodeViews;\n\t\t\t\tconst tableName = tableNodeTypes(state.schema).table.name;\n\t\t\t\tif (View && nodeViews) nodeViews[tableName] = (node, view) => {\n\t\t\t\t\treturn new View(node, defaultCellMinWidth, view);\n\t\t\t\t};\n\t\t\t\treturn new ResizeState(-1, false);\n\t\t\t},\n\t\t\tapply(tr, prev) {\n\t\t\t\treturn prev.apply(tr);\n\t\t\t}\n\t\t},\n\t\tprops: {\n\t\t\tattributes: (state) => {\n\t\t\t\tconst pluginState = columnResizingPluginKey.getState(state);\n\t\t\t\treturn pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n\t\t\t},\n\t\t\thandleDOMEvents: {\n\t\t\t\tmousemove: (view, event) => {\n\t\t\t\t\thandleMouseMove(view, event, handleWidth, lastColumnResizable);\n\t\t\t\t},\n\t\t\t\tmouseleave: (view) => {\n\t\t\t\t\thandleMouseLeave(view);\n\t\t\t\t},\n\t\t\t\tmousedown: (view, event) => {\n\t\t\t\t\thandleMouseDown(view, event, cellMinWidth, defaultCellMinWidth);\n\t\t\t\t}\n\t\t\t},\n\t\t\tdecorations: (state) => {\n\t\t\t\tconst pluginState = columnResizingPluginKey.getState(state);\n\t\t\t\tif (pluginState && pluginState.activeHandle > -1) return handleDecorations(state, pluginState.activeHandle);\n\t\t\t},\n\t\t\tnodeViews: {}\n\t\t}\n\t});\n\treturn plugin;\n}\n/**\n* @public\n*/\nvar ResizeState = class ResizeState {\n\tconstructor(activeHandle, dragging) {\n\t\tthis.activeHandle = activeHandle;\n\t\tthis.dragging = dragging;\n\t}\n\tapply(tr) {\n\t\tconst state = this;\n\t\tconst action = tr.getMeta(columnResizingPluginKey);\n\t\tif (action && action.setHandle != null) return new ResizeState(action.setHandle, false);\n\t\tif (action && action.setDragging !== void 0) return new ResizeState(state.activeHandle, action.setDragging);\n\t\tif (state.activeHandle > -1 && tr.docChanged) {\n\t\t\tlet handle = tr.mapping.map(state.activeHandle, -1);\n\t\t\tif (!pointsAtCell(tr.doc.resolve(handle))) handle = -1;\n\t\t\treturn new ResizeState(handle, state.dragging);\n\t\t}\n\t\treturn state;\n\t}\n};\nfunction handleMouseMove(view, event, handleWidth, lastColumnResizable) {\n\tif (!view.editable) return;\n\tconst pluginState = columnResizingPluginKey.getState(view.state);\n\tif (!pluginState) return;\n\tif (!pluginState.dragging) {\n\t\tconst target = domCellAround(event.target);\n\t\tlet cell = -1;\n\t\tif (target) {\n\t\t\tconst { left, right } = target.getBoundingClientRect();\n\t\t\tif (event.clientX - left <= handleWidth) cell = edgeCell(view, event, \"left\", handleWidth);\n\t\t\telse if (right - event.clientX <= handleWidth) cell = edgeCell(view, event, \"right\", handleWidth);\n\t\t}\n\t\tif (cell != pluginState.activeHandle) {\n\t\t\tif (!lastColumnResizable && cell !== -1) {\n\t\t\t\tconst $cell = view.state.doc.resolve(cell);\n\t\t\t\tconst table = $cell.node(-1);\n\t\t\t\tconst map = TableMap.get(table);\n\t\t\t\tconst tableStart = $cell.start(-1);\n\t\t\t\tif (map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1 == map.width - 1) return;\n\t\t\t}\n\t\t\tupdateHandle(view, cell);\n\t\t}\n\t}\n}\nfunction handleMouseLeave(view) {\n\tif (!view.editable) return;\n\tconst pluginState = columnResizingPluginKey.getState(view.state);\n\tif (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging) updateHandle(view, -1);\n}\nfunction handleMouseDown(view, event, cellMinWidth, defaultCellMinWidth) {\n\tvar _view$dom$ownerDocume;\n\tif (!view.editable) return false;\n\tconst win = (_view$dom$ownerDocume = view.dom.ownerDocument.defaultView) !== null && _view$dom$ownerDocume !== void 0 ? _view$dom$ownerDocume : window;\n\tconst pluginState = columnResizingPluginKey.getState(view.state);\n\tif (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging) return false;\n\tconst cell = view.state.doc.nodeAt(pluginState.activeHandle);\n\tconst width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n\tview.dispatch(view.state.tr.setMeta(columnResizingPluginKey, { setDragging: {\n\t\tstartX: event.clientX,\n\t\tstartWidth: width\n\t} }));\n\tfunction finish(event$1) {\n\t\twin.removeEventListener(\"mouseup\", finish);\n\t\twin.removeEventListener(\"mousemove\", move);\n\t\tconst pluginState$1 = columnResizingPluginKey.getState(view.state);\n\t\tif (pluginState$1 === null || pluginState$1 === void 0 ? void 0 : pluginState$1.dragging) {\n\t\t\tupdateColumnWidth(view, pluginState$1.activeHandle, draggedWidth(pluginState$1.dragging, event$1, cellMinWidth));\n\t\t\tview.dispatch(view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null }));\n\t\t}\n\t}\n\tfunction move(event$1) {\n\t\tif (!event$1.which) return finish(event$1);\n\t\tconst pluginState$1 = columnResizingPluginKey.getState(view.state);\n\t\tif (!pluginState$1) return;\n\t\tif (pluginState$1.dragging) {\n\t\t\tconst dragged = draggedWidth(pluginState$1.dragging, event$1, cellMinWidth);\n\t\t\tdisplayColumnWidth(view, pluginState$1.activeHandle, dragged, defaultCellMinWidth);\n\t\t}\n\t}\n\tdisplayColumnWidth(view, pluginState.activeHandle, width, defaultCellMinWidth);\n\twin.addEventListener(\"mouseup\", finish);\n\twin.addEventListener(\"mousemove\", move);\n\tevent.preventDefault();\n\treturn true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n\tconst width = colwidth && colwidth[colwidth.length - 1];\n\tif (width) return width;\n\tconst dom = view.domAtPos(cellPos);\n\tlet domWidth = dom.node.childNodes[dom.offset].offsetWidth, parts = colspan;\n\tif (colwidth) {\n\t\tfor (let i = 0; i < colspan; i++) if (colwidth[i]) {\n\t\t\tdomWidth -= colwidth[i];\n\t\t\tparts--;\n\t\t}\n\t}\n\treturn domWidth / parts;\n}\nfunction domCellAround(target) {\n\twhile (target && target.nodeName != \"TD\" && target.nodeName != \"TH\") target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n\treturn target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n\tconst offset = side == \"right\" ? -handleWidth : handleWidth;\n\tconst found = view.posAtCoords({\n\t\tleft: event.clientX + offset,\n\t\ttop: event.clientY\n\t});\n\tif (!found) return -1;\n\tconst { pos } = found;\n\tconst $cell = cellAround(view.state.doc.resolve(pos));\n\tif (!$cell) return -1;\n\tif (side == \"right\") return $cell.pos;\n\tconst map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n\tconst index = map.map.indexOf($cell.pos - start);\n\treturn index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, resizeMinWidth) {\n\tconst offset = event.clientX - dragging.startX;\n\treturn Math.max(resizeMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n\tview.dispatch(view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value }));\n}\nfunction updateColumnWidth(view, cell, width) {\n\tconst $cell = view.state.doc.resolve(cell);\n\tconst table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n\tconst col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n\tconst tr = view.state.tr;\n\tfor (let row = 0; row < map.height; row++) {\n\t\tconst mapIndex = row * map.width + col;\n\t\tif (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n\t\tconst pos = map.map[mapIndex];\n\t\tconst attrs = table.nodeAt(pos).attrs;\n\t\tconst index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n\t\tif (attrs.colwidth && attrs.colwidth[index] == width) continue;\n\t\tconst colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n\t\tcolwidth[index] = width;\n\t\ttr.setNodeMarkup(start + pos, null, {\n\t\t\t...attrs,\n\t\t\tcolwidth\n\t\t});\n\t}\n\tif (tr.docChanged) view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, defaultCellMinWidth) {\n\tconst $cell = view.state.doc.resolve(cell);\n\tconst table = $cell.node(-1), start = $cell.start(-1);\n\tconst col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n\tlet dom = view.domAtPos($cell.start(-1)).node;\n\twhile (dom && dom.nodeName != \"TABLE\") dom = dom.parentNode;\n\tif (!dom) return;\n\tupdateColumnsOnResize(table, dom.firstChild, dom, defaultCellMinWidth, col, width);\n}\nfunction zeroes(n) {\n\treturn Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n\tconst decorations = [];\n\tconst $cell = state.doc.resolve(cell);\n\tconst table = $cell.node(-1);\n\tif (!table) return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.empty;\n\tconst map = TableMap.get(table);\n\tconst start = $cell.start(-1);\n\tconst col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n\tfor (let row = 0; row < map.height; row++) {\n\t\tconst index = col + row * map.width;\n\t\tif ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n\t\t\tvar _columnResizingPlugin;\n\t\t\tconst cellPos = map.map[index];\n\t\t\tconst pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n\t\t\tconst dom = document.createElement(\"div\");\n\t\t\tdom.className = \"column-resize-handle\";\n\t\t\tif ((_columnResizingPlugin = columnResizingPluginKey.getState(state)) === null || _columnResizingPlugin === void 0 ? void 0 : _columnResizingPlugin.dragging) decorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.node(start + cellPos, start + cellPos + table.nodeAt(cellPos).nodeSize, { class: \"column-resize-dragging\" }));\n\t\t\tdecorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(pos, dom));\n\t\t}\n\t}\n\treturn prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, decorations);\n}\n\n//#endregion\n//#region src/index.ts\n/**\n* Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n* that, when added to an editor, enables cell-selection, handles\n* cell-based copy/paste, and makes sure tables stay well-formed (each\n* row has the same width, and cells don't overlap).\n*\n* You should probably put this plugin near the end of your array of\n* plugins, since it handles mouse and arrow key events in tables\n* rather broadly, and other plugins, like the gap cursor or the\n* column-width dragging plugin, might want to get a turn first to\n* perform more specific behavior.\n*\n* @public\n*/\nfunction tableEditing({ allowTableNodeSelection = false } = {}) {\n\treturn new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n\t\tkey: tableEditingKey,\n\t\tstate: {\n\t\t\tinit() {\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tapply(tr, cur) {\n\t\t\t\tconst set = tr.getMeta(tableEditingKey);\n\t\t\t\tif (set != null) return set == -1 ? null : set;\n\t\t\t\tif (cur == null || !tr.docChanged) return cur;\n\t\t\t\tconst { deleted, pos } = tr.mapping.mapResult(cur);\n\t\t\t\treturn deleted ? null : pos;\n\t\t\t}\n\t\t},\n\t\tprops: {\n\t\t\tdecorations: drawCellSelection,\n\t\t\thandleDOMEvents: { mousedown: handleMouseDown$1 },\n\t\t\tcreateSelectionBetween(view) {\n\t\t\t\treturn tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n\t\t\t},\n\t\t\thandleTripleClick,\n\t\t\thandleKeyDown,\n\t\t\thandlePaste\n\t\t},\n\t\tappendTransaction(_, oldState, state) {\n\t\t\treturn normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);\n\t\t}\n\t});\n}\n\n//#endregion\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvc2VtaXJyb3ItdGFibGVzQDEuOC41L25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci10YWJsZXMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStHO0FBQzNEO0FBQ1M7QUFDVDtBQUNGOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFpRDtBQUNwRSxtQkFBbUIsZ0VBQWdFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkMsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5REFBeUQ7QUFDbkUsVUFBVSx5REFBeUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CLGlDQUFpQyxrQkFBa0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBNEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBNEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Qix3REFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSwyREFBYTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0MsSUFBSTtBQUM5RCxZQUFZLHFEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ20zQjtBQUNuM0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy8xcjBuZjFzdC8xcjBuZjFzdC13ZWJzaXRlL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9zZW1pcnJvci10YWJsZXNAMS44LjUvbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXRhYmxlcy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVTZWxlY3Rpb24sIFBsdWdpbiwgUGx1Z2luS2V5LCBTZWxlY3Rpb24sIFNlbGVjdGlvblJhbmdlLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG5pbXBvcnQgeyBGcmFnbWVudCwgU2xpY2UgfSBmcm9tIFwicHJvc2VtaXJyb3ItbW9kZWxcIjtcbmltcG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQgfSBmcm9tIFwicHJvc2VtaXJyb3Itdmlld1wiO1xuaW1wb3J0IHsga2V5ZG93bkhhbmRsZXIgfSBmcm9tIFwicHJvc2VtaXJyb3Ita2V5bWFwXCI7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tIFwicHJvc2VtaXJyb3ItdHJhbnNmb3JtXCI7XG5cbi8vI3JlZ2lvbiBzcmMvdGFibGVtYXAudHNcbmxldCByZWFkRnJvbUNhY2hlO1xubGV0IGFkZFRvQ2FjaGU7XG5pZiAodHlwZW9mIFdlYWtNYXAgIT0gXCJ1bmRlZmluZWRcIikge1xuXHRsZXQgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcblx0cmVhZEZyb21DYWNoZSA9IChrZXkpID0+IGNhY2hlLmdldChrZXkpO1xuXHRhZGRUb0NhY2hlID0gKGtleSwgdmFsdWUpID0+IHtcblx0XHRjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xufSBlbHNlIHtcblx0Y29uc3QgY2FjaGUgPSBbXTtcblx0Y29uc3QgY2FjaGVTaXplID0gMTA7XG5cdGxldCBjYWNoZVBvcyA9IDA7XG5cdHJlYWRGcm9tQ2FjaGUgPSAoa2V5KSA9PiB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjYWNoZS5sZW5ndGg7IGkgKz0gMikgaWYgKGNhY2hlW2ldID09IGtleSkgcmV0dXJuIGNhY2hlW2kgKyAxXTtcblx0fTtcblx0YWRkVG9DYWNoZSA9IChrZXksIHZhbHVlKSA9PiB7XG5cdFx0aWYgKGNhY2hlUG9zID09IGNhY2hlU2l6ZSkgY2FjaGVQb3MgPSAwO1xuXHRcdGNhY2hlW2NhY2hlUG9zKytdID0ga2V5O1xuXHRcdHJldHVybiBjYWNoZVtjYWNoZVBvcysrXSA9IHZhbHVlO1xuXHR9O1xufVxuLyoqXG4qIEEgdGFibGUgbWFwIGRlc2NyaWJlcyB0aGUgc3RydWN0dXJlIG9mIGEgZ2l2ZW4gdGFibGUuIFRvIGF2b2lkXG4qIHJlY29tcHV0aW5nIHRoZW0gYWxsIHRoZSB0aW1lLCB0aGV5IGFyZSBjYWNoZWQgcGVyIHRhYmxlIG5vZGUuIFRvXG4qIGJlIGFibGUgdG8gZG8gdGhhdCwgcG9zaXRpb25zIHNhdmVkIGluIHRoZSBtYXAgYXJlIHJlbGF0aXZlIHRvIHRoZVxuKiBzdGFydCBvZiB0aGUgdGFibGUsIHJhdGhlciB0aGFuIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qXG4qIEBwdWJsaWNcbiovXG52YXIgVGFibGVNYXAgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIG1hcCwgcHJvYmxlbXMpIHtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5tYXAgPSBtYXA7XG5cdFx0dGhpcy5wcm9ibGVtcyA9IHByb2JsZW1zO1xuXHR9XG5cdGZpbmRDZWxsKHBvcykge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXAubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGN1clBvcyA9IHRoaXMubWFwW2ldO1xuXHRcdFx0aWYgKGN1clBvcyAhPSBwb3MpIGNvbnRpbnVlO1xuXHRcdFx0Y29uc3QgbGVmdCA9IGkgJSB0aGlzLndpZHRoO1xuXHRcdFx0Y29uc3QgdG9wID0gaSAvIHRoaXMud2lkdGggfCAwO1xuXHRcdFx0bGV0IHJpZ2h0ID0gbGVmdCArIDE7XG5cdFx0XHRsZXQgYm90dG9tID0gdG9wICsgMTtcblx0XHRcdGZvciAobGV0IGogPSAxOyByaWdodCA8IHRoaXMud2lkdGggJiYgdGhpcy5tYXBbaSArIGpdID09IGN1clBvczsgaisrKSByaWdodCsrO1xuXHRcdFx0Zm9yIChsZXQgaiA9IDE7IGJvdHRvbSA8IHRoaXMuaGVpZ2h0ICYmIHRoaXMubWFwW2kgKyB0aGlzLndpZHRoICogal0gPT0gY3VyUG9zOyBqKyspIGJvdHRvbSsrO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bGVmdCxcblx0XHRcdFx0dG9wLFxuXHRcdFx0XHRyaWdodCxcblx0XHRcdFx0Ym90dG9tXG5cdFx0XHR9O1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gY2VsbCB3aXRoIG9mZnNldCAke3Bvc30gZm91bmRgKTtcblx0fVxuXHRjb2xDb3VudChwb3MpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFwLmxlbmd0aDsgaSsrKSBpZiAodGhpcy5tYXBbaV0gPT0gcG9zKSByZXR1cm4gaSAlIHRoaXMud2lkdGg7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIGNlbGwgd2l0aCBvZmZzZXQgJHtwb3N9IGZvdW5kYCk7XG5cdH1cblx0bmV4dENlbGwocG9zLCBheGlzLCBkaXIpIHtcblx0XHRjb25zdCB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gdGhpcy5maW5kQ2VsbChwb3MpO1xuXHRcdGlmIChheGlzID09IFwiaG9yaXpcIikge1xuXHRcdFx0aWYgKGRpciA8IDAgPyBsZWZ0ID09IDAgOiByaWdodCA9PSB0aGlzLndpZHRoKSByZXR1cm4gbnVsbDtcblx0XHRcdHJldHVybiB0aGlzLm1hcFt0b3AgKiB0aGlzLndpZHRoICsgKGRpciA8IDAgPyBsZWZ0IC0gMSA6IHJpZ2h0KV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChkaXIgPCAwID8gdG9wID09IDAgOiBib3R0b20gPT0gdGhpcy5oZWlnaHQpIHJldHVybiBudWxsO1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwW2xlZnQgKyB0aGlzLndpZHRoICogKGRpciA8IDAgPyB0b3AgLSAxIDogYm90dG9tKV07XG5cdFx0fVxuXHR9XG5cdHJlY3RCZXR3ZWVuKGEsIGIpIHtcblx0XHRjb25zdCB7IGxlZnQ6IGxlZnRBLCByaWdodDogcmlnaHRBLCB0b3A6IHRvcEEsIGJvdHRvbTogYm90dG9tQSB9ID0gdGhpcy5maW5kQ2VsbChhKTtcblx0XHRjb25zdCB7IGxlZnQ6IGxlZnRCLCByaWdodDogcmlnaHRCLCB0b3A6IHRvcEIsIGJvdHRvbTogYm90dG9tQiB9ID0gdGhpcy5maW5kQ2VsbChiKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bGVmdDogTWF0aC5taW4obGVmdEEsIGxlZnRCKSxcblx0XHRcdHRvcDogTWF0aC5taW4odG9wQSwgdG9wQiksXG5cdFx0XHRyaWdodDogTWF0aC5tYXgocmlnaHRBLCByaWdodEIpLFxuXHRcdFx0Ym90dG9tOiBNYXRoLm1heChib3R0b21BLCBib3R0b21CKVxuXHRcdH07XG5cdH1cblx0Y2VsbHNJblJlY3QocmVjdCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRcdGNvbnN0IHNlZW4gPSB7fTtcblx0XHRmb3IgKGxldCByb3cgPSByZWN0LnRvcDsgcm93IDwgcmVjdC5ib3R0b207IHJvdysrKSBmb3IgKGxldCBjb2wgPSByZWN0LmxlZnQ7IGNvbCA8IHJlY3QucmlnaHQ7IGNvbCsrKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IHJvdyAqIHRoaXMud2lkdGggKyBjb2w7XG5cdFx0XHRjb25zdCBwb3MgPSB0aGlzLm1hcFtpbmRleF07XG5cdFx0XHRpZiAoc2Vlbltwb3NdKSBjb250aW51ZTtcblx0XHRcdHNlZW5bcG9zXSA9IHRydWU7XG5cdFx0XHRpZiAoY29sID09IHJlY3QubGVmdCAmJiBjb2wgJiYgdGhpcy5tYXBbaW5kZXggLSAxXSA9PSBwb3MgfHwgcm93ID09IHJlY3QudG9wICYmIHJvdyAmJiB0aGlzLm1hcFtpbmRleCAtIHRoaXMud2lkdGhdID09IHBvcykgY29udGludWU7XG5cdFx0XHRyZXN1bHQucHVzaChwb3MpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cdHBvc2l0aW9uQXQocm93LCBjb2wsIHRhYmxlKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIHJvd1N0YXJ0ID0gMDs7IGkrKykge1xuXHRcdFx0Y29uc3Qgcm93RW5kID0gcm93U3RhcnQgKyB0YWJsZS5jaGlsZChpKS5ub2RlU2l6ZTtcblx0XHRcdGlmIChpID09IHJvdykge1xuXHRcdFx0XHRsZXQgaW5kZXggPSBjb2wgKyByb3cgKiB0aGlzLndpZHRoO1xuXHRcdFx0XHRjb25zdCByb3dFbmRJbmRleCA9IChyb3cgKyAxKSAqIHRoaXMud2lkdGg7XG5cdFx0XHRcdHdoaWxlIChpbmRleCA8IHJvd0VuZEluZGV4ICYmIHRoaXMubWFwW2luZGV4XSA8IHJvd1N0YXJ0KSBpbmRleCsrO1xuXHRcdFx0XHRyZXR1cm4gaW5kZXggPT0gcm93RW5kSW5kZXggPyByb3dFbmQgLSAxIDogdGhpcy5tYXBbaW5kZXhdO1xuXHRcdFx0fVxuXHRcdFx0cm93U3RhcnQgPSByb3dFbmQ7XG5cdFx0fVxuXHR9XG5cdHN0YXRpYyBnZXQodGFibGUpIHtcblx0XHRyZXR1cm4gcmVhZEZyb21DYWNoZSh0YWJsZSkgfHwgYWRkVG9DYWNoZSh0YWJsZSwgY29tcHV0ZU1hcCh0YWJsZSkpO1xuXHR9XG59O1xuZnVuY3Rpb24gY29tcHV0ZU1hcCh0YWJsZSkge1xuXHRpZiAodGFibGUudHlwZS5zcGVjLnRhYmxlUm9sZSAhPSBcInRhYmxlXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm90IGEgdGFibGUgbm9kZTogXCIgKyB0YWJsZS50eXBlLm5hbWUpO1xuXHRjb25zdCB3aWR0aCA9IGZpbmRXaWR0aCh0YWJsZSksIGhlaWdodCA9IHRhYmxlLmNoaWxkQ291bnQ7XG5cdGNvbnN0IG1hcCA9IFtdO1xuXHRsZXQgbWFwUG9zID0gMDtcblx0bGV0IHByb2JsZW1zID0gbnVsbDtcblx0Y29uc3QgY29sV2lkdGhzID0gW107XG5cdGZvciAobGV0IGkgPSAwLCBlID0gd2lkdGggKiBoZWlnaHQ7IGkgPCBlOyBpKyspIG1hcFtpXSA9IDA7XG5cdGZvciAobGV0IHJvdyA9IDAsIHBvcyA9IDA7IHJvdyA8IGhlaWdodDsgcm93KyspIHtcblx0XHRjb25zdCByb3dOb2RlID0gdGFibGUuY2hpbGQocm93KTtcblx0XHRwb3MrKztcblx0XHRmb3IgKGxldCBpID0gMDs7IGkrKykge1xuXHRcdFx0d2hpbGUgKG1hcFBvcyA8IG1hcC5sZW5ndGggJiYgbWFwW21hcFBvc10gIT0gMCkgbWFwUG9zKys7XG5cdFx0XHRpZiAoaSA9PSByb3dOb2RlLmNoaWxkQ291bnQpIGJyZWFrO1xuXHRcdFx0Y29uc3QgY2VsbE5vZGUgPSByb3dOb2RlLmNoaWxkKGkpO1xuXHRcdFx0Y29uc3QgeyBjb2xzcGFuLCByb3dzcGFuLCBjb2x3aWR0aCB9ID0gY2VsbE5vZGUuYXR0cnM7XG5cdFx0XHRmb3IgKGxldCBoID0gMDsgaCA8IHJvd3NwYW47IGgrKykge1xuXHRcdFx0XHRpZiAoaCArIHJvdyA+PSBoZWlnaHQpIHtcblx0XHRcdFx0XHQocHJvYmxlbXMgfHwgKHByb2JsZW1zID0gW10pKS5wdXNoKHtcblx0XHRcdFx0XHRcdHR5cGU6IFwib3Zlcmxvbmdfcm93c3BhblwiLFxuXHRcdFx0XHRcdFx0cG9zLFxuXHRcdFx0XHRcdFx0bjogcm93c3BhbiAtIGhcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBzdGFydCA9IG1hcFBvcyArIGggKiB3aWR0aDtcblx0XHRcdFx0Zm9yIChsZXQgdyA9IDA7IHcgPCBjb2xzcGFuOyB3KyspIHtcblx0XHRcdFx0XHRpZiAobWFwW3N0YXJ0ICsgd10gPT0gMCkgbWFwW3N0YXJ0ICsgd10gPSBwb3M7XG5cdFx0XHRcdFx0ZWxzZSAocHJvYmxlbXMgfHwgKHByb2JsZW1zID0gW10pKS5wdXNoKHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiY29sbGlzaW9uXCIsXG5cdFx0XHRcdFx0XHRyb3csXG5cdFx0XHRcdFx0XHRwb3MsXG5cdFx0XHRcdFx0XHRuOiBjb2xzcGFuIC0gd1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGNvbnN0IGNvbFcgPSBjb2x3aWR0aCAmJiBjb2x3aWR0aFt3XTtcblx0XHRcdFx0XHRpZiAoY29sVykge1xuXHRcdFx0XHRcdFx0Y29uc3Qgd2lkdGhJbmRleCA9IChzdGFydCArIHcpICUgd2lkdGggKiAyLCBwcmV2ID0gY29sV2lkdGhzW3dpZHRoSW5kZXhdO1xuXHRcdFx0XHRcdFx0aWYgKHByZXYgPT0gbnVsbCB8fCBwcmV2ICE9IGNvbFcgJiYgY29sV2lkdGhzW3dpZHRoSW5kZXggKyAxXSA9PSAxKSB7XG5cdFx0XHRcdFx0XHRcdGNvbFdpZHRoc1t3aWR0aEluZGV4XSA9IGNvbFc7XG5cdFx0XHRcdFx0XHRcdGNvbFdpZHRoc1t3aWR0aEluZGV4ICsgMV0gPSAxO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwcmV2ID09IGNvbFcpIGNvbFdpZHRoc1t3aWR0aEluZGV4ICsgMV0rKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1hcFBvcyArPSBjb2xzcGFuO1xuXHRcdFx0cG9zICs9IGNlbGxOb2RlLm5vZGVTaXplO1xuXHRcdH1cblx0XHRjb25zdCBleHBlY3RlZFBvcyA9IChyb3cgKyAxKSAqIHdpZHRoO1xuXHRcdGxldCBtaXNzaW5nID0gMDtcblx0XHR3aGlsZSAobWFwUG9zIDwgZXhwZWN0ZWRQb3MpIGlmIChtYXBbbWFwUG9zKytdID09IDApIG1pc3NpbmcrKztcblx0XHRpZiAobWlzc2luZykgKHByb2JsZW1zIHx8IChwcm9ibGVtcyA9IFtdKSkucHVzaCh7XG5cdFx0XHR0eXBlOiBcIm1pc3NpbmdcIixcblx0XHRcdHJvdyxcblx0XHRcdG46IG1pc3Npbmdcblx0XHR9KTtcblx0XHRwb3MrKztcblx0fVxuXHRpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSAocHJvYmxlbXMgfHwgKHByb2JsZW1zID0gW10pKS5wdXNoKHsgdHlwZTogXCJ6ZXJvX3NpemVkXCIgfSk7XG5cdGNvbnN0IHRhYmxlTWFwID0gbmV3IFRhYmxlTWFwKHdpZHRoLCBoZWlnaHQsIG1hcCwgcHJvYmxlbXMpO1xuXHRsZXQgYmFkV2lkdGhzID0gZmFsc2U7XG5cdGZvciAobGV0IGkgPSAwOyAhYmFkV2lkdGhzICYmIGkgPCBjb2xXaWR0aHMubGVuZ3RoOyBpICs9IDIpIGlmIChjb2xXaWR0aHNbaV0gIT0gbnVsbCAmJiBjb2xXaWR0aHNbaSArIDFdIDwgaGVpZ2h0KSBiYWRXaWR0aHMgPSB0cnVlO1xuXHRpZiAoYmFkV2lkdGhzKSBmaW5kQmFkQ29sV2lkdGhzKHRhYmxlTWFwLCBjb2xXaWR0aHMsIHRhYmxlKTtcblx0cmV0dXJuIHRhYmxlTWFwO1xufVxuZnVuY3Rpb24gZmluZFdpZHRoKHRhYmxlKSB7XG5cdGxldCB3aWR0aCA9IC0xO1xuXHRsZXQgaGFzUm93U3BhbiA9IGZhbHNlO1xuXHRmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0YWJsZS5jaGlsZENvdW50OyByb3crKykge1xuXHRcdGNvbnN0IHJvd05vZGUgPSB0YWJsZS5jaGlsZChyb3cpO1xuXHRcdGxldCByb3dXaWR0aCA9IDA7XG5cdFx0aWYgKGhhc1Jvd1NwYW4pIGZvciAobGV0IGogPSAwOyBqIDwgcm93OyBqKyspIHtcblx0XHRcdGNvbnN0IHByZXZSb3cgPSB0YWJsZS5jaGlsZChqKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcHJldlJvdy5jaGlsZENvdW50OyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY2VsbCA9IHByZXZSb3cuY2hpbGQoaSk7XG5cdFx0XHRcdGlmIChqICsgY2VsbC5hdHRycy5yb3dzcGFuID4gcm93KSByb3dXaWR0aCArPSBjZWxsLmF0dHJzLmNvbHNwYW47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93Tm9kZS5jaGlsZENvdW50OyBpKyspIHtcblx0XHRcdGNvbnN0IGNlbGwgPSByb3dOb2RlLmNoaWxkKGkpO1xuXHRcdFx0cm93V2lkdGggKz0gY2VsbC5hdHRycy5jb2xzcGFuO1xuXHRcdFx0aWYgKGNlbGwuYXR0cnMucm93c3BhbiA+IDEpIGhhc1Jvd1NwYW4gPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAod2lkdGggPT0gLTEpIHdpZHRoID0gcm93V2lkdGg7XG5cdFx0ZWxzZSBpZiAod2lkdGggIT0gcm93V2lkdGgpIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHJvd1dpZHRoKTtcblx0fVxuXHRyZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiBmaW5kQmFkQ29sV2lkdGhzKG1hcCwgY29sV2lkdGhzLCB0YWJsZSkge1xuXHRpZiAoIW1hcC5wcm9ibGVtcykgbWFwLnByb2JsZW1zID0gW107XG5cdGNvbnN0IHNlZW4gPSB7fTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtYXAubWFwLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgcG9zID0gbWFwLm1hcFtpXTtcblx0XHRpZiAoc2Vlbltwb3NdKSBjb250aW51ZTtcblx0XHRzZWVuW3Bvc10gPSB0cnVlO1xuXHRcdGNvbnN0IG5vZGUgPSB0YWJsZS5ub2RlQXQocG9zKTtcblx0XHRpZiAoIW5vZGUpIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBjZWxsIHdpdGggb2Zmc2V0ICR7cG9zfSBmb3VuZGApO1xuXHRcdGxldCB1cGRhdGVkID0gbnVsbDtcblx0XHRjb25zdCBhdHRycyA9IG5vZGUuYXR0cnM7XG5cdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBhdHRycy5jb2xzcGFuOyBqKyspIHtcblx0XHRcdGNvbnN0IGNvbFdpZHRoID0gY29sV2lkdGhzWyhpICsgaikgJSBtYXAud2lkdGggKiAyXTtcblx0XHRcdGlmIChjb2xXaWR0aCAhPSBudWxsICYmICghYXR0cnMuY29sd2lkdGggfHwgYXR0cnMuY29sd2lkdGhbal0gIT0gY29sV2lkdGgpKSAodXBkYXRlZCB8fCAodXBkYXRlZCA9IGZyZXNoQ29sV2lkdGgoYXR0cnMpKSlbal0gPSBjb2xXaWR0aDtcblx0XHR9XG5cdFx0aWYgKHVwZGF0ZWQpIG1hcC5wcm9ibGVtcy51bnNoaWZ0KHtcblx0XHRcdHR5cGU6IFwiY29sd2lkdGggbWlzbWF0Y2hcIixcblx0XHRcdHBvcyxcblx0XHRcdGNvbHdpZHRoOiB1cGRhdGVkXG5cdFx0fSk7XG5cdH1cbn1cbmZ1bmN0aW9uIGZyZXNoQ29sV2lkdGgoYXR0cnMpIHtcblx0aWYgKGF0dHJzLmNvbHdpZHRoKSByZXR1cm4gYXR0cnMuY29sd2lkdGguc2xpY2UoKTtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMuY29sc3BhbjsgaSsrKSByZXN1bHQucHVzaCgwKTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3NjaGVtYS50c1xuZnVuY3Rpb24gZ2V0Q2VsbEF0dHJzKGRvbSwgZXh0cmFBdHRycykge1xuXHRpZiAodHlwZW9mIGRvbSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHt9O1xuXHRjb25zdCB3aWR0aEF0dHIgPSBkb20uZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2x3aWR0aFwiKTtcblx0Y29uc3Qgd2lkdGhzID0gd2lkdGhBdHRyICYmIC9eXFxkKygsXFxkKykqJC8udGVzdCh3aWR0aEF0dHIpID8gd2lkdGhBdHRyLnNwbGl0KFwiLFwiKS5tYXAoKHMpID0+IE51bWJlcihzKSkgOiBudWxsO1xuXHRjb25zdCBjb2xzcGFuID0gTnVtYmVyKGRvbS5nZXRBdHRyaWJ1dGUoXCJjb2xzcGFuXCIpIHx8IDEpO1xuXHRjb25zdCByZXN1bHQgPSB7XG5cdFx0Y29sc3Bhbixcblx0XHRyb3dzcGFuOiBOdW1iZXIoZG9tLmdldEF0dHJpYnV0ZShcInJvd3NwYW5cIikgfHwgMSksXG5cdFx0Y29sd2lkdGg6IHdpZHRocyAmJiB3aWR0aHMubGVuZ3RoID09IGNvbHNwYW4gPyB3aWR0aHMgOiBudWxsXG5cdH07XG5cdGZvciAoY29uc3QgcHJvcCBpbiBleHRyYUF0dHJzKSB7XG5cdFx0Y29uc3QgZ2V0dGVyID0gZXh0cmFBdHRyc1twcm9wXS5nZXRGcm9tRE9NO1xuXHRcdGNvbnN0IHZhbHVlID0gZ2V0dGVyICYmIGdldHRlcihkb20pO1xuXHRcdGlmICh2YWx1ZSAhPSBudWxsKSByZXN1bHRbcHJvcF0gPSB2YWx1ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2V0Q2VsbEF0dHJzKG5vZGUsIGV4dHJhQXR0cnMpIHtcblx0Y29uc3QgYXR0cnMgPSB7fTtcblx0aWYgKG5vZGUuYXR0cnMuY29sc3BhbiAhPSAxKSBhdHRycy5jb2xzcGFuID0gbm9kZS5hdHRycy5jb2xzcGFuO1xuXHRpZiAobm9kZS5hdHRycy5yb3dzcGFuICE9IDEpIGF0dHJzLnJvd3NwYW4gPSBub2RlLmF0dHJzLnJvd3NwYW47XG5cdGlmIChub2RlLmF0dHJzLmNvbHdpZHRoKSBhdHRyc1tcImRhdGEtY29sd2lkdGhcIl0gPSBub2RlLmF0dHJzLmNvbHdpZHRoLmpvaW4oXCIsXCIpO1xuXHRmb3IgKGNvbnN0IHByb3AgaW4gZXh0cmFBdHRycykge1xuXHRcdGNvbnN0IHNldHRlciA9IGV4dHJhQXR0cnNbcHJvcF0uc2V0RE9NQXR0cjtcblx0XHRpZiAoc2V0dGVyKSBzZXR0ZXIobm9kZS5hdHRyc1twcm9wXSwgYXR0cnMpO1xuXHR9XG5cdHJldHVybiBhdHRycztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ29sd2lkdGgodmFsdWUpIHtcblx0aWYgKHZhbHVlID09PSBudWxsKSByZXR1cm47XG5cdGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjb2x3aWR0aCBtdXN0IGJlIG51bGwgb3IgYW4gYXJyYXlcIik7XG5cdGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkgaWYgKHR5cGVvZiBpdGVtICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY29sd2lkdGggbXVzdCBiZSBudWxsIG9yIGFuIGFycmF5IG9mIG51bWJlcnNcIik7XG59XG4vKipcbiogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgc2V0IG9mIFtub2RlXG4qIHNwZWNzXShodHRwOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5TY2hlbWFTcGVjLm5vZGVzKSBmb3JcbiogYHRhYmxlYCwgYHRhYmxlX3Jvd2AsIGFuZCBgdGFibGVfY2VsbGAgbm9kZXMgdHlwZXMgYXMgdXNlZCBieSB0aGlzXG4qIG1vZHVsZS4gVGhlIHJlc3VsdCBjYW4gdGhlbiBiZSBhZGRlZCB0byB0aGUgc2V0IG9mIG5vZGVzIHdoZW5cbiogY3JlYXRpbmcgYSBzY2hlbWEuXG4qXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiB0YWJsZU5vZGVzKG9wdGlvbnMpIHtcblx0Y29uc3QgZXh0cmFBdHRycyA9IG9wdGlvbnMuY2VsbEF0dHJpYnV0ZXMgfHwge307XG5cdGNvbnN0IGNlbGxBdHRycyA9IHtcblx0XHRjb2xzcGFuOiB7XG5cdFx0XHRkZWZhdWx0OiAxLFxuXHRcdFx0dmFsaWRhdGU6IFwibnVtYmVyXCJcblx0XHR9LFxuXHRcdHJvd3NwYW46IHtcblx0XHRcdGRlZmF1bHQ6IDEsXG5cdFx0XHR2YWxpZGF0ZTogXCJudW1iZXJcIlxuXHRcdH0sXG5cdFx0Y29sd2lkdGg6IHtcblx0XHRcdGRlZmF1bHQ6IG51bGwsXG5cdFx0XHR2YWxpZGF0ZTogdmFsaWRhdGVDb2x3aWR0aFxuXHRcdH1cblx0fTtcblx0Zm9yIChjb25zdCBwcm9wIGluIGV4dHJhQXR0cnMpIGNlbGxBdHRyc1twcm9wXSA9IHtcblx0XHRkZWZhdWx0OiBleHRyYUF0dHJzW3Byb3BdLmRlZmF1bHQsXG5cdFx0dmFsaWRhdGU6IGV4dHJhQXR0cnNbcHJvcF0udmFsaWRhdGVcblx0fTtcblx0cmV0dXJuIHtcblx0XHR0YWJsZToge1xuXHRcdFx0Y29udGVudDogXCJ0YWJsZV9yb3crXCIsXG5cdFx0XHR0YWJsZVJvbGU6IFwidGFibGVcIixcblx0XHRcdGlzb2xhdGluZzogdHJ1ZSxcblx0XHRcdGdyb3VwOiBvcHRpb25zLnRhYmxlR3JvdXAsXG5cdFx0XHRwYXJzZURPTTogW3sgdGFnOiBcInRhYmxlXCIgfV0sXG5cdFx0XHR0b0RPTSgpIHtcblx0XHRcdFx0cmV0dXJuIFtcInRhYmxlXCIsIFtcInRib2R5XCIsIDBdXTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRhYmxlX3Jvdzoge1xuXHRcdFx0Y29udGVudDogXCIodGFibGVfY2VsbCB8IHRhYmxlX2hlYWRlcikqXCIsXG5cdFx0XHR0YWJsZVJvbGU6IFwicm93XCIsXG5cdFx0XHRwYXJzZURPTTogW3sgdGFnOiBcInRyXCIgfV0sXG5cdFx0XHR0b0RPTSgpIHtcblx0XHRcdFx0cmV0dXJuIFtcInRyXCIsIDBdO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dGFibGVfY2VsbDoge1xuXHRcdFx0Y29udGVudDogb3B0aW9ucy5jZWxsQ29udGVudCxcblx0XHRcdGF0dHJzOiBjZWxsQXR0cnMsXG5cdFx0XHR0YWJsZVJvbGU6IFwiY2VsbFwiLFxuXHRcdFx0aXNvbGF0aW5nOiB0cnVlLFxuXHRcdFx0cGFyc2VET006IFt7XG5cdFx0XHRcdHRhZzogXCJ0ZFwiLFxuXHRcdFx0XHRnZXRBdHRyczogKGRvbSkgPT4gZ2V0Q2VsbEF0dHJzKGRvbSwgZXh0cmFBdHRycylcblx0XHRcdH1dLFxuXHRcdFx0dG9ET00obm9kZSkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFwidGRcIixcblx0XHRcdFx0XHRzZXRDZWxsQXR0cnMobm9kZSwgZXh0cmFBdHRycyksXG5cdFx0XHRcdFx0MFxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dGFibGVfaGVhZGVyOiB7XG5cdFx0XHRjb250ZW50OiBvcHRpb25zLmNlbGxDb250ZW50LFxuXHRcdFx0YXR0cnM6IGNlbGxBdHRycyxcblx0XHRcdHRhYmxlUm9sZTogXCJoZWFkZXJfY2VsbFwiLFxuXHRcdFx0aXNvbGF0aW5nOiB0cnVlLFxuXHRcdFx0cGFyc2VET006IFt7XG5cdFx0XHRcdHRhZzogXCJ0aFwiLFxuXHRcdFx0XHRnZXRBdHRyczogKGRvbSkgPT4gZ2V0Q2VsbEF0dHJzKGRvbSwgZXh0cmFBdHRycylcblx0XHRcdH1dLFxuXHRcdFx0dG9ET00obm9kZSkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFwidGhcIixcblx0XHRcdFx0XHRzZXRDZWxsQXR0cnMobm9kZSwgZXh0cmFBdHRycyksXG5cdFx0XHRcdFx0MFxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cbi8qKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gdGFibGVOb2RlVHlwZXMoc2NoZW1hKSB7XG5cdGxldCByZXN1bHQgPSBzY2hlbWEuY2FjaGVkLnRhYmxlTm9kZVR5cGVzO1xuXHRpZiAoIXJlc3VsdCkge1xuXHRcdHJlc3VsdCA9IHNjaGVtYS5jYWNoZWQudGFibGVOb2RlVHlwZXMgPSB7fTtcblx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gc2NoZW1hLm5vZGVzKSB7XG5cdFx0XHRjb25zdCB0eXBlID0gc2NoZW1hLm5vZGVzW25hbWVdLCByb2xlID0gdHlwZS5zcGVjLnRhYmxlUm9sZTtcblx0XHRcdGlmIChyb2xlKSByZXN1bHRbcm9sZV0gPSB0eXBlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdXRpbC50c1xuLyoqXG4qIEBwdWJsaWNcbiovXG5jb25zdCB0YWJsZUVkaXRpbmdLZXkgPSBuZXcgUGx1Z2luS2V5KFwic2VsZWN0aW5nQ2VsbHNcIik7XG4vKipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIGNlbGxBcm91bmQoJHBvcykge1xuXHRmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPiAwOyBkLS0pIGlmICgkcG9zLm5vZGUoZCkudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInJvd1wiKSByZXR1cm4gJHBvcy5ub2RlKDApLnJlc29sdmUoJHBvcy5iZWZvcmUoZCArIDEpKTtcblx0cmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjZWxsV3JhcHBpbmcoJHBvcykge1xuXHRmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+IDA7IGQtLSkge1xuXHRcdGNvbnN0IHJvbGUgPSAkcG9zLm5vZGUoZCkudHlwZS5zcGVjLnRhYmxlUm9sZTtcblx0XHRpZiAocm9sZSA9PT0gXCJjZWxsXCIgfHwgcm9sZSA9PT0gXCJoZWFkZXJfY2VsbFwiKSByZXR1cm4gJHBvcy5ub2RlKGQpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufVxuLyoqXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBpc0luVGFibGUoc3RhdGUpIHtcblx0Y29uc3QgJGhlYWQgPSBzdGF0ZS5zZWxlY3Rpb24uJGhlYWQ7XG5cdGZvciAobGV0IGQgPSAkaGVhZC5kZXB0aDsgZCA+IDA7IGQtLSkgaWYgKCRoZWFkLm5vZGUoZCkudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInJvd1wiKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIGZhbHNlO1xufVxuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIHNlbGVjdGlvbkNlbGwoc3RhdGUpIHtcblx0Y29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuXHRpZiAoXCIkYW5jaG9yQ2VsbFwiIGluIHNlbCAmJiBzZWwuJGFuY2hvckNlbGwpIHJldHVybiBzZWwuJGFuY2hvckNlbGwucG9zID4gc2VsLiRoZWFkQ2VsbC5wb3MgPyBzZWwuJGFuY2hvckNlbGwgOiBzZWwuJGhlYWRDZWxsO1xuXHRlbHNlIGlmIChcIm5vZGVcIiBpbiBzZWwgJiYgc2VsLm5vZGUgJiYgc2VsLm5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcImNlbGxcIikgcmV0dXJuIHNlbC4kYW5jaG9yO1xuXHRjb25zdCAkY2VsbCA9IGNlbGxBcm91bmQoc2VsLiRoZWFkKSB8fCBjZWxsTmVhcihzZWwuJGhlYWQpO1xuXHRpZiAoJGNlbGwpIHJldHVybiAkY2VsbDtcblx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIGNlbGwgZm91bmQgYXJvdW5kIHBvc2l0aW9uICR7c2VsLmhlYWR9YCk7XG59XG4vKipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIGNlbGxOZWFyKCRwb3MpIHtcblx0Zm9yIChsZXQgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlciwgcG9zID0gJHBvcy5wb3M7IGFmdGVyOyBhZnRlciA9IGFmdGVyLmZpcnN0Q2hpbGQsIHBvcysrKSB7XG5cdFx0Y29uc3Qgcm9sZSA9IGFmdGVyLnR5cGUuc3BlYy50YWJsZVJvbGU7XG5cdFx0aWYgKHJvbGUgPT0gXCJjZWxsXCIgfHwgcm9sZSA9PSBcImhlYWRlcl9jZWxsXCIpIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKHBvcyk7XG5cdH1cblx0Zm9yIChsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBwb3MgPSAkcG9zLnBvczsgYmVmb3JlOyBiZWZvcmUgPSBiZWZvcmUubGFzdENoaWxkLCBwb3MtLSkge1xuXHRcdGNvbnN0IHJvbGUgPSBiZWZvcmUudHlwZS5zcGVjLnRhYmxlUm9sZTtcblx0XHRpZiAocm9sZSA9PSBcImNlbGxcIiB8fCByb2xlID09IFwiaGVhZGVyX2NlbGxcIikgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUocG9zIC0gYmVmb3JlLm5vZGVTaXplKTtcblx0fVxufVxuLyoqXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBwb2ludHNBdENlbGwoJHBvcykge1xuXHRyZXR1cm4gJHBvcy5wYXJlbnQudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInJvd1wiICYmICEhJHBvcy5ub2RlQWZ0ZXI7XG59XG4vKipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIG1vdmVDZWxsRm9yd2FyZCgkcG9zKSB7XG5cdHJldHVybiAkcG9zLm5vZGUoMCkucmVzb2x2ZSgkcG9zLnBvcyArICRwb3Mubm9kZUFmdGVyLm5vZGVTaXplKTtcbn1cbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBpblNhbWVUYWJsZSgkY2VsbEEsICRjZWxsQikge1xuXHRyZXR1cm4gJGNlbGxBLmRlcHRoID09ICRjZWxsQi5kZXB0aCAmJiAkY2VsbEEucG9zID49ICRjZWxsQi5zdGFydCgtMSkgJiYgJGNlbGxBLnBvcyA8PSAkY2VsbEIuZW5kKC0xKTtcbn1cbi8qKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gZmluZENlbGwoJHBvcykge1xuXHRyZXR1cm4gVGFibGVNYXAuZ2V0KCRwb3Mubm9kZSgtMSkpLmZpbmRDZWxsKCRwb3MucG9zIC0gJHBvcy5zdGFydCgtMSkpO1xufVxuLyoqXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBjb2xDb3VudCgkcG9zKSB7XG5cdHJldHVybiBUYWJsZU1hcC5nZXQoJHBvcy5ub2RlKC0xKSkuY29sQ291bnQoJHBvcy5wb3MgLSAkcG9zLnN0YXJ0KC0xKSk7XG59XG4vKipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIG5leHRDZWxsKCRwb3MsIGF4aXMsIGRpcikge1xuXHRjb25zdCB0YWJsZSA9ICRwb3Mubm9kZSgtMSk7XG5cdGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG5cdGNvbnN0IHRhYmxlU3RhcnQgPSAkcG9zLnN0YXJ0KC0xKTtcblx0Y29uc3QgbW92ZWQgPSBtYXAubmV4dENlbGwoJHBvcy5wb3MgLSB0YWJsZVN0YXJ0LCBheGlzLCBkaXIpO1xuXHRyZXR1cm4gbW92ZWQgPT0gbnVsbCA/IG51bGwgOiAkcG9zLm5vZGUoMCkucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbW92ZWQpO1xufVxuLyoqXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiByZW1vdmVDb2xTcGFuKGF0dHJzLCBwb3MsIG4gPSAxKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHtcblx0XHQuLi5hdHRycyxcblx0XHRjb2xzcGFuOiBhdHRycy5jb2xzcGFuIC0gblxuXHR9O1xuXHRpZiAocmVzdWx0LmNvbHdpZHRoKSB7XG5cdFx0cmVzdWx0LmNvbHdpZHRoID0gcmVzdWx0LmNvbHdpZHRoLnNsaWNlKCk7XG5cdFx0cmVzdWx0LmNvbHdpZHRoLnNwbGljZShwb3MsIG4pO1xuXHRcdGlmICghcmVzdWx0LmNvbHdpZHRoLnNvbWUoKHcpID0+IHcgPiAwKSkgcmVzdWx0LmNvbHdpZHRoID0gbnVsbDtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBhZGRDb2xTcGFuKGF0dHJzLCBwb3MsIG4gPSAxKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHtcblx0XHQuLi5hdHRycyxcblx0XHRjb2xzcGFuOiBhdHRycy5jb2xzcGFuICsgblxuXHR9O1xuXHRpZiAocmVzdWx0LmNvbHdpZHRoKSB7XG5cdFx0cmVzdWx0LmNvbHdpZHRoID0gcmVzdWx0LmNvbHdpZHRoLnNsaWNlKCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHJlc3VsdC5jb2x3aWR0aC5zcGxpY2UocG9zLCAwLCAwKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBjb2x1bW5Jc0hlYWRlcihtYXAsIHRhYmxlLCBjb2wpIHtcblx0Y29uc3QgaGVhZGVyQ2VsbCA9IHRhYmxlTm9kZVR5cGVzKHRhYmxlLnR5cGUuc2NoZW1hKS5oZWFkZXJfY2VsbDtcblx0Zm9yIChsZXQgcm93ID0gMDsgcm93IDwgbWFwLmhlaWdodDsgcm93KyspIGlmICh0YWJsZS5ub2RlQXQobWFwLm1hcFtjb2wgKyByb3cgKiBtYXAud2lkdGhdKS50eXBlICE9IGhlYWRlckNlbGwpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHRydWU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9jZWxsc2VsZWN0aW9uLnRzXG4vKipcbiogQSBbYFNlbGVjdGlvbmBdKGh0dHA6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbilcbiogc3ViY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgY2VsbCBzZWxlY3Rpb24gc3Bhbm5pbmcgcGFydCBvZiBhIHRhYmxlLlxuKiBXaXRoIHRoZSBwbHVnaW4gZW5hYmxlZCwgdGhlc2Ugd2lsbCBiZSBjcmVhdGVkIHdoZW4gdGhlIHVzZXJcbiogc2VsZWN0cyBhY3Jvc3MgY2VsbHMsIGFuZCB3aWxsIGJlIGRyYXduIGJ5IGdpdmluZyBzZWxlY3RlZCBjZWxscyBhXG4qIGBzZWxlY3RlZENlbGxgIENTUyBjbGFzcy5cbipcbiogQHB1YmxpY1xuKi9cbnZhciBDZWxsU2VsZWN0aW9uID0gY2xhc3MgQ2VsbFNlbGVjdGlvbiBleHRlbmRzIFNlbGVjdGlvbiB7XG5cdGNvbnN0cnVjdG9yKCRhbmNob3JDZWxsLCAkaGVhZENlbGwgPSAkYW5jaG9yQ2VsbCkge1xuXHRcdGNvbnN0IHRhYmxlID0gJGFuY2hvckNlbGwubm9kZSgtMSk7XG5cdFx0Y29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcblx0XHRjb25zdCB0YWJsZVN0YXJ0ID0gJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuXHRcdGNvbnN0IHJlY3QgPSBtYXAucmVjdEJldHdlZW4oJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCwgJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuXHRcdGNvbnN0IGRvYyA9ICRhbmNob3JDZWxsLm5vZGUoMCk7XG5cdFx0Y29uc3QgY2VsbHMgPSBtYXAuY2VsbHNJblJlY3QocmVjdCkuZmlsdGVyKChwKSA9PiBwICE9ICRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcblx0XHRjZWxscy51bnNoaWZ0KCRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcblx0XHRjb25zdCByYW5nZXMgPSBjZWxscy5tYXAoKHBvcykgPT4ge1xuXHRcdFx0Y29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwb3MpO1xuXHRcdFx0aWYgKCFjZWxsKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gY2VsbCB3aXRoIG9mZnNldCAke3Bvc30gZm91bmRgKTtcblx0XHRcdGNvbnN0IGZyb20gPSB0YWJsZVN0YXJ0ICsgcG9zICsgMTtcblx0XHRcdHJldHVybiBuZXcgU2VsZWN0aW9uUmFuZ2UoZG9jLnJlc29sdmUoZnJvbSksIGRvYy5yZXNvbHZlKGZyb20gKyBjZWxsLmNvbnRlbnQuc2l6ZSkpO1xuXHRcdH0pO1xuXHRcdHN1cGVyKHJhbmdlc1swXS4kZnJvbSwgcmFuZ2VzWzBdLiR0bywgcmFuZ2VzKTtcblx0XHR0aGlzLiRhbmNob3JDZWxsID0gJGFuY2hvckNlbGw7XG5cdFx0dGhpcy4kaGVhZENlbGwgPSAkaGVhZENlbGw7XG5cdH1cblx0bWFwKGRvYywgbWFwcGluZykge1xuXHRcdGNvbnN0ICRhbmNob3JDZWxsID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy4kYW5jaG9yQ2VsbC5wb3MpKTtcblx0XHRjb25zdCAkaGVhZENlbGwgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLiRoZWFkQ2VsbC5wb3MpKTtcblx0XHRpZiAocG9pbnRzQXRDZWxsKCRhbmNob3JDZWxsKSAmJiBwb2ludHNBdENlbGwoJGhlYWRDZWxsKSAmJiBpblNhbWVUYWJsZSgkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKSkge1xuXHRcdFx0Y29uc3QgdGFibGVDaGFuZ2VkID0gdGhpcy4kYW5jaG9yQ2VsbC5ub2RlKC0xKSAhPSAkYW5jaG9yQ2VsbC5ub2RlKC0xKTtcblx0XHRcdGlmICh0YWJsZUNoYW5nZWQgJiYgdGhpcy5pc1Jvd1NlbGVjdGlvbigpKSByZXR1cm4gQ2VsbFNlbGVjdGlvbi5yb3dTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG5cdFx0XHRlbHNlIGlmICh0YWJsZUNoYW5nZWQgJiYgdGhpcy5pc0NvbFNlbGVjdGlvbigpKSByZXR1cm4gQ2VsbFNlbGVjdGlvbi5jb2xTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG5cdFx0XHRlbHNlIHJldHVybiBuZXcgQ2VsbFNlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKTtcblx0XHR9XG5cdFx0cmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2VlbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKTtcblx0fVxuXHRjb250ZW50KCkge1xuXHRcdGNvbnN0IHRhYmxlID0gdGhpcy4kYW5jaG9yQ2VsbC5ub2RlKC0xKTtcblx0XHRjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuXHRcdGNvbnN0IHRhYmxlU3RhcnQgPSB0aGlzLiRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcblx0XHRjb25zdCByZWN0ID0gbWFwLnJlY3RCZXR3ZWVuKHRoaXMuJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCwgdGhpcy4kaGVhZENlbGwucG9zIC0gdGFibGVTdGFydCk7XG5cdFx0Y29uc3Qgc2VlbiA9IHt9O1xuXHRcdGNvbnN0IHJvd3MgPSBbXTtcblx0XHRmb3IgKGxldCByb3cgPSByZWN0LnRvcDsgcm93IDwgcmVjdC5ib3R0b207IHJvdysrKSB7XG5cdFx0XHRjb25zdCByb3dDb250ZW50ID0gW107XG5cdFx0XHRmb3IgKGxldCBpbmRleCA9IHJvdyAqIG1hcC53aWR0aCArIHJlY3QubGVmdCwgY29sID0gcmVjdC5sZWZ0OyBjb2wgPCByZWN0LnJpZ2h0OyBjb2wrKywgaW5kZXgrKykge1xuXHRcdFx0XHRjb25zdCBwb3MgPSBtYXAubWFwW2luZGV4XTtcblx0XHRcdFx0aWYgKHNlZW5bcG9zXSkgY29udGludWU7XG5cdFx0XHRcdHNlZW5bcG9zXSA9IHRydWU7XG5cdFx0XHRcdGNvbnN0IGNlbGxSZWN0ID0gbWFwLmZpbmRDZWxsKHBvcyk7XG5cdFx0XHRcdGxldCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG5cdFx0XHRcdGlmICghY2VsbCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIGNlbGwgd2l0aCBvZmZzZXQgJHtwb3N9IGZvdW5kYCk7XG5cdFx0XHRcdGNvbnN0IGV4dHJhTGVmdCA9IHJlY3QubGVmdCAtIGNlbGxSZWN0LmxlZnQ7XG5cdFx0XHRcdGNvbnN0IGV4dHJhUmlnaHQgPSBjZWxsUmVjdC5yaWdodCAtIHJlY3QucmlnaHQ7XG5cdFx0XHRcdGlmIChleHRyYUxlZnQgPiAwIHx8IGV4dHJhUmlnaHQgPiAwKSB7XG5cdFx0XHRcdFx0bGV0IGF0dHJzID0gY2VsbC5hdHRycztcblx0XHRcdFx0XHRpZiAoZXh0cmFMZWZ0ID4gMCkgYXR0cnMgPSByZW1vdmVDb2xTcGFuKGF0dHJzLCAwLCBleHRyYUxlZnQpO1xuXHRcdFx0XHRcdGlmIChleHRyYVJpZ2h0ID4gMCkgYXR0cnMgPSByZW1vdmVDb2xTcGFuKGF0dHJzLCBhdHRycy5jb2xzcGFuIC0gZXh0cmFSaWdodCwgZXh0cmFSaWdodCk7XG5cdFx0XHRcdFx0aWYgKGNlbGxSZWN0LmxlZnQgPCByZWN0LmxlZnQpIHtcblx0XHRcdFx0XHRcdGNlbGwgPSBjZWxsLnR5cGUuY3JlYXRlQW5kRmlsbChhdHRycyk7XG5cdFx0XHRcdFx0XHRpZiAoIWNlbGwpIHRocm93IG5ldyBSYW5nZUVycm9yKGBDb3VsZCBub3QgY3JlYXRlIGNlbGwgd2l0aCBhdHRycyAke0pTT04uc3RyaW5naWZ5KGF0dHJzKX1gKTtcblx0XHRcdFx0XHR9IGVsc2UgY2VsbCA9IGNlbGwudHlwZS5jcmVhdGUoYXR0cnMsIGNlbGwuY29udGVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNlbGxSZWN0LnRvcCA8IHJlY3QudG9wIHx8IGNlbGxSZWN0LmJvdHRvbSA+IHJlY3QuYm90dG9tKSB7XG5cdFx0XHRcdFx0Y29uc3QgYXR0cnMgPSB7XG5cdFx0XHRcdFx0XHQuLi5jZWxsLmF0dHJzLFxuXHRcdFx0XHRcdFx0cm93c3BhbjogTWF0aC5taW4oY2VsbFJlY3QuYm90dG9tLCByZWN0LmJvdHRvbSkgLSBNYXRoLm1heChjZWxsUmVjdC50b3AsIHJlY3QudG9wKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKGNlbGxSZWN0LnRvcCA8IHJlY3QudG9wKSBjZWxsID0gY2VsbC50eXBlLmNyZWF0ZUFuZEZpbGwoYXR0cnMpO1xuXHRcdFx0XHRcdGVsc2UgY2VsbCA9IGNlbGwudHlwZS5jcmVhdGUoYXR0cnMsIGNlbGwuY29udGVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cm93Q29udGVudC5wdXNoKGNlbGwpO1xuXHRcdFx0fVxuXHRcdFx0cm93cy5wdXNoKHRhYmxlLmNoaWxkKHJvdykuY29weShGcmFnbWVudC5mcm9tKHJvd0NvbnRlbnQpKSk7XG5cdFx0fVxuXHRcdGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pc0NvbFNlbGVjdGlvbigpICYmIHRoaXMuaXNSb3dTZWxlY3Rpb24oKSA/IHRhYmxlIDogcm93cztcblx0XHRyZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oZnJhZ21lbnQpLCAxLCAxKTtcblx0fVxuXHRyZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcblx0XHRjb25zdCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuXHRcdFx0dHIucmVwbGFjZShtYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCBtYXBwaW5nLm1hcCgkdG8ucG9zKSwgaSA/IFNsaWNlLmVtcHR5IDogY29udGVudCk7XG5cdFx0fVxuXHRcdGNvbnN0IHNlbCA9IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcCh0aGlzLnRvKSksIC0xKTtcblx0XHRpZiAoc2VsKSB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcblx0fVxuXHRyZXBsYWNlV2l0aCh0ciwgbm9kZSkge1xuXHRcdHRoaXMucmVwbGFjZSh0ciwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obm9kZSksIDAsIDApKTtcblx0fVxuXHRmb3JFYWNoQ2VsbChmKSB7XG5cdFx0Y29uc3QgdGFibGUgPSB0aGlzLiRhbmNob3JDZWxsLm5vZGUoLTEpO1xuXHRcdGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG5cdFx0Y29uc3QgdGFibGVTdGFydCA9IHRoaXMuJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuXHRcdGNvbnN0IGNlbGxzID0gbWFwLmNlbGxzSW5SZWN0KG1hcC5yZWN0QmV0d2Vlbih0aGlzLiRhbmNob3JDZWxsLnBvcyAtIHRhYmxlU3RhcnQsIHRoaXMuJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnQpKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSBmKHRhYmxlLm5vZGVBdChjZWxsc1tpXSksIHRhYmxlU3RhcnQgKyBjZWxsc1tpXSk7XG5cdH1cblx0aXNDb2xTZWxlY3Rpb24oKSB7XG5cdFx0Y29uc3QgYW5jaG9yVG9wID0gdGhpcy4kYW5jaG9yQ2VsbC5pbmRleCgtMSk7XG5cdFx0Y29uc3QgaGVhZFRvcCA9IHRoaXMuJGhlYWRDZWxsLmluZGV4KC0xKTtcblx0XHRpZiAoTWF0aC5taW4oYW5jaG9yVG9wLCBoZWFkVG9wKSA+IDApIHJldHVybiBmYWxzZTtcblx0XHRjb25zdCBhbmNob3JCb3R0b20gPSBhbmNob3JUb3AgKyB0aGlzLiRhbmNob3JDZWxsLm5vZGVBZnRlci5hdHRycy5yb3dzcGFuO1xuXHRcdGNvbnN0IGhlYWRCb3R0b20gPSBoZWFkVG9wICsgdGhpcy4kaGVhZENlbGwubm9kZUFmdGVyLmF0dHJzLnJvd3NwYW47XG5cdFx0cmV0dXJuIE1hdGgubWF4KGFuY2hvckJvdHRvbSwgaGVhZEJvdHRvbSkgPT0gdGhpcy4kaGVhZENlbGwubm9kZSgtMSkuY2hpbGRDb3VudDtcblx0fVxuXHRzdGF0aWMgY29sU2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwgPSAkYW5jaG9yQ2VsbCkge1xuXHRcdGNvbnN0IHRhYmxlID0gJGFuY2hvckNlbGwubm9kZSgtMSk7XG5cdFx0Y29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcblx0XHRjb25zdCB0YWJsZVN0YXJ0ID0gJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuXHRcdGNvbnN0IGFuY2hvclJlY3QgPSBtYXAuZmluZENlbGwoJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCk7XG5cdFx0Y29uc3QgaGVhZFJlY3QgPSBtYXAuZmluZENlbGwoJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuXHRcdGNvbnN0IGRvYyA9ICRhbmNob3JDZWxsLm5vZGUoMCk7XG5cdFx0aWYgKGFuY2hvclJlY3QudG9wIDw9IGhlYWRSZWN0LnRvcCkge1xuXHRcdFx0aWYgKGFuY2hvclJlY3QudG9wID4gMCkgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbWFwLm1hcFthbmNob3JSZWN0LmxlZnRdKTtcblx0XHRcdGlmIChoZWFkUmVjdC5ib3R0b20gPCBtYXAuaGVpZ2h0KSAkaGVhZENlbGwgPSBkb2MucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbWFwLm1hcFttYXAud2lkdGggKiAobWFwLmhlaWdodCAtIDEpICsgaGVhZFJlY3QucmlnaHQgLSAxXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChoZWFkUmVjdC50b3AgPiAwKSAkaGVhZENlbGwgPSBkb2MucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbWFwLm1hcFtoZWFkUmVjdC5sZWZ0XSk7XG5cdFx0XHRpZiAoYW5jaG9yUmVjdC5ib3R0b20gPCBtYXAuaGVpZ2h0KSAkYW5jaG9yQ2VsbCA9IGRvYy5yZXNvbHZlKHRhYmxlU3RhcnQgKyBtYXAubWFwW21hcC53aWR0aCAqIChtYXAuaGVpZ2h0IC0gMSkgKyBhbmNob3JSZWN0LnJpZ2h0IC0gMV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IENlbGxTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG5cdH1cblx0aXNSb3dTZWxlY3Rpb24oKSB7XG5cdFx0Y29uc3QgdGFibGUgPSB0aGlzLiRhbmNob3JDZWxsLm5vZGUoLTEpO1xuXHRcdGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG5cdFx0Y29uc3QgdGFibGVTdGFydCA9IHRoaXMuJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuXHRcdGNvbnN0IGFuY2hvckxlZnQgPSBtYXAuY29sQ291bnQodGhpcy4kYW5jaG9yQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcblx0XHRjb25zdCBoZWFkTGVmdCA9IG1hcC5jb2xDb3VudCh0aGlzLiRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcblx0XHRpZiAoTWF0aC5taW4oYW5jaG9yTGVmdCwgaGVhZExlZnQpID4gMCkgcmV0dXJuIGZhbHNlO1xuXHRcdGNvbnN0IGFuY2hvclJpZ2h0ID0gYW5jaG9yTGVmdCArIHRoaXMuJGFuY2hvckNlbGwubm9kZUFmdGVyLmF0dHJzLmNvbHNwYW47XG5cdFx0Y29uc3QgaGVhZFJpZ2h0ID0gaGVhZExlZnQgKyB0aGlzLiRoZWFkQ2VsbC5ub2RlQWZ0ZXIuYXR0cnMuY29sc3Bhbjtcblx0XHRyZXR1cm4gTWF0aC5tYXgoYW5jaG9yUmlnaHQsIGhlYWRSaWdodCkgPT0gbWFwLndpZHRoO1xuXHR9XG5cdGVxKG90aGVyKSB7XG5cdFx0cmV0dXJuIG90aGVyIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbiAmJiBvdGhlci4kYW5jaG9yQ2VsbC5wb3MgPT0gdGhpcy4kYW5jaG9yQ2VsbC5wb3MgJiYgb3RoZXIuJGhlYWRDZWxsLnBvcyA9PSB0aGlzLiRoZWFkQ2VsbC5wb3M7XG5cdH1cblx0c3RhdGljIHJvd1NlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsID0gJGFuY2hvckNlbGwpIHtcblx0XHRjb25zdCB0YWJsZSA9ICRhbmNob3JDZWxsLm5vZGUoLTEpO1xuXHRcdGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG5cdFx0Y29uc3QgdGFibGVTdGFydCA9ICRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcblx0XHRjb25zdCBhbmNob3JSZWN0ID0gbWFwLmZpbmRDZWxsKCRhbmNob3JDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuXHRcdGNvbnN0IGhlYWRSZWN0ID0gbWFwLmZpbmRDZWxsKCRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcblx0XHRjb25zdCBkb2MgPSAkYW5jaG9yQ2VsbC5ub2RlKDApO1xuXHRcdGlmIChhbmNob3JSZWN0LmxlZnQgPD0gaGVhZFJlY3QubGVmdCkge1xuXHRcdFx0aWYgKGFuY2hvclJlY3QubGVmdCA+IDApICRhbmNob3JDZWxsID0gZG9jLnJlc29sdmUodGFibGVTdGFydCArIG1hcC5tYXBbYW5jaG9yUmVjdC50b3AgKiBtYXAud2lkdGhdKTtcblx0XHRcdGlmIChoZWFkUmVjdC5yaWdodCA8IG1hcC53aWR0aCkgJGhlYWRDZWxsID0gZG9jLnJlc29sdmUodGFibGVTdGFydCArIG1hcC5tYXBbbWFwLndpZHRoICogKGhlYWRSZWN0LnRvcCArIDEpIC0gMV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoaGVhZFJlY3QubGVmdCA+IDApICRoZWFkQ2VsbCA9IGRvYy5yZXNvbHZlKHRhYmxlU3RhcnQgKyBtYXAubWFwW2hlYWRSZWN0LnRvcCAqIG1hcC53aWR0aF0pO1xuXHRcdFx0aWYgKGFuY2hvclJlY3QucmlnaHQgPCBtYXAud2lkdGgpICRhbmNob3JDZWxsID0gZG9jLnJlc29sdmUodGFibGVTdGFydCArIG1hcC5tYXBbbWFwLndpZHRoICogKGFuY2hvclJlY3QudG9wICsgMSkgLSAxXSk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgQ2VsbFNlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKTtcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiY2VsbFwiLFxuXHRcdFx0YW5jaG9yOiB0aGlzLiRhbmNob3JDZWxsLnBvcyxcblx0XHRcdGhlYWQ6IHRoaXMuJGhlYWRDZWxsLnBvc1xuXHRcdH07XG5cdH1cblx0c3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuXHRcdHJldHVybiBuZXcgQ2VsbFNlbGVjdGlvbihkb2MucmVzb2x2ZShqc29uLmFuY2hvciksIGRvYy5yZXNvbHZlKGpzb24uaGVhZCkpO1xuXHR9XG5cdHN0YXRpYyBjcmVhdGUoZG9jLCBhbmNob3JDZWxsLCBoZWFkQ2VsbCA9IGFuY2hvckNlbGwpIHtcblx0XHRyZXR1cm4gbmV3IENlbGxTZWxlY3Rpb24oZG9jLnJlc29sdmUoYW5jaG9yQ2VsbCksIGRvYy5yZXNvbHZlKGhlYWRDZWxsKSk7XG5cdH1cblx0Z2V0Qm9va21hcmsoKSB7XG5cdFx0cmV0dXJuIG5ldyBDZWxsQm9va21hcmsodGhpcy4kYW5jaG9yQ2VsbC5wb3MsIHRoaXMuJGhlYWRDZWxsLnBvcyk7XG5cdH1cbn07XG5DZWxsU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5TZWxlY3Rpb24uanNvbklEKFwiY2VsbFwiLCBDZWxsU2VsZWN0aW9uKTtcbi8qKlxuKiBAcHVibGljXG4qL1xudmFyIENlbGxCb29rbWFyayA9IGNsYXNzIENlbGxCb29rbWFyayB7XG5cdGNvbnN0cnVjdG9yKGFuY2hvciwgaGVhZCkge1xuXHRcdHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuXHRcdHRoaXMuaGVhZCA9IGhlYWQ7XG5cdH1cblx0bWFwKG1hcHBpbmcpIHtcblx0XHRyZXR1cm4gbmV3IENlbGxCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLmFuY2hvciksIG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuXHR9XG5cdHJlc29sdmUoZG9jKSB7XG5cdFx0Y29uc3QgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksICRoZWFkQ2VsbCA9IGRvYy5yZXNvbHZlKHRoaXMuaGVhZCk7XG5cdFx0aWYgKCRhbmNob3JDZWxsLnBhcmVudC50eXBlLnNwZWMudGFibGVSb2xlID09IFwicm93XCIgJiYgJGhlYWRDZWxsLnBhcmVudC50eXBlLnNwZWMudGFibGVSb2xlID09IFwicm93XCIgJiYgJGFuY2hvckNlbGwuaW5kZXgoKSA8ICRhbmNob3JDZWxsLnBhcmVudC5jaGlsZENvdW50ICYmICRoZWFkQ2VsbC5pbmRleCgpIDwgJGhlYWRDZWxsLnBhcmVudC5jaGlsZENvdW50ICYmIGluU2FtZVRhYmxlKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpKSByZXR1cm4gbmV3IENlbGxTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG5cdFx0ZWxzZSByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWRDZWxsLCAxKTtcblx0fVxufTtcbmZ1bmN0aW9uIGRyYXdDZWxsU2VsZWN0aW9uKHN0YXRlKSB7XG5cdGlmICghKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pKSByZXR1cm4gbnVsbDtcblx0Y29uc3QgY2VsbHMgPSBbXTtcblx0c3RhdGUuc2VsZWN0aW9uLmZvckVhY2hDZWxsKChub2RlLCBwb3MpID0+IHtcblx0XHRjZWxscy5wdXNoKERlY29yYXRpb24ubm9kZShwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHsgY2xhc3M6IFwic2VsZWN0ZWRDZWxsXCIgfSkpO1xuXHR9KTtcblx0cmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKHN0YXRlLmRvYywgY2VsbHMpO1xufVxuZnVuY3Rpb24gaXNDZWxsQm91bmRhcnlTZWxlY3Rpb24oeyAkZnJvbSwgJHRvIH0pIHtcblx0aWYgKCRmcm9tLnBvcyA9PSAkdG8ucG9zIHx8ICRmcm9tLnBvcyA8ICR0by5wb3MgLSA2KSByZXR1cm4gZmFsc2U7XG5cdGxldCBhZnRlckZyb20gPSAkZnJvbS5wb3M7XG5cdGxldCBiZWZvcmVUbyA9ICR0by5wb3M7XG5cdGxldCBkZXB0aCA9ICRmcm9tLmRlcHRoO1xuXHRmb3IgKDsgZGVwdGggPj0gMDsgZGVwdGgtLSwgYWZ0ZXJGcm9tKyspIGlmICgkZnJvbS5hZnRlcihkZXB0aCArIDEpIDwgJGZyb20uZW5kKGRlcHRoKSkgYnJlYWs7XG5cdGZvciAobGV0IGQgPSAkdG8uZGVwdGg7IGQgPj0gMDsgZC0tLCBiZWZvcmVUby0tKSBpZiAoJHRvLmJlZm9yZShkICsgMSkgPiAkdG8uc3RhcnQoZCkpIGJyZWFrO1xuXHRyZXR1cm4gYWZ0ZXJGcm9tID09IGJlZm9yZVRvICYmIC9yb3d8dGFibGUvLnRlc3QoJGZyb20ubm9kZShkZXB0aCkudHlwZS5zcGVjLnRhYmxlUm9sZSk7XG59XG5mdW5jdGlvbiBpc1RleHRTZWxlY3Rpb25BY3Jvc3NDZWxscyh7ICRmcm9tLCAkdG8gfSkge1xuXHRsZXQgZnJvbUNlbGxCb3VuZGFyeU5vZGU7XG5cdGxldCB0b0NlbGxCb3VuZGFyeU5vZGU7XG5cdGZvciAobGV0IGkgPSAkZnJvbS5kZXB0aDsgaSA+IDA7IGktLSkge1xuXHRcdGNvbnN0IG5vZGUgPSAkZnJvbS5ub2RlKGkpO1xuXHRcdGlmIChub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUgPT09IFwiY2VsbFwiIHx8IG5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSA9PT0gXCJoZWFkZXJfY2VsbFwiKSB7XG5cdFx0XHRmcm9tQ2VsbEJvdW5kYXJ5Tm9kZSA9IG5vZGU7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblx0Zm9yIChsZXQgaSA9ICR0by5kZXB0aDsgaSA+IDA7IGktLSkge1xuXHRcdGNvbnN0IG5vZGUgPSAkdG8ubm9kZShpKTtcblx0XHRpZiAobm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09PSBcImNlbGxcIiB8fCBub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUgPT09IFwiaGVhZGVyX2NlbGxcIikge1xuXHRcdFx0dG9DZWxsQm91bmRhcnlOb2RlID0gbm9kZTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZnJvbUNlbGxCb3VuZGFyeU5vZGUgIT09IHRvQ2VsbEJvdW5kYXJ5Tm9kZSAmJiAkdG8ucGFyZW50T2Zmc2V0ID09PSAwO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKHN0YXRlLCB0ciwgYWxsb3dUYWJsZU5vZGVTZWxlY3Rpb24pIHtcblx0Y29uc3Qgc2VsID0gKHRyIHx8IHN0YXRlKS5zZWxlY3Rpb247XG5cdGNvbnN0IGRvYyA9ICh0ciB8fCBzdGF0ZSkuZG9jO1xuXHRsZXQgbm9ybWFsaXplO1xuXHRsZXQgcm9sZTtcblx0aWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgKHJvbGUgPSBzZWwubm9kZS50eXBlLnNwZWMudGFibGVSb2xlKSkge1xuXHRcdGlmIChyb2xlID09IFwiY2VsbFwiIHx8IHJvbGUgPT0gXCJoZWFkZXJfY2VsbFwiKSBub3JtYWxpemUgPSBDZWxsU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHNlbC5mcm9tKTtcblx0XHRlbHNlIGlmIChyb2xlID09IFwicm93XCIpIHtcblx0XHRcdGNvbnN0ICRjZWxsID0gZG9jLnJlc29sdmUoc2VsLmZyb20gKyAxKTtcblx0XHRcdG5vcm1hbGl6ZSA9IENlbGxTZWxlY3Rpb24ucm93U2VsZWN0aW9uKCRjZWxsLCAkY2VsbCk7XG5cdFx0fSBlbHNlIGlmICghYWxsb3dUYWJsZU5vZGVTZWxlY3Rpb24pIHtcblx0XHRcdGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldChzZWwubm9kZSk7XG5cdFx0XHRjb25zdCBzdGFydCA9IHNlbC5mcm9tICsgMTtcblx0XHRcdGNvbnN0IGxhc3RDZWxsID0gc3RhcnQgKyBtYXAubWFwW21hcC53aWR0aCAqIG1hcC5oZWlnaHQgLSAxXTtcblx0XHRcdG5vcm1hbGl6ZSA9IENlbGxTZWxlY3Rpb24uY3JlYXRlKGRvYywgc3RhcnQgKyAxLCBsYXN0Q2VsbCk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgaXNDZWxsQm91bmRhcnlTZWxlY3Rpb24oc2VsKSkgbm9ybWFsaXplID0gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBzZWwuZnJvbSk7XG5cdGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgaXNUZXh0U2VsZWN0aW9uQWNyb3NzQ2VsbHMoc2VsKSkgbm9ybWFsaXplID0gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBzZWwuJGZyb20uc3RhcnQoKSwgc2VsLiRmcm9tLmVuZCgpKTtcblx0aWYgKG5vcm1hbGl6ZSkgKHRyIHx8ICh0ciA9IHN0YXRlLnRyKSkuc2V0U2VsZWN0aW9uKG5vcm1hbGl6ZSk7XG5cdHJldHVybiB0cjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2ZpeHRhYmxlcy50c1xuLyoqXG4qIEBwdWJsaWNcbiovXG5jb25zdCBmaXhUYWJsZXNLZXkgPSBuZXcgUGx1Z2luS2V5KFwiZml4LXRhYmxlc1wiKTtcbi8qKlxuKiBIZWxwZXIgZm9yIGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBub2RlcyBpbiBhIGRvY3VtZW50IHRoYXQgY2hhbmdlZFxuKiBjb21wYXJlZCB0byB0aGUgZ2l2ZW4gcHJldmlvdXMgZG9jdW1lbnQuIFVzZWZ1bCBmb3IgYXZvaWRpbmdcbiogZHVwbGljYXRlIHdvcmsgb24gZWFjaCB0cmFuc2FjdGlvbi5cbipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIGNoYW5nZWREZXNjZW5kYW50cyhvbGQsIGN1ciwgb2Zmc2V0LCBmKSB7XG5cdGNvbnN0IG9sZFNpemUgPSBvbGQuY2hpbGRDb3VudCwgY3VyU2l6ZSA9IGN1ci5jaGlsZENvdW50O1xuXHRvdXRlcjogZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgY3VyU2l6ZTsgaSsrKSB7XG5cdFx0Y29uc3QgY2hpbGQgPSBjdXIuY2hpbGQoaSk7XG5cdFx0Zm9yIChsZXQgc2NhbiA9IGosIGUgPSBNYXRoLm1pbihvbGRTaXplLCBpICsgMyk7IHNjYW4gPCBlOyBzY2FuKyspIGlmIChvbGQuY2hpbGQoc2NhbikgPT0gY2hpbGQpIHtcblx0XHRcdGogPSBzY2FuICsgMTtcblx0XHRcdG9mZnNldCArPSBjaGlsZC5ub2RlU2l6ZTtcblx0XHRcdGNvbnRpbnVlIG91dGVyO1xuXHRcdH1cblx0XHRmKGNoaWxkLCBvZmZzZXQpO1xuXHRcdGlmIChqIDwgb2xkU2l6ZSAmJiBvbGQuY2hpbGQoaikuc2FtZU1hcmt1cChjaGlsZCkpIGNoYW5nZWREZXNjZW5kYW50cyhvbGQuY2hpbGQoaiksIGNoaWxkLCBvZmZzZXQgKyAxLCBmKTtcblx0XHRlbHNlIGNoaWxkLm5vZGVzQmV0d2VlbigwLCBjaGlsZC5jb250ZW50LnNpemUsIGYsIG9mZnNldCArIDEpO1xuXHRcdG9mZnNldCArPSBjaGlsZC5ub2RlU2l6ZTtcblx0fVxufVxuLyoqXG4qIEluc3BlY3QgYWxsIHRhYmxlcyBpbiB0aGUgZ2l2ZW4gc3RhdGUncyBkb2N1bWVudCBhbmQgcmV0dXJuIGFcbiogdHJhbnNhY3Rpb24gdGhhdCBmaXhlcyB0aGVtLCBpZiBuZWNlc3NhcnkuIElmIGBvbGRTdGF0ZWAgd2FzXG4qIHByb3ZpZGVkLCB0aGF0IGlzIGFzc3VtZWQgdG8gaG9sZCBhIHByZXZpb3VzLCBrbm93bi1nb29kIHN0YXRlLFxuKiB3aGljaCB3aWxsIGJlIHVzZWQgdG8gYXZvaWQgcmUtc2Nhbm5pbmcgdW5jaGFuZ2VkIHBhcnRzIG9mIHRoZVxuKiBkb2N1bWVudC5cbipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIGZpeFRhYmxlcyhzdGF0ZSwgb2xkU3RhdGUpIHtcblx0bGV0IHRyO1xuXHRjb25zdCBjaGVjayA9IChub2RlLCBwb3MpID0+IHtcblx0XHRpZiAobm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09IFwidGFibGVcIikgdHIgPSBmaXhUYWJsZShzdGF0ZSwgbm9kZSwgcG9zLCB0cik7XG5cdH07XG5cdGlmICghb2xkU3RhdGUpIHN0YXRlLmRvYy5kZXNjZW5kYW50cyhjaGVjayk7XG5cdGVsc2UgaWYgKG9sZFN0YXRlLmRvYyAhPSBzdGF0ZS5kb2MpIGNoYW5nZWREZXNjZW5kYW50cyhvbGRTdGF0ZS5kb2MsIHN0YXRlLmRvYywgMCwgY2hlY2spO1xuXHRyZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBmaXhUYWJsZShzdGF0ZSwgdGFibGUsIHRhYmxlUG9zLCB0cikge1xuXHRjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuXHRpZiAoIW1hcC5wcm9ibGVtcykgcmV0dXJuIHRyO1xuXHRpZiAoIXRyKSB0ciA9IHN0YXRlLnRyO1xuXHRjb25zdCBtdXN0QWRkID0gW107XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbWFwLmhlaWdodDsgaSsrKSBtdXN0QWRkLnB1c2goMCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbWFwLnByb2JsZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgcHJvYiA9IG1hcC5wcm9ibGVtc1tpXTtcblx0XHRpZiAocHJvYi50eXBlID09IFwiY29sbGlzaW9uXCIpIHtcblx0XHRcdGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocHJvYi5wb3MpO1xuXHRcdFx0aWYgKCFjZWxsKSBjb250aW51ZTtcblx0XHRcdGNvbnN0IGF0dHJzID0gY2VsbC5hdHRycztcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgYXR0cnMucm93c3BhbjsgaisrKSBtdXN0QWRkW3Byb2Iucm93ICsgal0gKz0gcHJvYi5uO1xuXHRcdFx0dHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCh0YWJsZVBvcyArIDEgKyBwcm9iLnBvcyksIG51bGwsIHJlbW92ZUNvbFNwYW4oYXR0cnMsIGF0dHJzLmNvbHNwYW4gLSBwcm9iLm4sIHByb2IubikpO1xuXHRcdH0gZWxzZSBpZiAocHJvYi50eXBlID09IFwibWlzc2luZ1wiKSBtdXN0QWRkW3Byb2Iucm93XSArPSBwcm9iLm47XG5cdFx0ZWxzZSBpZiAocHJvYi50eXBlID09IFwib3Zlcmxvbmdfcm93c3BhblwiKSB7XG5cdFx0XHRjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHByb2IucG9zKTtcblx0XHRcdGlmICghY2VsbCkgY29udGludWU7XG5cdFx0XHR0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKHRhYmxlUG9zICsgMSArIHByb2IucG9zKSwgbnVsbCwge1xuXHRcdFx0XHQuLi5jZWxsLmF0dHJzLFxuXHRcdFx0XHRyb3dzcGFuOiBjZWxsLmF0dHJzLnJvd3NwYW4gLSBwcm9iLm5cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAocHJvYi50eXBlID09IFwiY29sd2lkdGggbWlzbWF0Y2hcIikge1xuXHRcdFx0Y29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwcm9iLnBvcyk7XG5cdFx0XHRpZiAoIWNlbGwpIGNvbnRpbnVlO1xuXHRcdFx0dHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCh0YWJsZVBvcyArIDEgKyBwcm9iLnBvcyksIG51bGwsIHtcblx0XHRcdFx0Li4uY2VsbC5hdHRycyxcblx0XHRcdFx0Y29sd2lkdGg6IHByb2IuY29sd2lkdGhcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAocHJvYi50eXBlID09IFwiemVyb19zaXplZFwiKSB7XG5cdFx0XHRjb25zdCBwb3MgPSB0ci5tYXBwaW5nLm1hcCh0YWJsZVBvcyk7XG5cdFx0XHR0ci5kZWxldGUocG9zLCBwb3MgKyB0YWJsZS5ub2RlU2l6ZSk7XG5cdFx0fVxuXHR9XG5cdGxldCBmaXJzdCwgbGFzdDtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtdXN0QWRkLmxlbmd0aDsgaSsrKSBpZiAobXVzdEFkZFtpXSkge1xuXHRcdGlmIChmaXJzdCA9PSBudWxsKSBmaXJzdCA9IGk7XG5cdFx0bGFzdCA9IGk7XG5cdH1cblx0Zm9yIChsZXQgaSA9IDAsIHBvcyA9IHRhYmxlUG9zICsgMTsgaSA8IG1hcC5oZWlnaHQ7IGkrKykge1xuXHRcdGNvbnN0IHJvdyA9IHRhYmxlLmNoaWxkKGkpO1xuXHRcdGNvbnN0IGVuZCA9IHBvcyArIHJvdy5ub2RlU2l6ZTtcblx0XHRjb25zdCBhZGQgPSBtdXN0QWRkW2ldO1xuXHRcdGlmIChhZGQgPiAwKSB7XG5cdFx0XHRsZXQgcm9sZSA9IFwiY2VsbFwiO1xuXHRcdFx0aWYgKHJvdy5maXJzdENoaWxkKSByb2xlID0gcm93LmZpcnN0Q2hpbGQudHlwZS5zcGVjLnRhYmxlUm9sZTtcblx0XHRcdGNvbnN0IG5vZGVzID0gW107XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGFkZDsgaisrKSB7XG5cdFx0XHRcdGNvbnN0IG5vZGUgPSB0YWJsZU5vZGVUeXBlcyhzdGF0ZS5zY2hlbWEpW3JvbGVdLmNyZWF0ZUFuZEZpbGwoKTtcblx0XHRcdFx0aWYgKG5vZGUpIG5vZGVzLnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBzaWRlID0gKGkgPT0gMCB8fCBmaXJzdCA9PSBpIC0gMSkgJiYgbGFzdCA9PSBpID8gcG9zICsgMSA6IGVuZCAtIDE7XG5cdFx0XHR0ci5pbnNlcnQodHIubWFwcGluZy5tYXAoc2lkZSksIG5vZGVzKTtcblx0XHR9XG5cdFx0cG9zID0gZW5kO1xuXHR9XG5cdHJldHVybiB0ci5zZXRNZXRhKGZpeFRhYmxlc0tleSwgeyBmaXhUYWJsZXM6IHRydWUgfSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91dGlscy9jb252ZXJ0LnRzXG4vKipcbiogVGhpcyBmdW5jdGlvbiB3aWxsIHRyYW5zZm9ybSB0aGUgdGFibGUgbm9kZSBpbnRvIGEgbWF0cml4IG9mIHJvd3MgYW5kIGNvbHVtbnNcbiogcmVzcGVjdGluZyBtZXJnZWQgY2VsbHMsIGZvciBleGFtcGxlIHRoaXMgdGFibGU6XG4qXG4qIGBgYFxuKiDilIzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiog4pSCICBBMSAg4pSCICBCMSAg4pSCICAgICBDMSAgICAgIOKUglxuKiDilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilKRcbiog4pSCICBBMiAg4pSCICAgICBCMiAgICAgIOKUgiAgICAgIOKUglxuKiDilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKQgIEQxICDilIJcbiog4pSCICBBMyAg4pSCICBCMyAg4pSCICBDMyAg4pSCICAgICAg4pSCXG4qIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuKiBgYGBcbipcbiogd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdGhlIGJlbG93OlxuKlxuKiBgYGBqYXZhc2NyaXB0XG4qIFtcbiogICBbQTEsIEIxLCBDMSwgbnVsbF0sXG4qICAgW0EyLCBCMiwgbnVsbCwgRDFdLFxuKiAgIFtBMywgQjMsIEMzLCBudWxsXSxcbiogXVxuKiBgYGBcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gY29udmVydFRhYmxlTm9kZVRvQXJyYXlPZlJvd3ModGFibGVOb2RlKSB7XG5cdGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZU5vZGUpO1xuXHRjb25zdCByb3dzID0gW107XG5cdGNvbnN0IHJvd0NvdW50ID0gbWFwLmhlaWdodDtcblx0Y29uc3QgY29sQ291bnQkMSA9IG1hcC53aWR0aDtcblx0Zm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHJvd0NvdW50OyByb3dJbmRleCsrKSB7XG5cdFx0Y29uc3Qgcm93ID0gW107XG5cdFx0Zm9yIChsZXQgY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IGNvbENvdW50JDE7IGNvbEluZGV4KyspIHtcblx0XHRcdGNvbnN0IGNlbGxJbmRleCA9IHJvd0luZGV4ICogY29sQ291bnQkMSArIGNvbEluZGV4O1xuXHRcdFx0Y29uc3QgY2VsbFBvcyA9IG1hcC5tYXBbY2VsbEluZGV4XTtcblx0XHRcdGlmIChyb3dJbmRleCA+IDApIHtcblx0XHRcdFx0Y29uc3QgdG9wQ2VsbEluZGV4ID0gY2VsbEluZGV4IC0gY29sQ291bnQkMTtcblx0XHRcdFx0aWYgKGNlbGxQb3MgPT09IG1hcC5tYXBbdG9wQ2VsbEluZGV4XSkge1xuXHRcdFx0XHRcdHJvdy5wdXNoKG51bGwpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29sSW5kZXggPiAwKSB7XG5cdFx0XHRcdGNvbnN0IGxlZnRDZWxsSW5kZXggPSBjZWxsSW5kZXggLSAxO1xuXHRcdFx0XHRpZiAoY2VsbFBvcyA9PT0gbWFwLm1hcFtsZWZ0Q2VsbEluZGV4XSkge1xuXHRcdFx0XHRcdHJvdy5wdXNoKG51bGwpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyb3cucHVzaCh0YWJsZU5vZGUubm9kZUF0KGNlbGxQb3MpKTtcblx0XHR9XG5cdFx0cm93cy5wdXNoKHJvdyk7XG5cdH1cblx0cmV0dXJuIHJvd3M7XG59XG4vKipcbiogQ29udmVydCBhbiBhcnJheSBvZiByb3dzIHRvIGEgdGFibGUgbm9kZS5cbipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gY29udmVydEFycmF5T2ZSb3dzVG9UYWJsZU5vZGUodGFibGVOb2RlLCBhcnJheU9mTm9kZXMpIHtcblx0Y29uc3QgbmV3Um93cyA9IFtdO1xuXHRjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGVOb2RlKTtcblx0Y29uc3Qgcm93Q291bnQgPSBtYXAuaGVpZ2h0O1xuXHRjb25zdCBjb2xDb3VudCQxID0gbWFwLndpZHRoO1xuXHRmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93Q291bnQ7IHJvd0luZGV4KyspIHtcblx0XHRjb25zdCBvbGRSb3cgPSB0YWJsZU5vZGUuY2hpbGQocm93SW5kZXgpO1xuXHRcdGNvbnN0IG5ld0NlbGxzID0gW107XG5cdFx0Zm9yIChsZXQgY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IGNvbENvdW50JDE7IGNvbEluZGV4KyspIHtcblx0XHRcdGNvbnN0IGNlbGwgPSBhcnJheU9mTm9kZXNbcm93SW5kZXhdW2NvbEluZGV4XTtcblx0XHRcdGlmICghY2VsbCkgY29udGludWU7XG5cdFx0XHRjb25zdCBjZWxsUG9zID0gbWFwLm1hcFtyb3dJbmRleCAqIG1hcC53aWR0aCArIGNvbEluZGV4XTtcblx0XHRcdGNvbnN0IG9sZENlbGwgPSB0YWJsZU5vZGUubm9kZUF0KGNlbGxQb3MpO1xuXHRcdFx0aWYgKCFvbGRDZWxsKSBjb250aW51ZTtcblx0XHRcdGNvbnN0IG5ld0NlbGwgPSBvbGRDZWxsLnR5cGUuY3JlYXRlQ2hlY2tlZChjZWxsLmF0dHJzLCBjZWxsLmNvbnRlbnQsIGNlbGwubWFya3MpO1xuXHRcdFx0bmV3Q2VsbHMucHVzaChuZXdDZWxsKTtcblx0XHR9XG5cdFx0Y29uc3QgbmV3Um93ID0gb2xkUm93LnR5cGUuY3JlYXRlQ2hlY2tlZChvbGRSb3cuYXR0cnMsIG5ld0NlbGxzLCBvbGRSb3cubWFya3MpO1xuXHRcdG5ld1Jvd3MucHVzaChuZXdSb3cpO1xuXHR9XG5cdHJldHVybiB0YWJsZU5vZGUudHlwZS5jcmVhdGVDaGVja2VkKHRhYmxlTm9kZS5hdHRycywgbmV3Um93cywgdGFibGVOb2RlLm1hcmtzKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3V0aWxzL21vdmUtcm93LWluLWFycmF5LW9mLXJvd3MudHNcbi8qKlxuKiBNb3ZlIGEgcm93IGluIGFuIGFycmF5IG9mIHJvd3MuXG4qXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIG1vdmVSb3dJbkFycmF5T2ZSb3dzKHJvd3MsIGluZGV4ZXNPcmlnaW4sIGluZGV4ZXNUYXJnZXQsIGRpcmVjdGlvbk92ZXJyaWRlKSB7XG5cdGNvbnN0IGRpcmVjdGlvbiA9IGluZGV4ZXNPcmlnaW5bMF0gPiBpbmRleGVzVGFyZ2V0WzBdID8gLTEgOiAxO1xuXHRjb25zdCByb3dzRXh0cmFjdGVkID0gcm93cy5zcGxpY2UoaW5kZXhlc09yaWdpblswXSwgaW5kZXhlc09yaWdpbi5sZW5ndGgpO1xuXHRjb25zdCBwb3NpdGlvbk9mZnNldCA9IHJvd3NFeHRyYWN0ZWQubGVuZ3RoICUgMiA9PT0gMCA/IDEgOiAwO1xuXHRsZXQgdGFyZ2V0O1xuXHRpZiAoZGlyZWN0aW9uT3ZlcnJpZGUgPT09IC0xICYmIGRpcmVjdGlvbiA9PT0gMSkgdGFyZ2V0ID0gaW5kZXhlc1RhcmdldFswXSAtIDE7XG5cdGVsc2UgaWYgKGRpcmVjdGlvbk92ZXJyaWRlID09PSAxICYmIGRpcmVjdGlvbiA9PT0gLTEpIHRhcmdldCA9IGluZGV4ZXNUYXJnZXRbaW5kZXhlc1RhcmdldC5sZW5ndGggLSAxXSAtIHBvc2l0aW9uT2Zmc2V0ICsgMTtcblx0ZWxzZSB0YXJnZXQgPSBkaXJlY3Rpb24gPT09IC0xID8gaW5kZXhlc1RhcmdldFswXSA6IGluZGV4ZXNUYXJnZXRbaW5kZXhlc1RhcmdldC5sZW5ndGggLSAxXSAtIHBvc2l0aW9uT2Zmc2V0O1xuXHRyb3dzLnNwbGljZSh0YXJnZXQsIDAsIC4uLnJvd3NFeHRyYWN0ZWQpO1xuXHRyZXR1cm4gcm93cztcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3V0aWxzL3F1ZXJ5LnRzXG4vKipcbiogQ2hlY2tzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBgQ2VsbFNlbGVjdGlvbmAgaW5zdGFuY2UuXG4qXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGlzQ2VsbFNlbGVjdGlvbih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uO1xufVxuLyoqXG4qIEZpbmQgdGhlIGNsb3Nlc3QgdGFibGUgbm9kZSBmb3IgYSBnaXZlbiBwb3NpdGlvbi5cbipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIGZpbmRUYWJsZSgkcG9zKSB7XG5cdHJldHVybiBmaW5kUGFyZW50Tm9kZSgobm9kZSkgPT4gbm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09PSBcInRhYmxlXCIsICRwb3MpO1xufVxuLyoqXG4qIFRyeSB0byBmaW5kIHRoZSBhbmNob3IgYW5kIGhlYWQgY2VsbCBpbiB0aGUgc2FtZSB0YWJsZSBieSB1c2luZyB0aGUgZ2l2ZW5cbiogYW5jaG9yIGFuZCBoZWFkIGFzIGhpdCBwb2ludHMsIG9yIGZhbGxiYWNrIHRvIHRoZSBzZWxlY3Rpb24ncyBhbmNob3IgYW5kXG4qIGhlYWQuXG4qXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBmaW5kQ2VsbFJhbmdlKHNlbGVjdGlvbiwgYW5jaG9ySGl0LCBoZWFkSGl0KSB7XG5cdHZhciBfcmVmLCBfcmVmMjtcblx0aWYgKGFuY2hvckhpdCA9PSBudWxsICYmIGhlYWRIaXQgPT0gbnVsbCAmJiBpc0NlbGxTZWxlY3Rpb24oc2VsZWN0aW9uKSkgcmV0dXJuIFtzZWxlY3Rpb24uJGFuY2hvckNlbGwsIHNlbGVjdGlvbi4kaGVhZENlbGxdO1xuXHRjb25zdCBhbmNob3IgPSAoX3JlZiA9IGFuY2hvckhpdCAhPT0gbnVsbCAmJiBhbmNob3JIaXQgIT09IHZvaWQgMCA/IGFuY2hvckhpdCA6IGhlYWRIaXQpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBzZWxlY3Rpb24uYW5jaG9yO1xuXHRjb25zdCBoZWFkID0gKF9yZWYyID0gaGVhZEhpdCAhPT0gbnVsbCAmJiBoZWFkSGl0ICE9PSB2b2lkIDAgPyBoZWFkSGl0IDogYW5jaG9ySGl0KSAhPT0gbnVsbCAmJiBfcmVmMiAhPT0gdm9pZCAwID8gX3JlZjIgOiBzZWxlY3Rpb24uaGVhZDtcblx0Y29uc3QgZG9jID0gc2VsZWN0aW9uLiRoZWFkLmRvYztcblx0Y29uc3QgJGFuY2hvckNlbGwgPSBmaW5kQ2VsbFBvcyhkb2MsIGFuY2hvcik7XG5cdGNvbnN0ICRoZWFkQ2VsbCA9IGZpbmRDZWxsUG9zKGRvYywgaGVhZCk7XG5cdGlmICgkYW5jaG9yQ2VsbCAmJiAkaGVhZENlbGwgJiYgaW5TYW1lVGFibGUoJGFuY2hvckNlbGwsICRoZWFkQ2VsbCkpIHJldHVybiBbJGFuY2hvckNlbGwsICRoZWFkQ2VsbF07XG5cdHJldHVybiBudWxsO1xufVxuLyoqXG4qIFRyeSB0byBmaW5kIGEgcmVzb2x2ZWQgcG9zIG9mIGEgY2VsbCBieSB1c2luZyB0aGUgZ2l2ZW4gcG9zIGFzIGEgaGl0IHBvaW50LlxuKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gZmluZENlbGxQb3MoZG9jLCBwb3MpIHtcblx0Y29uc3QgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG5cdHJldHVybiBjZWxsQXJvdW5kKCRwb3MpIHx8IGNlbGxOZWFyKCRwb3MpO1xufVxuLyoqXG4qIEZpbmQgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdGhhdCBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZS5cbipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZmluZFBhcmVudE5vZGUocHJlZGljYXRlLCAkcG9zKSB7XG5cdGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aDsgZGVwdGggPj0gMDsgZGVwdGggLT0gMSkge1xuXHRcdGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpO1xuXHRcdGlmIChwcmVkaWNhdGUobm9kZSkpIHJldHVybiB7XG5cdFx0XHRub2RlLFxuXHRcdFx0cG9zOiBkZXB0aCA9PT0gMCA/IDAgOiAkcG9zLmJlZm9yZShkZXB0aCksXG5cdFx0XHRzdGFydDogJHBvcy5zdGFydChkZXB0aCksXG5cdFx0XHRkZXB0aFxuXHRcdH07XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91dGlscy9nZXQtY2VsbHMudHNcbi8qKlxuKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNlbGxzIGluIGEgY29sdW1uIGF0IHRoZSBzcGVjaWZpZWQgY29sdW1uIGluZGV4LlxuKlxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBnZXRDZWxsc0luQ29sdW1uKGNvbHVtbkluZGV4LCBzZWxlY3Rpb24pIHtcblx0Y29uc3QgdGFibGUgPSBmaW5kVGFibGUoc2VsZWN0aW9uLiRmcm9tKTtcblx0aWYgKCF0YWJsZSkgcmV0dXJuO1xuXHRjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUubm9kZSk7XG5cdGlmIChjb2x1bW5JbmRleCA8IDAgfHwgY29sdW1uSW5kZXggPiBtYXAud2lkdGggLSAxKSByZXR1cm47XG5cdHJldHVybiBtYXAuY2VsbHNJblJlY3Qoe1xuXHRcdGxlZnQ6IGNvbHVtbkluZGV4LFxuXHRcdHJpZ2h0OiBjb2x1bW5JbmRleCArIDEsXG5cdFx0dG9wOiAwLFxuXHRcdGJvdHRvbTogbWFwLmhlaWdodFxuXHR9KS5tYXAoKG5vZGVQb3MpID0+IHtcblx0XHRjb25zdCBub2RlID0gdGFibGUubm9kZS5ub2RlQXQobm9kZVBvcyk7XG5cdFx0Y29uc3QgcG9zID0gbm9kZVBvcyArIHRhYmxlLnN0YXJ0O1xuXHRcdHJldHVybiB7XG5cdFx0XHRwb3MsXG5cdFx0XHRzdGFydDogcG9zICsgMSxcblx0XHRcdG5vZGUsXG5cdFx0XHRkZXB0aDogdGFibGUuZGVwdGggKyAyXG5cdFx0fTtcblx0fSk7XG59XG4vKipcbiogUmV0dXJucyBhbiBhcnJheSBvZiBjZWxscyBpbiBhIHJvdyBhdCB0aGUgc3BlY2lmaWVkIHJvdyBpbmRleC5cbipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZ2V0Q2VsbHNJblJvdyhyb3dJbmRleCwgc2VsZWN0aW9uKSB7XG5cdGNvbnN0IHRhYmxlID0gZmluZFRhYmxlKHNlbGVjdGlvbi4kZnJvbSk7XG5cdGlmICghdGFibGUpIHJldHVybjtcblx0Y29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlLm5vZGUpO1xuXHRpZiAocm93SW5kZXggPCAwIHx8IHJvd0luZGV4ID4gbWFwLmhlaWdodCAtIDEpIHJldHVybjtcblx0cmV0dXJuIG1hcC5jZWxsc0luUmVjdCh7XG5cdFx0bGVmdDogMCxcblx0XHRyaWdodDogbWFwLndpZHRoLFxuXHRcdHRvcDogcm93SW5kZXgsXG5cdFx0Ym90dG9tOiByb3dJbmRleCArIDFcblx0fSkubWFwKChub2RlUG9zKSA9PiB7XG5cdFx0Y29uc3Qgbm9kZSA9IHRhYmxlLm5vZGUubm9kZUF0KG5vZGVQb3MpO1xuXHRcdGNvbnN0IHBvcyA9IG5vZGVQb3MgKyB0YWJsZS5zdGFydDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cG9zLFxuXHRcdFx0c3RhcnQ6IHBvcyArIDEsXG5cdFx0XHRub2RlLFxuXHRcdFx0ZGVwdGg6IHRhYmxlLmRlcHRoICsgMlxuXHRcdH07XG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdXRpbHMvc2VsZWN0aW9uLXJhbmdlLnRzXG4vKipcbiogUmV0dXJucyBhIHJhbmdlIG9mIHJlY3Rhbmd1bGFyIHNlbGVjdGlvbiBzcGFubmluZyBhbGwgbWVyZ2VkIGNlbGxzIGFyb3VuZCBhXG4qIGNvbHVtbiBhdCBpbmRleCBgY29sdW1uSW5kZXhgLlxuKlxuKiBPcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBmcm9tIEF0bGFzc2lhbiAoQXBhY2hlIExpY2Vuc2UgMi4wKVxuKlxuKiBodHRwczovL2JpdGJ1Y2tldC5vcmcvYXRsYXNzaWFuL2F0bGFzc2lhbi1mcm9udGVuZC1taXJyb3Ivc3JjLzVmOTFjYjg3MWU4MjQ4YmMzYmFlNWRkYzMwYmI5ZmQ5MjAwZmFkYmIvZWRpdG9yL2VkaXRvci10YWJsZXMvc3JjL3V0aWxzL2dldC1zZWxlY3Rpb24tcmFuZ2UtaW4tY29sdW1uLnRzI2VkaXRvci9lZGl0b3ItdGFibGVzL3NyYy91dGlscy9nZXQtc2VsZWN0aW9uLXJhbmdlLWluLWNvbHVtbi50c1xuKlxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25SYW5nZUluQ29sdW1uKHRyLCBzdGFydENvbEluZGV4LCBlbmRDb2xJbmRleCA9IHN0YXJ0Q29sSW5kZXgpIHtcblx0bGV0IHN0YXJ0SW5kZXggPSBzdGFydENvbEluZGV4O1xuXHRsZXQgZW5kSW5kZXggPSBlbmRDb2xJbmRleDtcblx0Zm9yIChsZXQgaSA9IHN0YXJ0Q29sSW5kZXg7IGkgPj0gMDsgaS0tKSB7XG5cdFx0Y29uc3QgY2VsbHMgPSBnZXRDZWxsc0luQ29sdW1uKGksIHRyLnNlbGVjdGlvbik7XG5cdFx0aWYgKGNlbGxzKSBjZWxscy5mb3JFYWNoKChjZWxsKSA9PiB7XG5cdFx0XHRjb25zdCBtYXliZUVuZEluZGV4ID0gY2VsbC5ub2RlLmF0dHJzLmNvbHNwYW4gKyBpIC0gMTtcblx0XHRcdGlmIChtYXliZUVuZEluZGV4ID49IHN0YXJ0SW5kZXgpIHN0YXJ0SW5kZXggPSBpO1xuXHRcdFx0aWYgKG1heWJlRW5kSW5kZXggPiBlbmRJbmRleCkgZW5kSW5kZXggPSBtYXliZUVuZEluZGV4O1xuXHRcdH0pO1xuXHR9XG5cdGZvciAobGV0IGkgPSBzdGFydENvbEluZGV4OyBpIDw9IGVuZEluZGV4OyBpKyspIHtcblx0XHRjb25zdCBjZWxscyA9IGdldENlbGxzSW5Db2x1bW4oaSwgdHIuc2VsZWN0aW9uKTtcblx0XHRpZiAoY2VsbHMpIGNlbGxzLmZvckVhY2goKGNlbGwpID0+IHtcblx0XHRcdGNvbnN0IG1heWJlRW5kSW5kZXggPSBjZWxsLm5vZGUuYXR0cnMuY29sc3BhbiArIGkgLSAxO1xuXHRcdFx0aWYgKGNlbGwubm9kZS5hdHRycy5jb2xzcGFuID4gMSAmJiBtYXliZUVuZEluZGV4ID4gZW5kSW5kZXgpIGVuZEluZGV4ID0gbWF5YmVFbmRJbmRleDtcblx0XHR9KTtcblx0fVxuXHRjb25zdCBpbmRleGVzID0gW107XG5cdGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpKyspIHtcblx0XHRjb25zdCBtYXliZUNlbGxzID0gZ2V0Q2VsbHNJbkNvbHVtbihpLCB0ci5zZWxlY3Rpb24pO1xuXHRcdGlmIChtYXliZUNlbGxzICYmIG1heWJlQ2VsbHMubGVuZ3RoID4gMCkgaW5kZXhlcy5wdXNoKGkpO1xuXHR9XG5cdHN0YXJ0SW5kZXggPSBpbmRleGVzWzBdO1xuXHRlbmRJbmRleCA9IGluZGV4ZXNbaW5kZXhlcy5sZW5ndGggLSAxXTtcblx0Y29uc3QgZmlyc3RTZWxlY3RlZENvbHVtbkNlbGxzID0gZ2V0Q2VsbHNJbkNvbHVtbihzdGFydEluZGV4LCB0ci5zZWxlY3Rpb24pO1xuXHRjb25zdCBmaXJzdFJvd0NlbGxzID0gZ2V0Q2VsbHNJblJvdygwLCB0ci5zZWxlY3Rpb24pO1xuXHRpZiAoIWZpcnN0U2VsZWN0ZWRDb2x1bW5DZWxscyB8fCAhZmlyc3RSb3dDZWxscykgcmV0dXJuO1xuXHRjb25zdCAkYW5jaG9yID0gdHIuZG9jLnJlc29sdmUoZmlyc3RTZWxlY3RlZENvbHVtbkNlbGxzW2ZpcnN0U2VsZWN0ZWRDb2x1bW5DZWxscy5sZW5ndGggLSAxXS5wb3MpO1xuXHRsZXQgaGVhZENlbGw7XG5cdGZvciAobGV0IGkgPSBlbmRJbmRleDsgaSA+PSBzdGFydEluZGV4OyBpLS0pIHtcblx0XHRjb25zdCBjb2x1bW5DZWxscyA9IGdldENlbGxzSW5Db2x1bW4oaSwgdHIuc2VsZWN0aW9uKTtcblx0XHRpZiAoY29sdW1uQ2VsbHMgJiYgY29sdW1uQ2VsbHMubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yIChsZXQgaiA9IGZpcnN0Um93Q2VsbHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIGlmIChmaXJzdFJvd0NlbGxzW2pdLnBvcyA9PT0gY29sdW1uQ2VsbHNbMF0ucG9zKSB7XG5cdFx0XHRcdGhlYWRDZWxsID0gY29sdW1uQ2VsbHNbMF07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhlYWRDZWxsKSBicmVhaztcblx0XHR9XG5cdH1cblx0aWYgKCFoZWFkQ2VsbCkgcmV0dXJuO1xuXHRyZXR1cm4ge1xuXHRcdCRhbmNob3IsXG5cdFx0JGhlYWQ6IHRyLmRvYy5yZXNvbHZlKGhlYWRDZWxsLnBvcyksXG5cdFx0aW5kZXhlc1xuXHR9O1xufVxuLyoqXG4qIFJldHVybnMgYSByYW5nZSBvZiByZWN0YW5ndWxhciBzZWxlY3Rpb24gc3Bhbm5pbmcgYWxsIG1lcmdlZCBjZWxscyBhcm91bmQgYVxuKiByb3cgYXQgaW5kZXggYHJvd0luZGV4YC5cbipcbiogT3JpZ2luYWwgaW1wbGVtZW50YXRpb24gZnJvbSBBdGxhc3NpYW4gKEFwYWNoZSBMaWNlbnNlIDIuMClcbipcbiogaHR0cHM6Ly9iaXRidWNrZXQub3JnL2F0bGFzc2lhbi9hdGxhc3NpYW4tZnJvbnRlbmQtbWlycm9yL3NyYy81ZjkxY2I4NzFlODI0OGJjM2JhZTVkZGMzMGJiOWZkOTIwMGZhZGJiL2VkaXRvci9lZGl0b3ItdGFibGVzL3NyYy91dGlscy9nZXQtc2VsZWN0aW9uLXJhbmdlLWluLXJvdy50cyNlZGl0b3IvZWRpdG9yLXRhYmxlcy9zcmMvdXRpbHMvZ2V0LXNlbGVjdGlvbi1yYW5nZS1pbi1yb3cudHNcbipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmFuZ2VJblJvdyh0ciwgc3RhcnRSb3dJbmRleCwgZW5kUm93SW5kZXggPSBzdGFydFJvd0luZGV4KSB7XG5cdGxldCBzdGFydEluZGV4ID0gc3RhcnRSb3dJbmRleDtcblx0bGV0IGVuZEluZGV4ID0gZW5kUm93SW5kZXg7XG5cdGZvciAobGV0IGkgPSBzdGFydFJvd0luZGV4OyBpID49IDA7IGktLSkge1xuXHRcdGNvbnN0IGNlbGxzID0gZ2V0Q2VsbHNJblJvdyhpLCB0ci5zZWxlY3Rpb24pO1xuXHRcdGlmIChjZWxscykgY2VsbHMuZm9yRWFjaCgoY2VsbCkgPT4ge1xuXHRcdFx0Y29uc3QgbWF5YmVFbmRJbmRleCA9IGNlbGwubm9kZS5hdHRycy5yb3dzcGFuICsgaSAtIDE7XG5cdFx0XHRpZiAobWF5YmVFbmRJbmRleCA+PSBzdGFydEluZGV4KSBzdGFydEluZGV4ID0gaTtcblx0XHRcdGlmIChtYXliZUVuZEluZGV4ID4gZW5kSW5kZXgpIGVuZEluZGV4ID0gbWF5YmVFbmRJbmRleDtcblx0XHR9KTtcblx0fVxuXHRmb3IgKGxldCBpID0gc3RhcnRSb3dJbmRleDsgaSA8PSBlbmRJbmRleDsgaSsrKSB7XG5cdFx0Y29uc3QgY2VsbHMgPSBnZXRDZWxsc0luUm93KGksIHRyLnNlbGVjdGlvbik7XG5cdFx0aWYgKGNlbGxzKSBjZWxscy5mb3JFYWNoKChjZWxsKSA9PiB7XG5cdFx0XHRjb25zdCBtYXliZUVuZEluZGV4ID0gY2VsbC5ub2RlLmF0dHJzLnJvd3NwYW4gKyBpIC0gMTtcblx0XHRcdGlmIChjZWxsLm5vZGUuYXR0cnMucm93c3BhbiA+IDEgJiYgbWF5YmVFbmRJbmRleCA+IGVuZEluZGV4KSBlbmRJbmRleCA9IG1heWJlRW5kSW5kZXg7XG5cdFx0fSk7XG5cdH1cblx0Y29uc3QgaW5kZXhlcyA9IFtdO1xuXHRmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8PSBlbmRJbmRleDsgaSsrKSB7XG5cdFx0Y29uc3QgbWF5YmVDZWxscyA9IGdldENlbGxzSW5Sb3coaSwgdHIuc2VsZWN0aW9uKTtcblx0XHRpZiAobWF5YmVDZWxscyAmJiBtYXliZUNlbGxzLmxlbmd0aCA+IDApIGluZGV4ZXMucHVzaChpKTtcblx0fVxuXHRzdGFydEluZGV4ID0gaW5kZXhlc1swXTtcblx0ZW5kSW5kZXggPSBpbmRleGVzW2luZGV4ZXMubGVuZ3RoIC0gMV07XG5cdGNvbnN0IGZpcnN0U2VsZWN0ZWRSb3dDZWxscyA9IGdldENlbGxzSW5Sb3coc3RhcnRJbmRleCwgdHIuc2VsZWN0aW9uKTtcblx0Y29uc3QgZmlyc3RDb2x1bW5DZWxscyA9IGdldENlbGxzSW5Db2x1bW4oMCwgdHIuc2VsZWN0aW9uKTtcblx0aWYgKCFmaXJzdFNlbGVjdGVkUm93Q2VsbHMgfHwgIWZpcnN0Q29sdW1uQ2VsbHMpIHJldHVybjtcblx0Y29uc3QgJGFuY2hvciA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0U2VsZWN0ZWRSb3dDZWxsc1tmaXJzdFNlbGVjdGVkUm93Q2VsbHMubGVuZ3RoIC0gMV0ucG9zKTtcblx0bGV0IGhlYWRDZWxsO1xuXHRmb3IgKGxldCBpID0gZW5kSW5kZXg7IGkgPj0gc3RhcnRJbmRleDsgaS0tKSB7XG5cdFx0Y29uc3Qgcm93Q2VsbHMgPSBnZXRDZWxsc0luUm93KGksIHRyLnNlbGVjdGlvbik7XG5cdFx0aWYgKHJvd0NlbGxzICYmIHJvd0NlbGxzLmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAobGV0IGogPSBmaXJzdENvbHVtbkNlbGxzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSBpZiAoZmlyc3RDb2x1bW5DZWxsc1tqXS5wb3MgPT09IHJvd0NlbGxzWzBdLnBvcykge1xuXHRcdFx0XHRoZWFkQ2VsbCA9IHJvd0NlbGxzWzBdO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmIChoZWFkQ2VsbCkgYnJlYWs7XG5cdFx0fVxuXHR9XG5cdGlmICghaGVhZENlbGwpIHJldHVybjtcblx0cmV0dXJuIHtcblx0XHQkYW5jaG9yLFxuXHRcdCRoZWFkOiB0ci5kb2MucmVzb2x2ZShoZWFkQ2VsbC5wb3MpLFxuXHRcdGluZGV4ZXNcblx0fTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3V0aWxzL3RyYW5zcG9zZS50c1xuLyoqXG4qIFRyYW5zcG9zZXMgYSAyRCBhcnJheSBieSBmbGlwcGluZyBjb2x1bW5zIHRvIHJvd3MuXG4qXG4qIFRyYW5zcG9zaXRpb24gaXMgYSBmYW1pbGlhciBhbGdlYnJhIGNvbmNlcHQgd2hlcmUgdGhlIG1hdHJpeCBpcyBmbGlwcGVkXG4qIGFsb25nIGl0cyBkaWFnb25hbC4gRm9yIG1vcmUgZGV0YWlscywgc2VlOlxuKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmFuc3Bvc2VcbipcbiogQGV4YW1wbGVcbiogYGBgamF2YXNjcmlwdFxuKiBjb25zdCBhcnIgPSBbXG4qICAgWydhMScsICdhMicsICdhMyddLFxuKiAgIFsnYjEnLCAnYjInLCAnYjMnXSxcbiogICBbJ2MxJywgJ2MyJywgJ2MzJ10sXG4qICAgWydkMScsICdkMicsICdkMyddLFxuKiBdO1xuKlxuKiBjb25zdCByZXN1bHQgPSB0cmFuc3Bvc2UoYXJyKTtcbiogcmVzdWx0ID09PSBbXG4qICAgWydhMScsICdiMScsICdjMScsICdkMSddLFxuKiAgIFsnYTInLCAnYjInLCAnYzInLCAnZDInXSxcbiogICBbJ2EzJywgJ2IzJywgJ2MzJywgJ2QzJ10sXG4qIF1cbiogYGBgXG4qL1xuZnVuY3Rpb24gdHJhbnNwb3NlKGFycmF5KSB7XG5cdHJldHVybiBhcnJheVswXS5tYXAoKF8sIGkpID0+IHtcblx0XHRyZXR1cm4gYXJyYXkubWFwKChjb2x1bW4pID0+IGNvbHVtbltpXSk7XG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdXRpbHMvbW92ZS1jb2x1bW4udHNcbi8qKlxuKiBNb3ZlIGEgY29sdW1uIGZyb20gaW5kZXggYG9yaWdpbmAgdG8gaW5kZXggYHRhcmdldGAuXG4qXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIG1vdmVDb2x1bW4obW92ZUNvbFBhcmFtcykge1xuXHR2YXIgX2dldFNlbGVjdGlvblJhbmdlSW5DLCBfZ2V0U2VsZWN0aW9uUmFuZ2VJbkMyO1xuXHRjb25zdCB7IHRyLCBvcmlnaW5JbmRleCwgdGFyZ2V0SW5kZXgsIHNlbGVjdCwgcG9zIH0gPSBtb3ZlQ29sUGFyYW1zO1xuXHRjb25zdCB0YWJsZSA9IGZpbmRUYWJsZSh0ci5kb2MucmVzb2x2ZShwb3MpKTtcblx0aWYgKCF0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBpbmRleGVzT3JpZ2luQ29sdW1uID0gKF9nZXRTZWxlY3Rpb25SYW5nZUluQyA9IGdldFNlbGVjdGlvblJhbmdlSW5Db2x1bW4odHIsIG9yaWdpbkluZGV4KSkgPT09IG51bGwgfHwgX2dldFNlbGVjdGlvblJhbmdlSW5DID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0U2VsZWN0aW9uUmFuZ2VJbkMuaW5kZXhlcztcblx0Y29uc3QgaW5kZXhlc1RhcmdldENvbHVtbiA9IChfZ2V0U2VsZWN0aW9uUmFuZ2VJbkMyID0gZ2V0U2VsZWN0aW9uUmFuZ2VJbkNvbHVtbih0ciwgdGFyZ2V0SW5kZXgpKSA9PT0gbnVsbCB8fCBfZ2V0U2VsZWN0aW9uUmFuZ2VJbkMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0U2VsZWN0aW9uUmFuZ2VJbkMyLmluZGV4ZXM7XG5cdGlmICghaW5kZXhlc09yaWdpbkNvbHVtbiB8fCAhaW5kZXhlc1RhcmdldENvbHVtbikgcmV0dXJuIGZhbHNlO1xuXHRpZiAoaW5kZXhlc09yaWdpbkNvbHVtbi5pbmNsdWRlcyh0YXJnZXRJbmRleCkpIHJldHVybiBmYWxzZTtcblx0Y29uc3QgbmV3VGFibGUgPSBtb3ZlVGFibGVDb2x1bW4kMSh0YWJsZS5ub2RlLCBpbmRleGVzT3JpZ2luQ29sdW1uLCBpbmRleGVzVGFyZ2V0Q29sdW1uLCAwKTtcblx0dHIucmVwbGFjZVdpdGgodGFibGUucG9zLCB0YWJsZS5wb3MgKyB0YWJsZS5ub2RlLm5vZGVTaXplLCBuZXdUYWJsZSk7XG5cdGlmICghc2VsZWN0KSByZXR1cm4gdHJ1ZTtcblx0Y29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KG5ld1RhYmxlKTtcblx0Y29uc3Qgc3RhcnQgPSB0YWJsZS5zdGFydDtcblx0Y29uc3QgaW5kZXggPSB0YXJnZXRJbmRleDtcblx0Y29uc3QgbGFzdENlbGwgPSBtYXAucG9zaXRpb25BdChtYXAuaGVpZ2h0IC0gMSwgaW5kZXgsIG5ld1RhYmxlKTtcblx0Y29uc3QgJGxhc3RDZWxsID0gdHIuZG9jLnJlc29sdmUoc3RhcnQgKyBsYXN0Q2VsbCk7XG5cdGNvbnN0IGZpcnN0Q2VsbCA9IG1hcC5wb3NpdGlvbkF0KDAsIGluZGV4LCBuZXdUYWJsZSk7XG5cdGNvbnN0ICRmaXJzdENlbGwgPSB0ci5kb2MucmVzb2x2ZShzdGFydCArIGZpcnN0Q2VsbCk7XG5cdHRyLnNldFNlbGVjdGlvbihDZWxsU2VsZWN0aW9uLmNvbFNlbGVjdGlvbigkbGFzdENlbGwsICRmaXJzdENlbGwpKTtcblx0cmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtb3ZlVGFibGVDb2x1bW4kMSh0YWJsZSwgaW5kZXhlc09yaWdpbiwgaW5kZXhlc1RhcmdldCwgZGlyZWN0aW9uKSB7XG5cdGxldCByb3dzID0gdHJhbnNwb3NlKGNvbnZlcnRUYWJsZU5vZGVUb0FycmF5T2ZSb3dzKHRhYmxlKSk7XG5cdHJvd3MgPSBtb3ZlUm93SW5BcnJheU9mUm93cyhyb3dzLCBpbmRleGVzT3JpZ2luLCBpbmRleGVzVGFyZ2V0LCBkaXJlY3Rpb24pO1xuXHRyb3dzID0gdHJhbnNwb3NlKHJvd3MpO1xuXHRyZXR1cm4gY29udmVydEFycmF5T2ZSb3dzVG9UYWJsZU5vZGUodGFibGUsIHJvd3MpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdXRpbHMvbW92ZS1yb3cudHNcbi8qKlxuKiBNb3ZlIGEgcm93IGZyb20gaW5kZXggYG9yaWdpbmAgdG8gaW5kZXggYHRhcmdldGAuXG4qXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIG1vdmVSb3cobW92ZVJvd1BhcmFtcykge1xuXHR2YXIgX2dldFNlbGVjdGlvblJhbmdlSW5SLCBfZ2V0U2VsZWN0aW9uUmFuZ2VJblIyO1xuXHRjb25zdCB7IHRyLCBvcmlnaW5JbmRleCwgdGFyZ2V0SW5kZXgsIHNlbGVjdCwgcG9zIH0gPSBtb3ZlUm93UGFyYW1zO1xuXHRjb25zdCB0YWJsZSA9IGZpbmRUYWJsZSh0ci5kb2MucmVzb2x2ZShwb3MpKTtcblx0aWYgKCF0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBpbmRleGVzT3JpZ2luUm93ID0gKF9nZXRTZWxlY3Rpb25SYW5nZUluUiA9IGdldFNlbGVjdGlvblJhbmdlSW5Sb3codHIsIG9yaWdpbkluZGV4KSkgPT09IG51bGwgfHwgX2dldFNlbGVjdGlvblJhbmdlSW5SID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0U2VsZWN0aW9uUmFuZ2VJblIuaW5kZXhlcztcblx0Y29uc3QgaW5kZXhlc1RhcmdldFJvdyA9IChfZ2V0U2VsZWN0aW9uUmFuZ2VJblIyID0gZ2V0U2VsZWN0aW9uUmFuZ2VJblJvdyh0ciwgdGFyZ2V0SW5kZXgpKSA9PT0gbnVsbCB8fCBfZ2V0U2VsZWN0aW9uUmFuZ2VJblIyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0U2VsZWN0aW9uUmFuZ2VJblIyLmluZGV4ZXM7XG5cdGlmICghaW5kZXhlc09yaWdpblJvdyB8fCAhaW5kZXhlc1RhcmdldFJvdykgcmV0dXJuIGZhbHNlO1xuXHRpZiAoaW5kZXhlc09yaWdpblJvdy5pbmNsdWRlcyh0YXJnZXRJbmRleCkpIHJldHVybiBmYWxzZTtcblx0Y29uc3QgbmV3VGFibGUgPSBtb3ZlVGFibGVSb3ckMSh0YWJsZS5ub2RlLCBpbmRleGVzT3JpZ2luUm93LCBpbmRleGVzVGFyZ2V0Um93LCAwKTtcblx0dHIucmVwbGFjZVdpdGgodGFibGUucG9zLCB0YWJsZS5wb3MgKyB0YWJsZS5ub2RlLm5vZGVTaXplLCBuZXdUYWJsZSk7XG5cdGlmICghc2VsZWN0KSByZXR1cm4gdHJ1ZTtcblx0Y29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KG5ld1RhYmxlKTtcblx0Y29uc3Qgc3RhcnQgPSB0YWJsZS5zdGFydDtcblx0Y29uc3QgaW5kZXggPSB0YXJnZXRJbmRleDtcblx0Y29uc3QgbGFzdENlbGwgPSBtYXAucG9zaXRpb25BdChpbmRleCwgbWFwLndpZHRoIC0gMSwgbmV3VGFibGUpO1xuXHRjb25zdCAkbGFzdENlbGwgPSB0ci5kb2MucmVzb2x2ZShzdGFydCArIGxhc3RDZWxsKTtcblx0Y29uc3QgZmlyc3RDZWxsID0gbWFwLnBvc2l0aW9uQXQoaW5kZXgsIDAsIG5ld1RhYmxlKTtcblx0Y29uc3QgJGZpcnN0Q2VsbCA9IHRyLmRvYy5yZXNvbHZlKHN0YXJ0ICsgZmlyc3RDZWxsKTtcblx0dHIuc2V0U2VsZWN0aW9uKENlbGxTZWxlY3Rpb24ucm93U2VsZWN0aW9uKCRsYXN0Q2VsbCwgJGZpcnN0Q2VsbCkpO1xuXHRyZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1vdmVUYWJsZVJvdyQxKHRhYmxlLCBpbmRleGVzT3JpZ2luLCBpbmRleGVzVGFyZ2V0LCBkaXJlY3Rpb24pIHtcblx0bGV0IHJvd3MgPSBjb252ZXJ0VGFibGVOb2RlVG9BcnJheU9mUm93cyh0YWJsZSk7XG5cdHJvd3MgPSBtb3ZlUm93SW5BcnJheU9mUm93cyhyb3dzLCBpbmRleGVzT3JpZ2luLCBpbmRleGVzVGFyZ2V0LCBkaXJlY3Rpb24pO1xuXHRyZXR1cm4gY29udmVydEFycmF5T2ZSb3dzVG9UYWJsZU5vZGUodGFibGUsIHJvd3MpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvY29tbWFuZHMudHNcbi8qKlxuKiBIZWxwZXIgdG8gZ2V0IHRoZSBzZWxlY3RlZCByZWN0YW5nbGUgaW4gYSB0YWJsZSwgaWYgYW55LiBBZGRzIHRhYmxlXG4qIG1hcCwgdGFibGUgbm9kZSwgYW5kIHRhYmxlIHN0YXJ0IG9mZnNldCB0byB0aGUgb2JqZWN0IGZvclxuKiBjb252ZW5pZW5jZS5cbipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIHNlbGVjdGVkUmVjdChzdGF0ZSkge1xuXHRjb25zdCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG5cdGNvbnN0ICRwb3MgPSBzZWxlY3Rpb25DZWxsKHN0YXRlKTtcblx0Y29uc3QgdGFibGUgPSAkcG9zLm5vZGUoLTEpO1xuXHRjb25zdCB0YWJsZVN0YXJ0ID0gJHBvcy5zdGFydCgtMSk7XG5cdGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG5cdHJldHVybiB7XG5cdFx0Li4uc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbiA/IG1hcC5yZWN0QmV0d2VlbihzZWwuJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCwgc2VsLiRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KSA6IG1hcC5maW5kQ2VsbCgkcG9zLnBvcyAtIHRhYmxlU3RhcnQpLFxuXHRcdHRhYmxlU3RhcnQsXG5cdFx0bWFwLFxuXHRcdHRhYmxlXG5cdH07XG59XG4vKipcbiogQWRkIGEgY29sdW1uIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpbiBhIHRhYmxlLlxuKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gYWRkQ29sdW1uKHRyLCB7IG1hcCwgdGFibGVTdGFydCwgdGFibGUgfSwgY29sKSB7XG5cdGxldCByZWZDb2x1bW4gPSBjb2wgPiAwID8gLTEgOiAwO1xuXHRpZiAoY29sdW1uSXNIZWFkZXIobWFwLCB0YWJsZSwgY29sICsgcmVmQ29sdW1uKSkgcmVmQ29sdW1uID0gY29sID09IDAgfHwgY29sID09IG1hcC53aWR0aCA/IG51bGwgOiAwO1xuXHRmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyByb3crKykge1xuXHRcdGNvbnN0IGluZGV4ID0gcm93ICogbWFwLndpZHRoICsgY29sO1xuXHRcdGlmIChjb2wgPiAwICYmIGNvbCA8IG1hcC53aWR0aCAmJiBtYXAubWFwW2luZGV4IC0gMV0gPT0gbWFwLm1hcFtpbmRleF0pIHtcblx0XHRcdGNvbnN0IHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuXHRcdFx0Y29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwb3MpO1xuXHRcdFx0dHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCh0YWJsZVN0YXJ0ICsgcG9zKSwgbnVsbCwgYWRkQ29sU3BhbihjZWxsLmF0dHJzLCBjb2wgLSBtYXAuY29sQ291bnQocG9zKSkpO1xuXHRcdFx0cm93ICs9IGNlbGwuYXR0cnMucm93c3BhbiAtIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IHR5cGUgPSByZWZDb2x1bW4gPT0gbnVsbCA/IHRhYmxlTm9kZVR5cGVzKHRhYmxlLnR5cGUuc2NoZW1hKS5jZWxsIDogdGFibGUubm9kZUF0KG1hcC5tYXBbaW5kZXggKyByZWZDb2x1bW5dKS50eXBlO1xuXHRcdFx0Y29uc3QgcG9zID0gbWFwLnBvc2l0aW9uQXQocm93LCBjb2wsIHRhYmxlKTtcblx0XHRcdHRyLmluc2VydCh0ci5tYXBwaW5nLm1hcCh0YWJsZVN0YXJ0ICsgcG9zKSwgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdHI7XG59XG4vKipcbiogQ29tbWFuZCB0byBhZGQgYSBjb2x1bW4gYmVmb3JlIHRoZSBjb2x1bW4gd2l0aCB0aGUgc2VsZWN0aW9uLlxuKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gYWRkQ29sdW1uQmVmb3JlKHN0YXRlLCBkaXNwYXRjaCkge1xuXHRpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcblx0aWYgKGRpc3BhdGNoKSB7XG5cdFx0Y29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSk7XG5cdFx0ZGlzcGF0Y2goYWRkQ29sdW1uKHN0YXRlLnRyLCByZWN0LCByZWN0LmxlZnQpKTtcblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuKiBDb21tYW5kIHRvIGFkZCBhIGNvbHVtbiBhZnRlciB0aGUgY29sdW1uIHdpdGggdGhlIHNlbGVjdGlvbi5cbipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIGFkZENvbHVtbkFmdGVyKHN0YXRlLCBkaXNwYXRjaCkge1xuXHRpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcblx0aWYgKGRpc3BhdGNoKSB7XG5cdFx0Y29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSk7XG5cdFx0ZGlzcGF0Y2goYWRkQ29sdW1uKHN0YXRlLnRyLCByZWN0LCByZWN0LnJpZ2h0KSk7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG4vKipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIHJlbW92ZUNvbHVtbih0ciwgeyBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0IH0sIGNvbCkge1xuXHRjb25zdCBtYXBTdGFydCA9IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7XG5cdGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1hcC5oZWlnaHQ7KSB7XG5cdFx0Y29uc3QgaW5kZXggPSByb3cgKiBtYXAud2lkdGggKyBjb2w7XG5cdFx0Y29uc3QgcG9zID0gbWFwLm1hcFtpbmRleF07XG5cdFx0Y29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwb3MpO1xuXHRcdGNvbnN0IGF0dHJzID0gY2VsbC5hdHRycztcblx0XHRpZiAoY29sID4gMCAmJiBtYXAubWFwW2luZGV4IC0gMV0gPT0gcG9zIHx8IGNvbCA8IG1hcC53aWR0aCAtIDEgJiYgbWFwLm1hcFtpbmRleCArIDFdID09IHBvcykgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLnNsaWNlKG1hcFN0YXJ0KS5tYXAodGFibGVTdGFydCArIHBvcyksIG51bGwsIHJlbW92ZUNvbFNwYW4oYXR0cnMsIGNvbCAtIG1hcC5jb2xDb3VudChwb3MpKSk7XG5cdFx0ZWxzZSB7XG5cdFx0XHRjb25zdCBzdGFydCA9IHRyLm1hcHBpbmcuc2xpY2UobWFwU3RhcnQpLm1hcCh0YWJsZVN0YXJ0ICsgcG9zKTtcblx0XHRcdHRyLmRlbGV0ZShzdGFydCwgc3RhcnQgKyBjZWxsLm5vZGVTaXplKTtcblx0XHR9XG5cdFx0cm93ICs9IGF0dHJzLnJvd3NwYW47XG5cdH1cbn1cbi8qKlxuKiBDb21tYW5kIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgc2VsZWN0ZWQgY29sdW1ucyBmcm9tIGEgdGFibGUuXG4qXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBkZWxldGVDb2x1bW4oc3RhdGUsIGRpc3BhdGNoKSB7XG5cdGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoZGlzcGF0Y2gpIHtcblx0XHRjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKTtcblx0XHRjb25zdCB0ciA9IHN0YXRlLnRyO1xuXHRcdGlmIChyZWN0LmxlZnQgPT0gMCAmJiByZWN0LnJpZ2h0ID09IHJlY3QubWFwLndpZHRoKSByZXR1cm4gZmFsc2U7XG5cdFx0Zm9yIChsZXQgaSA9IHJlY3QucmlnaHQgLSAxOzsgaS0tKSB7XG5cdFx0XHRyZW1vdmVDb2x1bW4odHIsIHJlY3QsIGkpO1xuXHRcdFx0aWYgKGkgPT0gcmVjdC5sZWZ0KSBicmVhaztcblx0XHRcdGNvbnN0IHRhYmxlID0gcmVjdC50YWJsZVN0YXJ0ID8gdHIuZG9jLm5vZGVBdChyZWN0LnRhYmxlU3RhcnQgLSAxKSA6IHRyLmRvYztcblx0XHRcdGlmICghdGFibGUpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gdGFibGUgZm91bmRcIik7XG5cdFx0XHRyZWN0LnRhYmxlID0gdGFibGU7XG5cdFx0XHRyZWN0Lm1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG5cdFx0fVxuXHRcdGRpc3BhdGNoKHRyKTtcblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gcm93SXNIZWFkZXIobWFwLCB0YWJsZSwgcm93KSB7XG5cdHZhciBfdGFibGUkbm9kZUF0O1xuXHRjb25zdCBoZWFkZXJDZWxsID0gdGFibGVOb2RlVHlwZXModGFibGUudHlwZS5zY2hlbWEpLmhlYWRlcl9jZWxsO1xuXHRmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBtYXAud2lkdGg7IGNvbCsrKSBpZiAoKChfdGFibGUkbm9kZUF0ID0gdGFibGUubm9kZUF0KG1hcC5tYXBbY29sICsgcm93ICogbWFwLndpZHRoXSkpID09PSBudWxsIHx8IF90YWJsZSRub2RlQXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90YWJsZSRub2RlQXQudHlwZSkgIT0gaGVhZGVyQ2VsbCkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gYWRkUm93KHRyLCB7IG1hcCwgdGFibGVTdGFydCwgdGFibGUgfSwgcm93KSB7XG5cdGxldCByb3dQb3MgPSB0YWJsZVN0YXJ0O1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHJvdzsgaSsrKSByb3dQb3MgKz0gdGFibGUuY2hpbGQoaSkubm9kZVNpemU7XG5cdGNvbnN0IGNlbGxzID0gW107XG5cdGxldCByZWZSb3cgPSByb3cgPiAwID8gLTEgOiAwO1xuXHRpZiAocm93SXNIZWFkZXIobWFwLCB0YWJsZSwgcm93ICsgcmVmUm93KSkgcmVmUm93ID0gcm93ID09IDAgfHwgcm93ID09IG1hcC5oZWlnaHQgPyBudWxsIDogMDtcblx0Zm9yIChsZXQgY29sID0gMCwgaW5kZXggPSBtYXAud2lkdGggKiByb3c7IGNvbCA8IG1hcC53aWR0aDsgY29sKyssIGluZGV4KyspIGlmIChyb3cgPiAwICYmIHJvdyA8IG1hcC5oZWlnaHQgJiYgbWFwLm1hcFtpbmRleF0gPT0gbWFwLm1hcFtpbmRleCAtIG1hcC53aWR0aF0pIHtcblx0XHRjb25zdCBwb3MgPSBtYXAubWFwW2luZGV4XTtcblx0XHRjb25zdCBhdHRycyA9IHRhYmxlLm5vZGVBdChwb3MpLmF0dHJzO1xuXHRcdHRyLnNldE5vZGVNYXJrdXAodGFibGVTdGFydCArIHBvcywgbnVsbCwge1xuXHRcdFx0Li4uYXR0cnMsXG5cdFx0XHRyb3dzcGFuOiBhdHRycy5yb3dzcGFuICsgMVxuXHRcdH0pO1xuXHRcdGNvbCArPSBhdHRycy5jb2xzcGFuIC0gMTtcblx0fSBlbHNlIHtcblx0XHR2YXIgX3RhYmxlJG5vZGVBdDI7XG5cdFx0Y29uc3QgdHlwZSA9IHJlZlJvdyA9PSBudWxsID8gdGFibGVOb2RlVHlwZXModGFibGUudHlwZS5zY2hlbWEpLmNlbGwgOiAoX3RhYmxlJG5vZGVBdDIgPSB0YWJsZS5ub2RlQXQobWFwLm1hcFtpbmRleCArIHJlZlJvdyAqIG1hcC53aWR0aF0pKSA9PT0gbnVsbCB8fCBfdGFibGUkbm9kZUF0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RhYmxlJG5vZGVBdDIudHlwZTtcblx0XHRjb25zdCBub2RlID0gdHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlLmNyZWF0ZUFuZEZpbGwoKTtcblx0XHRpZiAobm9kZSkgY2VsbHMucHVzaChub2RlKTtcblx0fVxuXHR0ci5pbnNlcnQocm93UG9zLCB0YWJsZU5vZGVUeXBlcyh0YWJsZS50eXBlLnNjaGVtYSkucm93LmNyZWF0ZShudWxsLCBjZWxscykpO1xuXHRyZXR1cm4gdHI7XG59XG4vKipcbiogQWRkIGEgdGFibGUgcm93IGJlZm9yZSB0aGUgc2VsZWN0aW9uLlxuKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gYWRkUm93QmVmb3JlKHN0YXRlLCBkaXNwYXRjaCkge1xuXHRpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcblx0aWYgKGRpc3BhdGNoKSB7XG5cdFx0Y29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSk7XG5cdFx0ZGlzcGF0Y2goYWRkUm93KHN0YXRlLnRyLCByZWN0LCByZWN0LnRvcCkpO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuLyoqXG4qIEFkZCBhIHRhYmxlIHJvdyBhZnRlciB0aGUgc2VsZWN0aW9uLlxuKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gYWRkUm93QWZ0ZXIoc3RhdGUsIGRpc3BhdGNoKSB7XG5cdGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoZGlzcGF0Y2gpIHtcblx0XHRjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKTtcblx0XHRkaXNwYXRjaChhZGRSb3coc3RhdGUudHIsIHJlY3QsIHJlY3QuYm90dG9tKSk7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG4vKipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIHJlbW92ZVJvdyh0ciwgeyBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0IH0sIHJvdykge1xuXHRsZXQgcm93UG9zID0gMDtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCByb3c7IGkrKykgcm93UG9zICs9IHRhYmxlLmNoaWxkKGkpLm5vZGVTaXplO1xuXHRjb25zdCBuZXh0Um93ID0gcm93UG9zICsgdGFibGUuY2hpbGQocm93KS5ub2RlU2l6ZTtcblx0Y29uc3QgbWFwRnJvbSA9IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7XG5cdHRyLmRlbGV0ZShyb3dQb3MgKyB0YWJsZVN0YXJ0LCBuZXh0Um93ICsgdGFibGVTdGFydCk7XG5cdGNvbnN0IHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuXHRmb3IgKGxldCBjb2wgPSAwLCBpbmRleCA9IHJvdyAqIG1hcC53aWR0aDsgY29sIDwgbWFwLndpZHRoOyBjb2wrKywgaW5kZXgrKykge1xuXHRcdGNvbnN0IHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuXHRcdGlmIChzZWVuLmhhcyhwb3MpKSBjb250aW51ZTtcblx0XHRzZWVuLmFkZChwb3MpO1xuXHRcdGlmIChyb3cgPiAwICYmIHBvcyA9PSBtYXAubWFwW2luZGV4IC0gbWFwLndpZHRoXSkge1xuXHRcdFx0Y29uc3QgYXR0cnMgPSB0YWJsZS5ub2RlQXQocG9zKS5hdHRycztcblx0XHRcdHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgdGFibGVTdGFydCksIG51bGwsIHtcblx0XHRcdFx0Li4uYXR0cnMsXG5cdFx0XHRcdHJvd3NwYW46IGF0dHJzLnJvd3NwYW4gLSAxXG5cdFx0XHR9KTtcblx0XHRcdGNvbCArPSBhdHRycy5jb2xzcGFuIC0gMTtcblx0XHR9IGVsc2UgaWYgKHJvdyA8IG1hcC5oZWlnaHQgJiYgcG9zID09IG1hcC5tYXBbaW5kZXggKyBtYXAud2lkdGhdKSB7XG5cdFx0XHRjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG5cdFx0XHRjb25zdCBhdHRycyA9IGNlbGwuYXR0cnM7XG5cdFx0XHRjb25zdCBjb3B5ID0gY2VsbC50eXBlLmNyZWF0ZSh7XG5cdFx0XHRcdC4uLmF0dHJzLFxuXHRcdFx0XHRyb3dzcGFuOiBjZWxsLmF0dHJzLnJvd3NwYW4gLSAxXG5cdFx0XHR9LCBjZWxsLmNvbnRlbnQpO1xuXHRcdFx0Y29uc3QgbmV3UG9zID0gbWFwLnBvc2l0aW9uQXQocm93ICsgMSwgY29sLCB0YWJsZSk7XG5cdFx0XHR0ci5pbnNlcnQodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAodGFibGVTdGFydCArIG5ld1BvcyksIGNvcHkpO1xuXHRcdFx0Y29sICs9IGF0dHJzLmNvbHNwYW4gLSAxO1xuXHRcdH1cblx0fVxufVxuLyoqXG4qIFJlbW92ZSB0aGUgc2VsZWN0ZWQgcm93cyBmcm9tIGEgdGFibGUuXG4qXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBkZWxldGVSb3coc3RhdGUsIGRpc3BhdGNoKSB7XG5cdGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoZGlzcGF0Y2gpIHtcblx0XHRjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKSwgdHIgPSBzdGF0ZS50cjtcblx0XHRpZiAocmVjdC50b3AgPT0gMCAmJiByZWN0LmJvdHRvbSA9PSByZWN0Lm1hcC5oZWlnaHQpIHJldHVybiBmYWxzZTtcblx0XHRmb3IgKGxldCBpID0gcmVjdC5ib3R0b20gLSAxOzsgaS0tKSB7XG5cdFx0XHRyZW1vdmVSb3codHIsIHJlY3QsIGkpO1xuXHRcdFx0aWYgKGkgPT0gcmVjdC50b3ApIGJyZWFrO1xuXHRcdFx0Y29uc3QgdGFibGUgPSByZWN0LnRhYmxlU3RhcnQgPyB0ci5kb2Mubm9kZUF0KHJlY3QudGFibGVTdGFydCAtIDEpIDogdHIuZG9jO1xuXHRcdFx0aWYgKCF0YWJsZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyB0YWJsZSBmb3VuZFwiKTtcblx0XHRcdHJlY3QudGFibGUgPSB0YWJsZTtcblx0XHRcdHJlY3QubWFwID0gVGFibGVNYXAuZ2V0KHJlY3QudGFibGUpO1xuXHRcdH1cblx0XHRkaXNwYXRjaCh0cik7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc0VtcHR5KGNlbGwpIHtcblx0Y29uc3QgYyA9IGNlbGwuY29udGVudDtcblx0cmV0dXJuIGMuY2hpbGRDb3VudCA9PSAxICYmIGMuY2hpbGQoMCkuaXNUZXh0YmxvY2sgJiYgYy5jaGlsZCgwKS5jaGlsZENvdW50ID09IDA7XG59XG5mdW5jdGlvbiBjZWxsc092ZXJsYXBSZWN0YW5nbGUoeyB3aWR0aCwgaGVpZ2h0LCBtYXAgfSwgcmVjdCkge1xuXHRsZXQgaW5kZXhUb3AgPSByZWN0LnRvcCAqIHdpZHRoICsgcmVjdC5sZWZ0LCBpbmRleExlZnQgPSBpbmRleFRvcDtcblx0bGV0IGluZGV4Qm90dG9tID0gKHJlY3QuYm90dG9tIC0gMSkgKiB3aWR0aCArIHJlY3QubGVmdCwgaW5kZXhSaWdodCA9IGluZGV4VG9wICsgKHJlY3QucmlnaHQgLSByZWN0LmxlZnQgLSAxKTtcblx0Zm9yIChsZXQgaSA9IHJlY3QudG9wOyBpIDwgcmVjdC5ib3R0b207IGkrKykge1xuXHRcdGlmIChyZWN0LmxlZnQgPiAwICYmIG1hcFtpbmRleExlZnRdID09IG1hcFtpbmRleExlZnQgLSAxXSB8fCByZWN0LnJpZ2h0IDwgd2lkdGggJiYgbWFwW2luZGV4UmlnaHRdID09IG1hcFtpbmRleFJpZ2h0ICsgMV0pIHJldHVybiB0cnVlO1xuXHRcdGluZGV4TGVmdCArPSB3aWR0aDtcblx0XHRpbmRleFJpZ2h0ICs9IHdpZHRoO1xuXHR9XG5cdGZvciAobGV0IGkgPSByZWN0LmxlZnQ7IGkgPCByZWN0LnJpZ2h0OyBpKyspIHtcblx0XHRpZiAocmVjdC50b3AgPiAwICYmIG1hcFtpbmRleFRvcF0gPT0gbWFwW2luZGV4VG9wIC0gd2lkdGhdIHx8IHJlY3QuYm90dG9tIDwgaGVpZ2h0ICYmIG1hcFtpbmRleEJvdHRvbV0gPT0gbWFwW2luZGV4Qm90dG9tICsgd2lkdGhdKSByZXR1cm4gdHJ1ZTtcblx0XHRpbmRleFRvcCsrO1xuXHRcdGluZGV4Qm90dG9tKys7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuLyoqXG4qIE1lcmdlIHRoZSBzZWxlY3RlZCBjZWxscyBpbnRvIGEgc2luZ2xlIGNlbGwuIE9ubHkgYXZhaWxhYmxlIHdoZW5cbiogdGhlIHNlbGVjdGVkIGNlbGxzJyBvdXRsaW5lIGZvcm1zIGEgcmVjdGFuZ2xlLlxuKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gbWVyZ2VDZWxscyhzdGF0ZSwgZGlzcGF0Y2gpIHtcblx0Y29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuXHRpZiAoIShzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSB8fCBzZWwuJGFuY2hvckNlbGwucG9zID09IHNlbC4kaGVhZENlbGwucG9zKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpLCB7IG1hcCB9ID0gcmVjdDtcblx0aWYgKGNlbGxzT3ZlcmxhcFJlY3RhbmdsZShtYXAsIHJlY3QpKSByZXR1cm4gZmFsc2U7XG5cdGlmIChkaXNwYXRjaCkge1xuXHRcdGNvbnN0IHRyID0gc3RhdGUudHI7XG5cdFx0Y29uc3Qgc2VlbiA9IHt9O1xuXHRcdGxldCBjb250ZW50ID0gRnJhZ21lbnQuZW1wdHk7XG5cdFx0bGV0IG1lcmdlZFBvcztcblx0XHRsZXQgbWVyZ2VkQ2VsbDtcblx0XHRmb3IgKGxldCByb3cgPSByZWN0LnRvcDsgcm93IDwgcmVjdC5ib3R0b207IHJvdysrKSBmb3IgKGxldCBjb2wgPSByZWN0LmxlZnQ7IGNvbCA8IHJlY3QucmlnaHQ7IGNvbCsrKSB7XG5cdFx0XHRjb25zdCBjZWxsUG9zID0gbWFwLm1hcFtyb3cgKiBtYXAud2lkdGggKyBjb2xdO1xuXHRcdFx0Y29uc3QgY2VsbCA9IHJlY3QudGFibGUubm9kZUF0KGNlbGxQb3MpO1xuXHRcdFx0aWYgKHNlZW5bY2VsbFBvc10gfHwgIWNlbGwpIGNvbnRpbnVlO1xuXHRcdFx0c2VlbltjZWxsUG9zXSA9IHRydWU7XG5cdFx0XHRpZiAobWVyZ2VkUG9zID09IG51bGwpIHtcblx0XHRcdFx0bWVyZ2VkUG9zID0gY2VsbFBvcztcblx0XHRcdFx0bWVyZ2VkQ2VsbCA9IGNlbGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIWlzRW1wdHkoY2VsbCkpIGNvbnRlbnQgPSBjb250ZW50LmFwcGVuZChjZWxsLmNvbnRlbnQpO1xuXHRcdFx0XHRjb25zdCBtYXBwZWQgPSB0ci5tYXBwaW5nLm1hcChjZWxsUG9zICsgcmVjdC50YWJsZVN0YXJ0KTtcblx0XHRcdFx0dHIuZGVsZXRlKG1hcHBlZCwgbWFwcGVkICsgY2VsbC5ub2RlU2l6ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtZXJnZWRQb3MgPT0gbnVsbCB8fCBtZXJnZWRDZWxsID09IG51bGwpIHJldHVybiB0cnVlO1xuXHRcdHRyLnNldE5vZGVNYXJrdXAobWVyZ2VkUG9zICsgcmVjdC50YWJsZVN0YXJ0LCBudWxsLCB7XG5cdFx0XHQuLi5hZGRDb2xTcGFuKG1lcmdlZENlbGwuYXR0cnMsIG1lcmdlZENlbGwuYXR0cnMuY29sc3BhbiwgcmVjdC5yaWdodCAtIHJlY3QubGVmdCAtIG1lcmdlZENlbGwuYXR0cnMuY29sc3BhbiksXG5cdFx0XHRyb3dzcGFuOiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG5cdFx0fSk7XG5cdFx0aWYgKGNvbnRlbnQuc2l6ZSA+IDApIHtcblx0XHRcdGNvbnN0IGVuZCA9IG1lcmdlZFBvcyArIDEgKyBtZXJnZWRDZWxsLmNvbnRlbnQuc2l6ZTtcblx0XHRcdGNvbnN0IHN0YXJ0ID0gaXNFbXB0eShtZXJnZWRDZWxsKSA/IG1lcmdlZFBvcyArIDEgOiBlbmQ7XG5cdFx0XHR0ci5yZXBsYWNlV2l0aChzdGFydCArIHJlY3QudGFibGVTdGFydCwgZW5kICsgcmVjdC50YWJsZVN0YXJ0LCBjb250ZW50KTtcblx0XHR9XG5cdFx0dHIuc2V0U2VsZWN0aW9uKG5ldyBDZWxsU2VsZWN0aW9uKHRyLmRvYy5yZXNvbHZlKG1lcmdlZFBvcyArIHJlY3QudGFibGVTdGFydCkpKTtcblx0XHRkaXNwYXRjaCh0cik7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG4vKipcbiogU3BsaXQgYSBzZWxlY3RlZCBjZWxsLCB3aG9zZSByb3dwYW4gb3IgY29sc3BhbiBpcyBncmVhdGVyIHRoYW4gb25lLFxuKiBpbnRvIHNtYWxsZXIgY2VsbHMuIFVzZSB0aGUgZmlyc3QgY2VsbCB0eXBlIGZvciB0aGUgbmV3IGNlbGxzLlxuKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gc3BsaXRDZWxsKHN0YXRlLCBkaXNwYXRjaCkge1xuXHRjb25zdCBub2RlVHlwZXMgPSB0YWJsZU5vZGVUeXBlcyhzdGF0ZS5zY2hlbWEpO1xuXHRyZXR1cm4gc3BsaXRDZWxsV2l0aFR5cGUoKHsgbm9kZSB9KSA9PiB7XG5cdFx0cmV0dXJuIG5vZGVUeXBlc1tub2RlLnR5cGUuc3BlYy50YWJsZVJvbGVdO1xuXHR9KShzdGF0ZSwgZGlzcGF0Y2gpO1xufVxuLyoqXG4qIFNwbGl0IGEgc2VsZWN0ZWQgY2VsbCwgd2hvc2Ugcm93cGFuIG9yIGNvbHNwYW4gaXMgZ3JlYXRlciB0aGFuIG9uZSxcbiogaW50byBzbWFsbGVyIGNlbGxzIHdpdGggdGhlIGNlbGwgdHlwZSAodGgsIHRkKSByZXR1cm5lZCBieSBnZXRUeXBlIGZ1bmN0aW9uLlxuKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gc3BsaXRDZWxsV2l0aFR5cGUoZ2V0Q2VsbFR5cGUpIHtcblx0cmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcblx0XHRjb25zdCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG5cdFx0bGV0IGNlbGxOb2RlO1xuXHRcdGxldCBjZWxsUG9zO1xuXHRcdGlmICghKHNlbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pKSB7XG5cdFx0XHR2YXIgX2NlbGxBcm91bmQ7XG5cdFx0XHRjZWxsTm9kZSA9IGNlbGxXcmFwcGluZyhzZWwuJGZyb20pO1xuXHRcdFx0aWYgKCFjZWxsTm9kZSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0Y2VsbFBvcyA9IChfY2VsbEFyb3VuZCA9IGNlbGxBcm91bmQoc2VsLiRmcm9tKSkgPT09IG51bGwgfHwgX2NlbGxBcm91bmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jZWxsQXJvdW5kLnBvcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHNlbC4kYW5jaG9yQ2VsbC5wb3MgIT0gc2VsLiRoZWFkQ2VsbC5wb3MpIHJldHVybiBmYWxzZTtcblx0XHRcdGNlbGxOb2RlID0gc2VsLiRhbmNob3JDZWxsLm5vZGVBZnRlcjtcblx0XHRcdGNlbGxQb3MgPSBzZWwuJGFuY2hvckNlbGwucG9zO1xuXHRcdH1cblx0XHRpZiAoY2VsbE5vZGUgPT0gbnVsbCB8fCBjZWxsUG9zID09IG51bGwpIHJldHVybiBmYWxzZTtcblx0XHRpZiAoY2VsbE5vZGUuYXR0cnMuY29sc3BhbiA9PSAxICYmIGNlbGxOb2RlLmF0dHJzLnJvd3NwYW4gPT0gMSkgcmV0dXJuIGZhbHNlO1xuXHRcdGlmIChkaXNwYXRjaCkge1xuXHRcdFx0bGV0IGJhc2VBdHRycyA9IGNlbGxOb2RlLmF0dHJzO1xuXHRcdFx0Y29uc3QgYXR0cnMgPSBbXTtcblx0XHRcdGNvbnN0IGNvbHdpZHRoID0gYmFzZUF0dHJzLmNvbHdpZHRoO1xuXHRcdFx0aWYgKGJhc2VBdHRycy5yb3dzcGFuID4gMSkgYmFzZUF0dHJzID0ge1xuXHRcdFx0XHQuLi5iYXNlQXR0cnMsXG5cdFx0XHRcdHJvd3NwYW46IDFcblx0XHRcdH07XG5cdFx0XHRpZiAoYmFzZUF0dHJzLmNvbHNwYW4gPiAxKSBiYXNlQXR0cnMgPSB7XG5cdFx0XHRcdC4uLmJhc2VBdHRycyxcblx0XHRcdFx0Y29sc3BhbjogMVxuXHRcdFx0fTtcblx0XHRcdGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpLCB0ciA9IHN0YXRlLnRyO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0OyBpKyspIGF0dHJzLnB1c2goY29sd2lkdGggPyB7XG5cdFx0XHRcdC4uLmJhc2VBdHRycyxcblx0XHRcdFx0Y29sd2lkdGg6IGNvbHdpZHRoICYmIGNvbHdpZHRoW2ldID8gW2NvbHdpZHRoW2ldXSA6IG51bGxcblx0XHRcdH0gOiBiYXNlQXR0cnMpO1xuXHRcdFx0bGV0IGxhc3RDZWxsO1xuXHRcdFx0Zm9yIChsZXQgcm93ID0gcmVjdC50b3A7IHJvdyA8IHJlY3QuYm90dG9tOyByb3crKykge1xuXHRcdFx0XHRsZXQgcG9zID0gcmVjdC5tYXAucG9zaXRpb25BdChyb3csIHJlY3QubGVmdCwgcmVjdC50YWJsZSk7XG5cdFx0XHRcdGlmIChyb3cgPT0gcmVjdC50b3ApIHBvcyArPSBjZWxsTm9kZS5ub2RlU2l6ZTtcblx0XHRcdFx0Zm9yIChsZXQgY29sID0gcmVjdC5sZWZ0LCBpID0gMDsgY29sIDwgcmVjdC5yaWdodDsgY29sKyssIGkrKykge1xuXHRcdFx0XHRcdGlmIChjb2wgPT0gcmVjdC5sZWZ0ICYmIHJvdyA9PSByZWN0LnRvcCkgY29udGludWU7XG5cdFx0XHRcdFx0dHIuaW5zZXJ0KGxhc3RDZWxsID0gdHIubWFwcGluZy5tYXAocG9zICsgcmVjdC50YWJsZVN0YXJ0LCAxKSwgZ2V0Q2VsbFR5cGUoe1xuXHRcdFx0XHRcdFx0bm9kZTogY2VsbE5vZGUsXG5cdFx0XHRcdFx0XHRyb3csXG5cdFx0XHRcdFx0XHRjb2xcblx0XHRcdFx0XHR9KS5jcmVhdGVBbmRGaWxsKGF0dHJzW2ldKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRyLnNldE5vZGVNYXJrdXAoY2VsbFBvcywgZ2V0Q2VsbFR5cGUoe1xuXHRcdFx0XHRub2RlOiBjZWxsTm9kZSxcblx0XHRcdFx0cm93OiByZWN0LnRvcCxcblx0XHRcdFx0Y29sOiByZWN0LmxlZnRcblx0XHRcdH0pLCBhdHRyc1swXSk7XG5cdFx0XHRpZiAoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikgdHIuc2V0U2VsZWN0aW9uKG5ldyBDZWxsU2VsZWN0aW9uKHRyLmRvYy5yZXNvbHZlKHNlbC4kYW5jaG9yQ2VsbC5wb3MpLCBsYXN0Q2VsbCA/IHRyLmRvYy5yZXNvbHZlKGxhc3RDZWxsKSA6IHZvaWQgMCkpO1xuXHRcdFx0ZGlzcGF0Y2godHIpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn1cbi8qKlxuKiBSZXR1cm5zIGEgY29tbWFuZCB0aGF0IHNldHMgdGhlIGdpdmVuIGF0dHJpYnV0ZSB0byB0aGUgZ2l2ZW4gdmFsdWUsXG4qIGFuZCBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2VsbCBkb2Vzbid0XG4qIGFscmVhZHkgaGF2ZSB0aGF0IGF0dHJpYnV0ZSBzZXQgdG8gdGhhdCB2YWx1ZS5cbipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIHNldENlbGxBdHRyKG5hbWUsIHZhbHVlKSB7XG5cdHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcblx0XHRpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcblx0XHRjb25zdCAkY2VsbCA9IHNlbGVjdGlvbkNlbGwoc3RhdGUpO1xuXHRcdGlmICgkY2VsbC5ub2RlQWZ0ZXIuYXR0cnNbbmFtZV0gPT09IHZhbHVlKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKGRpc3BhdGNoKSB7XG5cdFx0XHRjb25zdCB0ciA9IHN0YXRlLnRyO1xuXHRcdFx0aWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pIHN0YXRlLnNlbGVjdGlvbi5mb3JFYWNoQ2VsbCgobm9kZSwgcG9zKSA9PiB7XG5cdFx0XHRcdGlmIChub2RlLmF0dHJzW25hbWVdICE9PSB2YWx1ZSkgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIG51bGwsIHtcblx0XHRcdFx0XHQuLi5ub2RlLmF0dHJzLFxuXHRcdFx0XHRcdFtuYW1lXTogdmFsdWVcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdGVsc2UgdHIuc2V0Tm9kZU1hcmt1cCgkY2VsbC5wb3MsIG51bGwsIHtcblx0XHRcdFx0Li4uJGNlbGwubm9kZUFmdGVyLmF0dHJzLFxuXHRcdFx0XHRbbmFtZV06IHZhbHVlXG5cdFx0XHR9KTtcblx0XHRcdGRpc3BhdGNoKHRyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkX3RvZ2dsZUhlYWRlcih0eXBlKSB7XG5cdHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcblx0XHRpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcblx0XHRpZiAoZGlzcGF0Y2gpIHtcblx0XHRcdGNvbnN0IHR5cGVzID0gdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKTtcblx0XHRcdGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpLCB0ciA9IHN0YXRlLnRyO1xuXHRcdFx0Y29uc3QgY2VsbHMgPSByZWN0Lm1hcC5jZWxsc0luUmVjdCh0eXBlID09IFwiY29sdW1uXCIgPyB7XG5cdFx0XHRcdGxlZnQ6IHJlY3QubGVmdCxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRyaWdodDogcmVjdC5yaWdodCxcblx0XHRcdFx0Ym90dG9tOiByZWN0Lm1hcC5oZWlnaHRcblx0XHRcdH0gOiB0eXBlID09IFwicm93XCIgPyB7XG5cdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdHRvcDogcmVjdC50b3AsXG5cdFx0XHRcdHJpZ2h0OiByZWN0Lm1hcC53aWR0aCxcblx0XHRcdFx0Ym90dG9tOiByZWN0LmJvdHRvbVxuXHRcdFx0fSA6IHJlY3QpO1xuXHRcdFx0Y29uc3Qgbm9kZXMgPSBjZWxscy5tYXAoKHBvcykgPT4gcmVjdC50YWJsZS5ub2RlQXQocG9zKSk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSBpZiAobm9kZXNbaV0udHlwZSA9PSB0eXBlcy5oZWFkZXJfY2VsbCkgdHIuc2V0Tm9kZU1hcmt1cChyZWN0LnRhYmxlU3RhcnQgKyBjZWxsc1tpXSwgdHlwZXMuY2VsbCwgbm9kZXNbaV0uYXR0cnMpO1xuXHRcdFx0aWYgKHRyLnN0ZXBzLmxlbmd0aCA9PT0gMCkgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykgdHIuc2V0Tm9kZU1hcmt1cChyZWN0LnRhYmxlU3RhcnQgKyBjZWxsc1tpXSwgdHlwZXMuaGVhZGVyX2NlbGwsIG5vZGVzW2ldLmF0dHJzKTtcblx0XHRcdGRpc3BhdGNoKHRyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG59XG5mdW5jdGlvbiBpc0hlYWRlckVuYWJsZWRCeVR5cGUodHlwZSwgcmVjdCwgdHlwZXMpIHtcblx0Y29uc3QgY2VsbFBvc2l0aW9ucyA9IHJlY3QubWFwLmNlbGxzSW5SZWN0KHtcblx0XHRsZWZ0OiAwLFxuXHRcdHRvcDogMCxcblx0XHRyaWdodDogdHlwZSA9PSBcInJvd1wiID8gcmVjdC5tYXAud2lkdGggOiAxLFxuXHRcdGJvdHRvbTogdHlwZSA9PSBcImNvbHVtblwiID8gcmVjdC5tYXAuaGVpZ2h0IDogMVxuXHR9KTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsUG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgY2VsbCA9IHJlY3QudGFibGUubm9kZUF0KGNlbGxQb3NpdGlvbnNbaV0pO1xuXHRcdGlmIChjZWxsICYmIGNlbGwudHlwZSAhPT0gdHlwZXMuaGVhZGVyX2NlbGwpIHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuKiBUb2dnbGVzIGJldHdlZW4gcm93L2NvbHVtbiBoZWFkZXIgYW5kIG5vcm1hbCBjZWxscyAoT25seSBhcHBsaWVzIHRvIGZpcnN0IHJvdy9jb2x1bW4pLlxuKiBGb3IgZGVwcmVjYXRlZCBiZWhhdmlvciBwYXNzIGB1c2VEZXByZWNhdGVkTG9naWNgIGluIG9wdGlvbnMgd2l0aCB0cnVlLlxuKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gdG9nZ2xlSGVhZGVyKHR5cGUsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB1c2VEZXByZWNhdGVkTG9naWM6IGZhbHNlIH07XG5cdGlmIChvcHRpb25zLnVzZURlcHJlY2F0ZWRMb2dpYykgcmV0dXJuIGRlcHJlY2F0ZWRfdG9nZ2xlSGVhZGVyKHR5cGUpO1xuXHRyZXR1cm4gZnVuY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG5cdFx0aWYgKCFpc0luVGFibGUoc3RhdGUpKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKGRpc3BhdGNoKSB7XG5cdFx0XHRjb25zdCB0eXBlcyA9IHRhYmxlTm9kZVR5cGVzKHN0YXRlLnNjaGVtYSk7XG5cdFx0XHRjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKSwgdHIgPSBzdGF0ZS50cjtcblx0XHRcdGNvbnN0IGlzSGVhZGVyUm93RW5hYmxlZCA9IGlzSGVhZGVyRW5hYmxlZEJ5VHlwZShcInJvd1wiLCByZWN0LCB0eXBlcyk7XG5cdFx0XHRjb25zdCBpc0hlYWRlckNvbHVtbkVuYWJsZWQgPSBpc0hlYWRlckVuYWJsZWRCeVR5cGUoXCJjb2x1bW5cIiwgcmVjdCwgdHlwZXMpO1xuXHRcdFx0Y29uc3Qgc2VsZWN0aW9uU3RhcnRzQXQgPSAodHlwZSA9PT0gXCJjb2x1bW5cIiA/IGlzSGVhZGVyUm93RW5hYmxlZCA6IHR5cGUgPT09IFwicm93XCIgPyBpc0hlYWRlckNvbHVtbkVuYWJsZWQgOiBmYWxzZSkgPyAxIDogMDtcblx0XHRcdGNvbnN0IGNlbGxzUmVjdCA9IHR5cGUgPT0gXCJjb2x1bW5cIiA/IHtcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0dG9wOiBzZWxlY3Rpb25TdGFydHNBdCxcblx0XHRcdFx0cmlnaHQ6IDEsXG5cdFx0XHRcdGJvdHRvbTogcmVjdC5tYXAuaGVpZ2h0XG5cdFx0XHR9IDogdHlwZSA9PSBcInJvd1wiID8ge1xuXHRcdFx0XHRsZWZ0OiBzZWxlY3Rpb25TdGFydHNBdCxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRyaWdodDogcmVjdC5tYXAud2lkdGgsXG5cdFx0XHRcdGJvdHRvbTogMVxuXHRcdFx0fSA6IHJlY3Q7XG5cdFx0XHRjb25zdCBuZXdUeXBlID0gdHlwZSA9PSBcImNvbHVtblwiID8gaXNIZWFkZXJDb2x1bW5FbmFibGVkID8gdHlwZXMuY2VsbCA6IHR5cGVzLmhlYWRlcl9jZWxsIDogdHlwZSA9PSBcInJvd1wiID8gaXNIZWFkZXJSb3dFbmFibGVkID8gdHlwZXMuY2VsbCA6IHR5cGVzLmhlYWRlcl9jZWxsIDogdHlwZXMuY2VsbDtcblx0XHRcdHJlY3QubWFwLmNlbGxzSW5SZWN0KGNlbGxzUmVjdCkuZm9yRWFjaCgocmVsYXRpdmVDZWxsUG9zKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNlbGxQb3MgPSByZWxhdGl2ZUNlbGxQb3MgKyByZWN0LnRhYmxlU3RhcnQ7XG5cdFx0XHRcdGNvbnN0IGNlbGwgPSB0ci5kb2Mubm9kZUF0KGNlbGxQb3MpO1xuXHRcdFx0XHRpZiAoY2VsbCkgdHIuc2V0Tm9kZU1hcmt1cChjZWxsUG9zLCBuZXdUeXBlLCBjZWxsLmF0dHJzKTtcblx0XHRcdH0pO1xuXHRcdFx0ZGlzcGF0Y2godHIpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn1cbi8qKlxuKiBUb2dnbGVzIHdoZXRoZXIgdGhlIHNlbGVjdGVkIHJvdyBjb250YWlucyBoZWFkZXIgY2VsbHMuXG4qXG4qIEBwdWJsaWNcbiovXG5jb25zdCB0b2dnbGVIZWFkZXJSb3cgPSB0b2dnbGVIZWFkZXIoXCJyb3dcIiwgeyB1c2VEZXByZWNhdGVkTG9naWM6IHRydWUgfSk7XG4vKipcbiogVG9nZ2xlcyB3aGV0aGVyIHRoZSBzZWxlY3RlZCBjb2x1bW4gY29udGFpbnMgaGVhZGVyIGNlbGxzLlxuKlxuKiBAcHVibGljXG4qL1xuY29uc3QgdG9nZ2xlSGVhZGVyQ29sdW1uID0gdG9nZ2xlSGVhZGVyKFwiY29sdW1uXCIsIHsgdXNlRGVwcmVjYXRlZExvZ2ljOiB0cnVlIH0pO1xuLyoqXG4qIFRvZ2dsZXMgd2hldGhlciB0aGUgc2VsZWN0ZWQgY2VsbHMgYXJlIGhlYWRlciBjZWxscy5cbipcbiogQHB1YmxpY1xuKi9cbmNvbnN0IHRvZ2dsZUhlYWRlckNlbGwgPSB0b2dnbGVIZWFkZXIoXCJjZWxsXCIsIHsgdXNlRGVwcmVjYXRlZExvZ2ljOiB0cnVlIH0pO1xuZnVuY3Rpb24gZmluZE5leHRDZWxsKCRjZWxsLCBkaXIpIHtcblx0aWYgKGRpciA8IDApIHtcblx0XHRjb25zdCBiZWZvcmUgPSAkY2VsbC5ub2RlQmVmb3JlO1xuXHRcdGlmIChiZWZvcmUpIHJldHVybiAkY2VsbC5wb3MgLSBiZWZvcmUubm9kZVNpemU7XG5cdFx0Zm9yIChsZXQgcm93ID0gJGNlbGwuaW5kZXgoLTEpIC0gMSwgcm93RW5kID0gJGNlbGwuYmVmb3JlKCk7IHJvdyA+PSAwOyByb3ctLSkge1xuXHRcdFx0Y29uc3Qgcm93Tm9kZSA9ICRjZWxsLm5vZGUoLTEpLmNoaWxkKHJvdyk7XG5cdFx0XHRjb25zdCBsYXN0Q2hpbGQgPSByb3dOb2RlLmxhc3RDaGlsZDtcblx0XHRcdGlmIChsYXN0Q2hpbGQpIHJldHVybiByb3dFbmQgLSAxIC0gbGFzdENoaWxkLm5vZGVTaXplO1xuXHRcdFx0cm93RW5kIC09IHJvd05vZGUubm9kZVNpemU7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmICgkY2VsbC5pbmRleCgpIDwgJGNlbGwucGFyZW50LmNoaWxkQ291bnQgLSAxKSByZXR1cm4gJGNlbGwucG9zICsgJGNlbGwubm9kZUFmdGVyLm5vZGVTaXplO1xuXHRcdGNvbnN0IHRhYmxlID0gJGNlbGwubm9kZSgtMSk7XG5cdFx0Zm9yIChsZXQgcm93ID0gJGNlbGwuaW5kZXhBZnRlcigtMSksIHJvd1N0YXJ0ID0gJGNlbGwuYWZ0ZXIoKTsgcm93IDwgdGFibGUuY2hpbGRDb3VudDsgcm93KyspIHtcblx0XHRcdGNvbnN0IHJvd05vZGUgPSB0YWJsZS5jaGlsZChyb3cpO1xuXHRcdFx0aWYgKHJvd05vZGUuY2hpbGRDb3VudCkgcmV0dXJuIHJvd1N0YXJ0ICsgMTtcblx0XHRcdHJvd1N0YXJ0ICs9IHJvd05vZGUubm9kZVNpemU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufVxuLyoqXG4qIFJldHVybnMgYSBjb21tYW5kIGZvciBzZWxlY3RpbmcgdGhlIG5leHQgKGRpcmVjdGlvbj0xKSBvciBwcmV2aW91c1xuKiAoZGlyZWN0aW9uPS0xKSBjZWxsIGluIGEgdGFibGUuXG4qXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBnb1RvTmV4dENlbGwoZGlyZWN0aW9uKSB7XG5cdHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcblx0XHRpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcblx0XHRjb25zdCBjZWxsID0gZmluZE5leHRDZWxsKHNlbGVjdGlvbkNlbGwoc3RhdGUpLCBkaXJlY3Rpb24pO1xuXHRcdGlmIChjZWxsID09IG51bGwpIHJldHVybiBmYWxzZTtcblx0XHRpZiAoZGlzcGF0Y2gpIHtcblx0XHRcdGNvbnN0ICRjZWxsID0gc3RhdGUuZG9jLnJlc29sdmUoY2VsbCk7XG5cdFx0XHRkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKCRjZWxsLCBtb3ZlQ2VsbEZvcndhcmQoJGNlbGwpKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xufVxuLyoqXG4qIERlbGV0ZXMgdGhlIHRhYmxlIGFyb3VuZCB0aGUgc2VsZWN0aW9uLCBpZiBhbnkuXG4qXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBkZWxldGVUYWJsZShzdGF0ZSwgZGlzcGF0Y2gpIHtcblx0Y29uc3QgJHBvcyA9IHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yO1xuXHRmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+IDA7IGQtLSkgaWYgKCRwb3Mubm9kZShkKS50eXBlLnNwZWMudGFibGVSb2xlID09IFwidGFibGVcIikge1xuXHRcdGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRwb3MuYmVmb3JlKGQpLCAkcG9zLmFmdGVyKGQpKS5zY3JvbGxJbnRvVmlldygpKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG4vKipcbiogRGVsZXRlcyB0aGUgY29udGVudCBvZiB0aGUgc2VsZWN0ZWQgY2VsbHMsIGlmIHRoZXkgYXJlIG5vdCBlbXB0eS5cbipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIGRlbGV0ZUNlbGxTZWxlY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG5cdGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcblx0aWYgKCEoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikpIHJldHVybiBmYWxzZTtcblx0aWYgKGRpc3BhdGNoKSB7XG5cdFx0Y29uc3QgdHIgPSBzdGF0ZS50cjtcblx0XHRjb25zdCBiYXNlQ29udGVudCA9IHRhYmxlTm9kZVR5cGVzKHN0YXRlLnNjaGVtYSkuY2VsbC5jcmVhdGVBbmRGaWxsKCkuY29udGVudDtcblx0XHRzZWwuZm9yRWFjaENlbGwoKGNlbGwsIHBvcykgPT4ge1xuXHRcdFx0aWYgKCFjZWxsLmNvbnRlbnQuZXEoYmFzZUNvbnRlbnQpKSB0ci5yZXBsYWNlKHRyLm1hcHBpbmcubWFwKHBvcyArIDEpLCB0ci5tYXBwaW5nLm1hcChwb3MgKyBjZWxsLm5vZGVTaXplIC0gMSksIG5ldyBTbGljZShiYXNlQ29udGVudCwgMCwgMCkpO1xuXHRcdH0pO1xuXHRcdGlmICh0ci5kb2NDaGFuZ2VkKSBkaXNwYXRjaCh0cik7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG4vKipcbiogTW92ZSBhIHRhYmxlIHJvdyBmcm9tIGluZGV4IGBmcm9tYCB0byBpbmRleCBgdG9gLlxuKlxuKiBAcHVibGljXG4qL1xuZnVuY3Rpb24gbW92ZVRhYmxlUm93KG9wdGlvbnMpIHtcblx0cmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcblx0XHRjb25zdCB7IGZyb206IG9yaWdpbkluZGV4LCB0bzogdGFyZ2V0SW5kZXgsIHNlbGVjdCA9IHRydWUsIHBvcyA9IHN0YXRlLnNlbGVjdGlvbi5mcm9tIH0gPSBvcHRpb25zO1xuXHRcdGNvbnN0IHRyID0gc3RhdGUudHI7XG5cdFx0aWYgKG1vdmVSb3coe1xuXHRcdFx0dHIsXG5cdFx0XHRvcmlnaW5JbmRleCxcblx0XHRcdHRhcmdldEluZGV4LFxuXHRcdFx0c2VsZWN0LFxuXHRcdFx0cG9zXG5cdFx0fSkpIHtcblx0XHRcdGRpc3BhdGNoID09PSBudWxsIHx8IGRpc3BhdGNoID09PSB2b2lkIDAgfHwgZGlzcGF0Y2godHIpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cbi8qKlxuKiBNb3ZlIGEgdGFibGUgY29sdW1uIGZyb20gaW5kZXggYGZyb21gIHRvIGluZGV4IGB0b2AuXG4qXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBtb3ZlVGFibGVDb2x1bW4ob3B0aW9ucykge1xuXHRyZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuXHRcdGNvbnN0IHsgZnJvbTogb3JpZ2luSW5kZXgsIHRvOiB0YXJnZXRJbmRleCwgc2VsZWN0ID0gdHJ1ZSwgcG9zID0gc3RhdGUuc2VsZWN0aW9uLmZyb20gfSA9IG9wdGlvbnM7XG5cdFx0Y29uc3QgdHIgPSBzdGF0ZS50cjtcblx0XHRpZiAobW92ZUNvbHVtbih7XG5cdFx0XHR0cixcblx0XHRcdG9yaWdpbkluZGV4LFxuXHRcdFx0dGFyZ2V0SW5kZXgsXG5cdFx0XHRzZWxlY3QsXG5cdFx0XHRwb3Ncblx0XHR9KSkge1xuXHRcdFx0ZGlzcGF0Y2ggPT09IG51bGwgfHwgZGlzcGF0Y2ggPT09IHZvaWQgMCB8fCBkaXNwYXRjaCh0cik7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvY29weXBhc3RlLnRzXG4vKipcbiogR2V0IGEgcmVjdGFuZ3VsYXIgYXJlYSBvZiBjZWxscyBmcm9tIGEgc2xpY2UsIG9yIG51bGwgaWYgdGhlIG91dGVyXG4qIG5vZGVzIG9mIHRoZSBzbGljZSBhcmVuJ3QgdGFibGUgY2VsbHMgb3Igcm93cy5cbipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gcGFzdGVkQ2VsbHMoc2xpY2UpIHtcblx0aWYgKHNsaWNlLnNpemUgPT09IDApIHJldHVybiBudWxsO1xuXHRsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHNsaWNlO1xuXHR3aGlsZSAoY29udGVudC5jaGlsZENvdW50ID09IDEgJiYgKG9wZW5TdGFydCA+IDAgJiYgb3BlbkVuZCA+IDAgfHwgY29udGVudC5jaGlsZCgwKS50eXBlLnNwZWMudGFibGVSb2xlID09IFwidGFibGVcIikpIHtcblx0XHRvcGVuU3RhcnQtLTtcblx0XHRvcGVuRW5kLS07XG5cdFx0Y29udGVudCA9IGNvbnRlbnQuY2hpbGQoMCkuY29udGVudDtcblx0fVxuXHRjb25zdCBmaXJzdCA9IGNvbnRlbnQuY2hpbGQoMCk7XG5cdGNvbnN0IHJvbGUgPSBmaXJzdC50eXBlLnNwZWMudGFibGVSb2xlO1xuXHRjb25zdCBzY2hlbWEgPSBmaXJzdC50eXBlLnNjaGVtYSwgcm93cyA9IFtdO1xuXHRpZiAocm9sZSA9PSBcInJvd1wiKSBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQuY2hpbGRDb3VudDsgaSsrKSB7XG5cdFx0bGV0IGNlbGxzID0gY29udGVudC5jaGlsZChpKS5jb250ZW50O1xuXHRcdGNvbnN0IGxlZnQgPSBpID8gMCA6IE1hdGgubWF4KDAsIG9wZW5TdGFydCAtIDEpO1xuXHRcdGNvbnN0IHJpZ2h0ID0gaSA8IGNvbnRlbnQuY2hpbGRDb3VudCAtIDEgPyAwIDogTWF0aC5tYXgoMCwgb3BlbkVuZCAtIDEpO1xuXHRcdGlmIChsZWZ0IHx8IHJpZ2h0KSBjZWxscyA9IGZpdFNsaWNlKHRhYmxlTm9kZVR5cGVzKHNjaGVtYSkucm93LCBuZXcgU2xpY2UoY2VsbHMsIGxlZnQsIHJpZ2h0KSkuY29udGVudDtcblx0XHRyb3dzLnB1c2goY2VsbHMpO1xuXHR9XG5cdGVsc2UgaWYgKHJvbGUgPT0gXCJjZWxsXCIgfHwgcm9sZSA9PSBcImhlYWRlcl9jZWxsXCIpIHJvd3MucHVzaChvcGVuU3RhcnQgfHwgb3BlbkVuZCA/IGZpdFNsaWNlKHRhYmxlTm9kZVR5cGVzKHNjaGVtYSkucm93LCBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKSkuY29udGVudCA6IGNvbnRlbnQpO1xuXHRlbHNlIHJldHVybiBudWxsO1xuXHRyZXR1cm4gZW5zdXJlUmVjdGFuZ3VsYXIoc2NoZW1hLCByb3dzKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZVJlY3Rhbmd1bGFyKHNjaGVtYSwgcm93cykge1xuXHRjb25zdCB3aWR0aHMgPSBbXTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qgcm93ID0gcm93c1tpXTtcblx0XHRmb3IgKGxldCBqID0gcm93LmNoaWxkQ291bnQgLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0Y29uc3QgeyByb3dzcGFuLCBjb2xzcGFuIH0gPSByb3cuY2hpbGQoaikuYXR0cnM7XG5cdFx0XHRmb3IgKGxldCByID0gaTsgciA8IGkgKyByb3dzcGFuOyByKyspIHdpZHRoc1tyXSA9ICh3aWR0aHNbcl0gfHwgMCkgKyBjb2xzcGFuO1xuXHRcdH1cblx0fVxuXHRsZXQgd2lkdGggPSAwO1xuXHRmb3IgKGxldCByID0gMDsgciA8IHdpZHRocy5sZW5ndGg7IHIrKykgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgd2lkdGhzW3JdKTtcblx0Zm9yIChsZXQgciA9IDA7IHIgPCB3aWR0aHMubGVuZ3RoOyByKyspIHtcblx0XHRpZiAociA+PSByb3dzLmxlbmd0aCkgcm93cy5wdXNoKEZyYWdtZW50LmVtcHR5KTtcblx0XHRpZiAod2lkdGhzW3JdIDwgd2lkdGgpIHtcblx0XHRcdGNvbnN0IGVtcHR5ID0gdGFibGVOb2RlVHlwZXMoc2NoZW1hKS5jZWxsLmNyZWF0ZUFuZEZpbGwoKTtcblx0XHRcdGNvbnN0IGNlbGxzID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gd2lkdGhzW3JdOyBpIDwgd2lkdGg7IGkrKykgY2VsbHMucHVzaChlbXB0eSk7XG5cdFx0XHRyb3dzW3JdID0gcm93c1tyXS5hcHBlbmQoRnJhZ21lbnQuZnJvbShjZWxscykpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4ge1xuXHRcdGhlaWdodDogcm93cy5sZW5ndGgsXG5cdFx0d2lkdGgsXG5cdFx0cm93c1xuXHR9O1xufVxuZnVuY3Rpb24gZml0U2xpY2Uobm9kZVR5cGUsIHNsaWNlKSB7XG5cdGNvbnN0IG5vZGUgPSBub2RlVHlwZS5jcmVhdGVBbmRGaWxsKCk7XG5cdHJldHVybiBuZXcgVHJhbnNmb3JtKG5vZGUpLnJlcGxhY2UoMCwgbm9kZS5jb250ZW50LnNpemUsIHNsaWNlKS5kb2M7XG59XG4vKipcbiogQ2xpcCBvciBleHRlbmQgKHJlcGVhdCkgdGhlIGdpdmVuIHNldCBvZiBjZWxscyB0byBjb3ZlciB0aGUgZ2l2ZW5cbiogd2lkdGggYW5kIGhlaWdodC4gV2lsbCBjbGlwIHJvd3NwYW4vY29sc3BhbiBjZWxscyBhdCB0aGUgZWRnZXMgd2hlblxuKiB0aGV5IHN0aWNrIG91dC5cbipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gY2xpcENlbGxzKHsgd2lkdGgsIGhlaWdodCwgcm93cyB9LCBuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG5cdGlmICh3aWR0aCAhPSBuZXdXaWR0aCkge1xuXHRcdGNvbnN0IGFkZGVkID0gW107XG5cdFx0Y29uc3QgbmV3Um93cyA9IFtdO1xuXHRcdGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3MubGVuZ3RoOyByb3crKykge1xuXHRcdFx0Y29uc3QgZnJhZyA9IHJvd3Nbcm93XSwgY2VsbHMgPSBbXTtcblx0XHRcdGZvciAobGV0IGNvbCA9IGFkZGVkW3Jvd10gfHwgMCwgaSA9IDA7IGNvbCA8IG5ld1dpZHRoOyBpKyspIHtcblx0XHRcdFx0bGV0IGNlbGwgPSBmcmFnLmNoaWxkKGkgJSBmcmFnLmNoaWxkQ291bnQpO1xuXHRcdFx0XHRpZiAoY29sICsgY2VsbC5hdHRycy5jb2xzcGFuID4gbmV3V2lkdGgpIGNlbGwgPSBjZWxsLnR5cGUuY3JlYXRlQ2hlY2tlZChyZW1vdmVDb2xTcGFuKGNlbGwuYXR0cnMsIGNlbGwuYXR0cnMuY29sc3BhbiwgY29sICsgY2VsbC5hdHRycy5jb2xzcGFuIC0gbmV3V2lkdGgpLCBjZWxsLmNvbnRlbnQpO1xuXHRcdFx0XHRjZWxscy5wdXNoKGNlbGwpO1xuXHRcdFx0XHRjb2wgKz0gY2VsbC5hdHRycy5jb2xzcGFuO1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMTsgaiA8IGNlbGwuYXR0cnMucm93c3BhbjsgaisrKSBhZGRlZFtyb3cgKyBqXSA9IChhZGRlZFtyb3cgKyBqXSB8fCAwKSArIGNlbGwuYXR0cnMuY29sc3Bhbjtcblx0XHRcdH1cblx0XHRcdG5ld1Jvd3MucHVzaChGcmFnbWVudC5mcm9tKGNlbGxzKSk7XG5cdFx0fVxuXHRcdHJvd3MgPSBuZXdSb3dzO1xuXHRcdHdpZHRoID0gbmV3V2lkdGg7XG5cdH1cblx0aWYgKGhlaWdodCAhPSBuZXdIZWlnaHQpIHtcblx0XHRjb25zdCBuZXdSb3dzID0gW107XG5cdFx0Zm9yIChsZXQgcm93ID0gMCwgaSA9IDA7IHJvdyA8IG5ld0hlaWdodDsgcm93KyssIGkrKykge1xuXHRcdFx0Y29uc3QgY2VsbHMgPSBbXSwgc291cmNlID0gcm93c1tpICUgaGVpZ2h0XTtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgc291cmNlLmNoaWxkQ291bnQ7IGorKykge1xuXHRcdFx0XHRsZXQgY2VsbCA9IHNvdXJjZS5jaGlsZChqKTtcblx0XHRcdFx0aWYgKHJvdyArIGNlbGwuYXR0cnMucm93c3BhbiA+IG5ld0hlaWdodCkgY2VsbCA9IGNlbGwudHlwZS5jcmVhdGUoe1xuXHRcdFx0XHRcdC4uLmNlbGwuYXR0cnMsXG5cdFx0XHRcdFx0cm93c3BhbjogTWF0aC5tYXgoMSwgbmV3SGVpZ2h0IC0gY2VsbC5hdHRycy5yb3dzcGFuKVxuXHRcdFx0XHR9LCBjZWxsLmNvbnRlbnQpO1xuXHRcdFx0XHRjZWxscy5wdXNoKGNlbGwpO1xuXHRcdFx0fVxuXHRcdFx0bmV3Um93cy5wdXNoKEZyYWdtZW50LmZyb20oY2VsbHMpKTtcblx0XHR9XG5cdFx0cm93cyA9IG5ld1Jvd3M7XG5cdFx0aGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXHR9XG5cdHJldHVybiB7XG5cdFx0d2lkdGgsXG5cdFx0aGVpZ2h0LFxuXHRcdHJvd3Ncblx0fTtcbn1cbmZ1bmN0aW9uIGdyb3dUYWJsZSh0ciwgbWFwLCB0YWJsZSwgc3RhcnQsIHdpZHRoLCBoZWlnaHQsIG1hcEZyb20pIHtcblx0Y29uc3Qgc2NoZW1hID0gdHIuZG9jLnR5cGUuc2NoZW1hO1xuXHRjb25zdCB0eXBlcyA9IHRhYmxlTm9kZVR5cGVzKHNjaGVtYSk7XG5cdGxldCBlbXB0eTtcblx0bGV0IGVtcHR5SGVhZDtcblx0aWYgKHdpZHRoID4gbWFwLndpZHRoKSBmb3IgKGxldCByb3cgPSAwLCByb3dFbmQgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyByb3crKykge1xuXHRcdGNvbnN0IHJvd05vZGUgPSB0YWJsZS5jaGlsZChyb3cpO1xuXHRcdHJvd0VuZCArPSByb3dOb2RlLm5vZGVTaXplO1xuXHRcdGNvbnN0IGNlbGxzID0gW107XG5cdFx0bGV0IGFkZDtcblx0XHRpZiAocm93Tm9kZS5sYXN0Q2hpbGQgPT0gbnVsbCB8fCByb3dOb2RlLmxhc3RDaGlsZC50eXBlID09IHR5cGVzLmNlbGwpIGFkZCA9IGVtcHR5IHx8IChlbXB0eSA9IHR5cGVzLmNlbGwuY3JlYXRlQW5kRmlsbCgpKTtcblx0XHRlbHNlIGFkZCA9IGVtcHR5SGVhZCB8fCAoZW1wdHlIZWFkID0gdHlwZXMuaGVhZGVyX2NlbGwuY3JlYXRlQW5kRmlsbCgpKTtcblx0XHRmb3IgKGxldCBpID0gbWFwLndpZHRoOyBpIDwgd2lkdGg7IGkrKykgY2VsbHMucHVzaChhZGQpO1xuXHRcdHRyLmluc2VydCh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChyb3dFbmQgLSAxICsgc3RhcnQpLCBjZWxscyk7XG5cdH1cblx0aWYgKGhlaWdodCA+IG1hcC5oZWlnaHQpIHtcblx0XHRjb25zdCBjZWxscyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwLCBzdGFydCQxID0gKG1hcC5oZWlnaHQgLSAxKSAqIG1hcC53aWR0aDsgaSA8IE1hdGgubWF4KG1hcC53aWR0aCwgd2lkdGgpOyBpKyspIHtcblx0XHRcdGNvbnN0IGhlYWRlciA9IGkgPj0gbWFwLndpZHRoID8gZmFsc2UgOiB0YWJsZS5ub2RlQXQobWFwLm1hcFtzdGFydCQxICsgaV0pLnR5cGUgPT0gdHlwZXMuaGVhZGVyX2NlbGw7XG5cdFx0XHRjZWxscy5wdXNoKGhlYWRlciA/IGVtcHR5SGVhZCB8fCAoZW1wdHlIZWFkID0gdHlwZXMuaGVhZGVyX2NlbGwuY3JlYXRlQW5kRmlsbCgpKSA6IGVtcHR5IHx8IChlbXB0eSA9IHR5cGVzLmNlbGwuY3JlYXRlQW5kRmlsbCgpKSk7XG5cdFx0fVxuXHRcdGNvbnN0IGVtcHR5Um93ID0gdHlwZXMucm93LmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKGNlbGxzKSksIHJvd3MgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gbWFwLmhlaWdodDsgaSA8IGhlaWdodDsgaSsrKSByb3dzLnB1c2goZW1wdHlSb3cpO1xuXHRcdHRyLmluc2VydCh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChzdGFydCArIHRhYmxlLm5vZGVTaXplIC0gMiksIHJvd3MpO1xuXHR9XG5cdHJldHVybiAhIShlbXB0eSB8fCBlbXB0eUhlYWQpO1xufVxuZnVuY3Rpb24gaXNvbGF0ZUhvcml6b250YWwodHIsIG1hcCwgdGFibGUsIHN0YXJ0LCBsZWZ0LCByaWdodCwgdG9wLCBtYXBGcm9tKSB7XG5cdGlmICh0b3AgPT0gMCB8fCB0b3AgPT0gbWFwLmhlaWdodCkgcmV0dXJuIGZhbHNlO1xuXHRsZXQgZm91bmQgPSBmYWxzZTtcblx0Zm9yIChsZXQgY29sID0gbGVmdDsgY29sIDwgcmlnaHQ7IGNvbCsrKSB7XG5cdFx0Y29uc3QgaW5kZXggPSB0b3AgKiBtYXAud2lkdGggKyBjb2wsIHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuXHRcdGlmIChtYXAubWFwW2luZGV4IC0gbWFwLndpZHRoXSA9PSBwb3MpIHtcblx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocG9zKTtcblx0XHRcdGNvbnN0IHsgdG9wOiBjZWxsVG9wLCBsZWZ0OiBjZWxsTGVmdCB9ID0gbWFwLmZpbmRDZWxsKHBvcyk7XG5cdFx0XHR0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyArIHN0YXJ0KSwgbnVsbCwge1xuXHRcdFx0XHQuLi5jZWxsLmF0dHJzLFxuXHRcdFx0XHRyb3dzcGFuOiB0b3AgLSBjZWxsVG9wXG5cdFx0XHR9KTtcblx0XHRcdHRyLmluc2VydCh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChtYXAucG9zaXRpb25BdCh0b3AsIGNlbGxMZWZ0LCB0YWJsZSkpLCBjZWxsLnR5cGUuY3JlYXRlQW5kRmlsbCh7XG5cdFx0XHRcdC4uLmNlbGwuYXR0cnMsXG5cdFx0XHRcdHJvd3NwYW46IGNlbGxUb3AgKyBjZWxsLmF0dHJzLnJvd3NwYW4gLSB0b3Bcblx0XHRcdH0pKTtcblx0XHRcdGNvbCArPSBjZWxsLmF0dHJzLmNvbHNwYW4gLSAxO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpc29sYXRlVmVydGljYWwodHIsIG1hcCwgdGFibGUsIHN0YXJ0LCB0b3AsIGJvdHRvbSwgbGVmdCwgbWFwRnJvbSkge1xuXHRpZiAobGVmdCA9PSAwIHx8IGxlZnQgPT0gbWFwLndpZHRoKSByZXR1cm4gZmFsc2U7XG5cdGxldCBmb3VuZCA9IGZhbHNlO1xuXHRmb3IgKGxldCByb3cgPSB0b3A7IHJvdyA8IGJvdHRvbTsgcm93KyspIHtcblx0XHRjb25zdCBpbmRleCA9IHJvdyAqIG1hcC53aWR0aCArIGxlZnQsIHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuXHRcdGlmIChtYXAubWFwW2luZGV4IC0gMV0gPT0gcG9zKSB7XG5cdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG5cdFx0XHRjb25zdCBjZWxsTGVmdCA9IG1hcC5jb2xDb3VudChwb3MpO1xuXHRcdFx0Y29uc3QgdXBkYXRlUG9zID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgc3RhcnQpO1xuXHRcdFx0dHIuc2V0Tm9kZU1hcmt1cCh1cGRhdGVQb3MsIG51bGwsIHJlbW92ZUNvbFNwYW4oY2VsbC5hdHRycywgbGVmdCAtIGNlbGxMZWZ0LCBjZWxsLmF0dHJzLmNvbHNwYW4gLSAobGVmdCAtIGNlbGxMZWZ0KSkpO1xuXHRcdFx0dHIuaW5zZXJ0KHVwZGF0ZVBvcyArIGNlbGwubm9kZVNpemUsIGNlbGwudHlwZS5jcmVhdGVBbmRGaWxsKHJlbW92ZUNvbFNwYW4oY2VsbC5hdHRycywgMCwgbGVmdCAtIGNlbGxMZWZ0KSkpO1xuXHRcdFx0cm93ICs9IGNlbGwuYXR0cnMucm93c3BhbiAtIDE7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmb3VuZDtcbn1cbi8qKlxuKiBJbnNlcnQgdGhlIGdpdmVuIHNldCBvZiBjZWxscyAoYXMgcmV0dXJuZWQgYnkgYHBhc3RlZENlbGxzYCkgaW50byBhXG4qIHRhYmxlLCBhdCB0aGUgcG9zaXRpb24gcG9pbnRlZCBhdCBieSByZWN0LlxuKlxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBpbnNlcnRDZWxscyhzdGF0ZSwgZGlzcGF0Y2gsIHRhYmxlU3RhcnQsIHJlY3QsIGNlbGxzKSB7XG5cdGxldCB0YWJsZSA9IHRhYmxlU3RhcnQgPyBzdGF0ZS5kb2Mubm9kZUF0KHRhYmxlU3RhcnQgLSAxKSA6IHN0YXRlLmRvYztcblx0aWYgKCF0YWJsZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gdGFibGUgZm91bmRcIik7XG5cdGxldCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuXHRjb25zdCB7IHRvcCwgbGVmdCB9ID0gcmVjdDtcblx0Y29uc3QgcmlnaHQgPSBsZWZ0ICsgY2VsbHMud2lkdGgsIGJvdHRvbSA9IHRvcCArIGNlbGxzLmhlaWdodDtcblx0Y29uc3QgdHIgPSBzdGF0ZS50cjtcblx0bGV0IG1hcEZyb20gPSAwO1xuXHRmdW5jdGlvbiByZWNvbXAoKSB7XG5cdFx0dGFibGUgPSB0YWJsZVN0YXJ0ID8gdHIuZG9jLm5vZGVBdCh0YWJsZVN0YXJ0IC0gMSkgOiB0ci5kb2M7XG5cdFx0aWYgKCF0YWJsZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gdGFibGUgZm91bmRcIik7XG5cdFx0bWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcblx0XHRtYXBGcm9tID0gdHIubWFwcGluZy5tYXBzLmxlbmd0aDtcblx0fVxuXHRpZiAoZ3Jvd1RhYmxlKHRyLCBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0LCByaWdodCwgYm90dG9tLCBtYXBGcm9tKSkgcmVjb21wKCk7XG5cdGlmIChpc29sYXRlSG9yaXpvbnRhbCh0ciwgbWFwLCB0YWJsZSwgdGFibGVTdGFydCwgbGVmdCwgcmlnaHQsIHRvcCwgbWFwRnJvbSkpIHJlY29tcCgpO1xuXHRpZiAoaXNvbGF0ZUhvcml6b250YWwodHIsIG1hcCwgdGFibGUsIHRhYmxlU3RhcnQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIG1hcEZyb20pKSByZWNvbXAoKTtcblx0aWYgKGlzb2xhdGVWZXJ0aWNhbCh0ciwgbWFwLCB0YWJsZSwgdGFibGVTdGFydCwgdG9wLCBib3R0b20sIGxlZnQsIG1hcEZyb20pKSByZWNvbXAoKTtcblx0aWYgKGlzb2xhdGVWZXJ0aWNhbCh0ciwgbWFwLCB0YWJsZSwgdGFibGVTdGFydCwgdG9wLCBib3R0b20sIHJpZ2h0LCBtYXBGcm9tKSkgcmVjb21wKCk7XG5cdGZvciAobGV0IHJvdyA9IHRvcDsgcm93IDwgYm90dG9tOyByb3crKykge1xuXHRcdGNvbnN0IGZyb20gPSBtYXAucG9zaXRpb25BdChyb3csIGxlZnQsIHRhYmxlKSwgdG8gPSBtYXAucG9zaXRpb25BdChyb3csIHJpZ2h0LCB0YWJsZSk7XG5cdFx0dHIucmVwbGFjZSh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChmcm9tICsgdGFibGVTdGFydCksIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHRvICsgdGFibGVTdGFydCksIG5ldyBTbGljZShjZWxscy5yb3dzW3JvdyAtIHRvcF0sIDAsIDApKTtcblx0fVxuXHRyZWNvbXAoKTtcblx0dHIuc2V0U2VsZWN0aW9uKG5ldyBDZWxsU2VsZWN0aW9uKHRyLmRvYy5yZXNvbHZlKHRhYmxlU3RhcnQgKyBtYXAucG9zaXRpb25BdCh0b3AsIGxlZnQsIHRhYmxlKSksIHRyLmRvYy5yZXNvbHZlKHRhYmxlU3RhcnQgKyBtYXAucG9zaXRpb25BdChib3R0b20gLSAxLCByaWdodCAtIDEsIHRhYmxlKSkpKTtcblx0ZGlzcGF0Y2godHIpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvaW5wdXQudHNcbmNvbnN0IGhhbmRsZUtleURvd24gPSBrZXlkb3duSGFuZGxlcih7XG5cdEFycm93TGVmdDogYXJyb3coXCJob3JpelwiLCAtMSksXG5cdEFycm93UmlnaHQ6IGFycm93KFwiaG9yaXpcIiwgMSksXG5cdEFycm93VXA6IGFycm93KFwidmVydFwiLCAtMSksXG5cdEFycm93RG93bjogYXJyb3coXCJ2ZXJ0XCIsIDEpLFxuXHRcIlNoaWZ0LUFycm93TGVmdFwiOiBzaGlmdEFycm93KFwiaG9yaXpcIiwgLTEpLFxuXHRcIlNoaWZ0LUFycm93UmlnaHRcIjogc2hpZnRBcnJvdyhcImhvcml6XCIsIDEpLFxuXHRcIlNoaWZ0LUFycm93VXBcIjogc2hpZnRBcnJvdyhcInZlcnRcIiwgLTEpLFxuXHRcIlNoaWZ0LUFycm93RG93blwiOiBzaGlmdEFycm93KFwidmVydFwiLCAxKSxcblx0QmFja3NwYWNlOiBkZWxldGVDZWxsU2VsZWN0aW9uLFxuXHRcIk1vZC1CYWNrc3BhY2VcIjogZGVsZXRlQ2VsbFNlbGVjdGlvbixcblx0RGVsZXRlOiBkZWxldGVDZWxsU2VsZWN0aW9uLFxuXHRcIk1vZC1EZWxldGVcIjogZGVsZXRlQ2VsbFNlbGVjdGlvblxufSk7XG5mdW5jdGlvbiBtYXliZVNldFNlbGVjdGlvbihzdGF0ZSwgZGlzcGF0Y2gsIHNlbGVjdGlvbikge1xuXHRpZiAoc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpIHJldHVybiBmYWxzZTtcblx0aWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKS5zY3JvbGxJbnRvVmlldygpKTtcblx0cmV0dXJuIHRydWU7XG59XG4vKipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gYXJyb3coYXhpcywgZGlyKSB7XG5cdHJldHVybiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG5cdFx0aWYgKCF2aWV3KSByZXR1cm4gZmFsc2U7XG5cdFx0Y29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuXHRcdGlmIChzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSByZXR1cm4gbWF5YmVTZXRTZWxlY3Rpb24oc3RhdGUsIGRpc3BhdGNoLCBTZWxlY3Rpb24ubmVhcihzZWwuJGhlYWRDZWxsLCBkaXIpKTtcblx0XHRpZiAoYXhpcyAhPSBcImhvcml6XCIgJiYgIXNlbC5lbXB0eSkgcmV0dXJuIGZhbHNlO1xuXHRcdGNvbnN0IGVuZCA9IGF0RW5kT2ZDZWxsKHZpZXcsIGF4aXMsIGRpcik7XG5cdFx0aWYgKGVuZCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKGF4aXMgPT0gXCJob3JpelwiKSByZXR1cm4gbWF5YmVTZXRTZWxlY3Rpb24oc3RhdGUsIGRpc3BhdGNoLCBTZWxlY3Rpb24ubmVhcihzdGF0ZS5kb2MucmVzb2x2ZShzZWwuaGVhZCArIGRpciksIGRpcikpO1xuXHRcdGVsc2Uge1xuXHRcdFx0Y29uc3QgJGNlbGwgPSBzdGF0ZS5kb2MucmVzb2x2ZShlbmQpO1xuXHRcdFx0Y29uc3QgJG5leHQgPSBuZXh0Q2VsbCgkY2VsbCwgYXhpcywgZGlyKTtcblx0XHRcdGxldCBuZXdTZWw7XG5cdFx0XHRpZiAoJG5leHQpIG5ld1NlbCA9IFNlbGVjdGlvbi5uZWFyKCRuZXh0LCAxKTtcblx0XHRcdGVsc2UgaWYgKGRpciA8IDApIG5ld1NlbCA9IFNlbGVjdGlvbi5uZWFyKHN0YXRlLmRvYy5yZXNvbHZlKCRjZWxsLmJlZm9yZSgtMSkpLCAtMSk7XG5cdFx0XHRlbHNlIG5ld1NlbCA9IFNlbGVjdGlvbi5uZWFyKHN0YXRlLmRvYy5yZXNvbHZlKCRjZWxsLmFmdGVyKC0xKSksIDEpO1xuXHRcdFx0cmV0dXJuIG1heWJlU2V0U2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCwgbmV3U2VsKTtcblx0XHR9XG5cdH07XG59XG5mdW5jdGlvbiBzaGlmdEFycm93KGF4aXMsIGRpcikge1xuXHRyZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuXHRcdGlmICghdmlldykgcmV0dXJuIGZhbHNlO1xuXHRcdGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcblx0XHRsZXQgY2VsbFNlbDtcblx0XHRpZiAoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikgY2VsbFNlbCA9IHNlbDtcblx0XHRlbHNlIHtcblx0XHRcdGNvbnN0IGVuZCA9IGF0RW5kT2ZDZWxsKHZpZXcsIGF4aXMsIGRpcik7XG5cdFx0XHRpZiAoZW5kID09IG51bGwpIHJldHVybiBmYWxzZTtcblx0XHRcdGNlbGxTZWwgPSBuZXcgQ2VsbFNlbGVjdGlvbihzdGF0ZS5kb2MucmVzb2x2ZShlbmQpKTtcblx0XHR9XG5cdFx0Y29uc3QgJGhlYWQgPSBuZXh0Q2VsbChjZWxsU2VsLiRoZWFkQ2VsbCwgYXhpcywgZGlyKTtcblx0XHRpZiAoISRoZWFkKSByZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIG1heWJlU2V0U2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCwgbmV3IENlbGxTZWxlY3Rpb24oY2VsbFNlbC4kYW5jaG9yQ2VsbCwgJGhlYWQpKTtcblx0fTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRyaXBsZUNsaWNrKHZpZXcsIHBvcykge1xuXHRjb25zdCBkb2MgPSB2aWV3LnN0YXRlLmRvYywgJGNlbGwgPSBjZWxsQXJvdW5kKGRvYy5yZXNvbHZlKHBvcykpO1xuXHRpZiAoISRjZWxsKSByZXR1cm4gZmFsc2U7XG5cdHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IENlbGxTZWxlY3Rpb24oJGNlbGwpKSk7XG5cdHJldHVybiB0cnVlO1xufVxuLyoqXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBoYW5kbGVQYXN0ZSh2aWV3LCBfLCBzbGljZSkge1xuXHRpZiAoIWlzSW5UYWJsZSh2aWV3LnN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuXHRsZXQgY2VsbHMgPSBwYXN0ZWRDZWxscyhzbGljZSk7XG5cdGNvbnN0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuXHRpZiAoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikge1xuXHRcdGlmICghY2VsbHMpIGNlbGxzID0ge1xuXHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRoZWlnaHQ6IDEsXG5cdFx0XHRyb3dzOiBbRnJhZ21lbnQuZnJvbShmaXRTbGljZSh0YWJsZU5vZGVUeXBlcyh2aWV3LnN0YXRlLnNjaGVtYSkuY2VsbCwgc2xpY2UpKV1cblx0XHR9O1xuXHRcdGNvbnN0IHRhYmxlID0gc2VsLiRhbmNob3JDZWxsLm5vZGUoLTEpO1xuXHRcdGNvbnN0IHN0YXJ0ID0gc2VsLiRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcblx0XHRjb25zdCByZWN0ID0gVGFibGVNYXAuZ2V0KHRhYmxlKS5yZWN0QmV0d2VlbihzZWwuJGFuY2hvckNlbGwucG9zIC0gc3RhcnQsIHNlbC4kaGVhZENlbGwucG9zIC0gc3RhcnQpO1xuXHRcdGNlbGxzID0gY2xpcENlbGxzKGNlbGxzLCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LCByZWN0LmJvdHRvbSAtIHJlY3QudG9wKTtcblx0XHRpbnNlcnRDZWxscyh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCBzdGFydCwgcmVjdCwgY2VsbHMpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKGNlbGxzKSB7XG5cdFx0Y29uc3QgJGNlbGwgPSBzZWxlY3Rpb25DZWxsKHZpZXcuc3RhdGUpO1xuXHRcdGNvbnN0IHN0YXJ0ID0gJGNlbGwuc3RhcnQoLTEpO1xuXHRcdGluc2VydENlbGxzKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHN0YXJ0LCBUYWJsZU1hcC5nZXQoJGNlbGwubm9kZSgtMSkpLmZpbmRDZWxsKCRjZWxsLnBvcyAtIHN0YXJ0KSwgY2VsbHMpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duJDEodmlldywgc3RhcnRFdmVudCkge1xuXHR2YXIgX2NlbGxVbmRlck1vdXNlO1xuXHRpZiAoc3RhcnRFdmVudC5idXR0b24gIT0gMCkgcmV0dXJuO1xuXHRpZiAoc3RhcnRFdmVudC5jdHJsS2V5IHx8IHN0YXJ0RXZlbnQubWV0YUtleSkgcmV0dXJuO1xuXHRjb25zdCBzdGFydERPTUNlbGwgPSBkb21JbkNlbGwodmlldywgc3RhcnRFdmVudC50YXJnZXQpO1xuXHRsZXQgJGFuY2hvcjtcblx0aWYgKHN0YXJ0RXZlbnQuc2hpZnRLZXkgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSB7XG5cdFx0c2V0Q2VsbFNlbGVjdGlvbih2aWV3LnN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yQ2VsbCwgc3RhcnRFdmVudCk7XG5cdFx0c3RhcnRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9IGVsc2UgaWYgKHN0YXJ0RXZlbnQuc2hpZnRLZXkgJiYgc3RhcnRET01DZWxsICYmICgkYW5jaG9yID0gY2VsbEFyb3VuZCh2aWV3LnN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yKSkgIT0gbnVsbCAmJiAoKF9jZWxsVW5kZXJNb3VzZSA9IGNlbGxVbmRlck1vdXNlKHZpZXcsIHN0YXJ0RXZlbnQpKSA9PT0gbnVsbCB8fCBfY2VsbFVuZGVyTW91c2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jZWxsVW5kZXJNb3VzZS5wb3MpICE9ICRhbmNob3IucG9zKSB7XG5cdFx0c2V0Q2VsbFNlbGVjdGlvbigkYW5jaG9yLCBzdGFydEV2ZW50KTtcblx0XHRzdGFydEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH0gZWxzZSBpZiAoIXN0YXJ0RE9NQ2VsbCkgcmV0dXJuO1xuXHRmdW5jdGlvbiBzZXRDZWxsU2VsZWN0aW9uKCRhbmNob3IkMSwgZXZlbnQpIHtcblx0XHRsZXQgJGhlYWQgPSBjZWxsVW5kZXJNb3VzZSh2aWV3LCBldmVudCk7XG5cdFx0Y29uc3Qgc3RhcnRpbmcgPSB0YWJsZUVkaXRpbmdLZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSkgPT0gbnVsbDtcblx0XHRpZiAoISRoZWFkIHx8ICFpblNhbWVUYWJsZSgkYW5jaG9yJDEsICRoZWFkKSkgaWYgKHN0YXJ0aW5nKSAkaGVhZCA9ICRhbmNob3IkMTtcblx0XHRlbHNlIHJldHVybjtcblx0XHRjb25zdCBzZWxlY3Rpb24gPSBuZXcgQ2VsbFNlbGVjdGlvbigkYW5jaG9yJDEsICRoZWFkKTtcblx0XHRpZiAoc3RhcnRpbmcgfHwgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbikpIHtcblx0XHRcdGNvbnN0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcblx0XHRcdGlmIChzdGFydGluZykgdHIuc2V0TWV0YSh0YWJsZUVkaXRpbmdLZXksICRhbmNob3IkMS5wb3MpO1xuXHRcdFx0dmlldy5kaXNwYXRjaCh0cik7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0dmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHN0b3ApO1xuXHRcdHZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIHN0b3ApO1xuXHRcdHZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuXHRcdGlmICh0YWJsZUVkaXRpbmdLZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSkgIT0gbnVsbCkgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldE1ldGEodGFibGVFZGl0aW5nS2V5LCAtMSkpO1xuXHR9XG5cdGZ1bmN0aW9uIG1vdmUoX2V2ZW50KSB7XG5cdFx0Y29uc3QgZXZlbnQgPSBfZXZlbnQ7XG5cdFx0Y29uc3QgYW5jaG9yID0gdGFibGVFZGl0aW5nS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuXHRcdGxldCAkYW5jaG9yJDE7XG5cdFx0aWYgKGFuY2hvciAhPSBudWxsKSAkYW5jaG9yJDEgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGFuY2hvcik7XG5cdFx0ZWxzZSBpZiAoZG9tSW5DZWxsKHZpZXcsIGV2ZW50LnRhcmdldCkgIT0gc3RhcnRET01DZWxsKSB7XG5cdFx0XHQkYW5jaG9yJDEgPSBjZWxsVW5kZXJNb3VzZSh2aWV3LCBzdGFydEV2ZW50KTtcblx0XHRcdGlmICghJGFuY2hvciQxKSByZXR1cm4gc3RvcCgpO1xuXHRcdH1cblx0XHRpZiAoJGFuY2hvciQxKSBzZXRDZWxsU2VsZWN0aW9uKCRhbmNob3IkMSwgZXZlbnQpO1xuXHR9XG5cdHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBzdG9wKTtcblx0dmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgc3RvcCk7XG5cdHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xufVxuZnVuY3Rpb24gYXRFbmRPZkNlbGwodmlldywgYXhpcywgZGlyKSB7XG5cdGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpIHJldHVybiBudWxsO1xuXHRjb25zdCB7ICRoZWFkIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcblx0Zm9yIChsZXQgZCA9ICRoZWFkLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcblx0XHRjb25zdCBwYXJlbnQgPSAkaGVhZC5ub2RlKGQpO1xuXHRcdGlmICgoZGlyIDwgMCA/ICRoZWFkLmluZGV4KGQpIDogJGhlYWQuaW5kZXhBZnRlcihkKSkgIT0gKGRpciA8IDAgPyAwIDogcGFyZW50LmNoaWxkQ291bnQpKSByZXR1cm4gbnVsbDtcblx0XHRpZiAocGFyZW50LnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJjZWxsXCIgfHwgcGFyZW50LnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJoZWFkZXJfY2VsbFwiKSB7XG5cdFx0XHRjb25zdCBjZWxsUG9zID0gJGhlYWQuYmVmb3JlKGQpO1xuXHRcdFx0Y29uc3QgZGlyU3RyID0gYXhpcyA9PSBcInZlcnRcIiA/IGRpciA+IDAgPyBcImRvd25cIiA6IFwidXBcIiA6IGRpciA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcblx0XHRcdHJldHVybiB2aWV3LmVuZE9mVGV4dGJsb2NrKGRpclN0cikgPyBjZWxsUG9zIDogbnVsbDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkb21JbkNlbGwodmlldywgZG9tKSB7XG5cdGZvciAoOyBkb20gJiYgZG9tICE9IHZpZXcuZG9tOyBkb20gPSBkb20ucGFyZW50Tm9kZSkgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIlREXCIgfHwgZG9tLm5vZGVOYW1lID09IFwiVEhcIikgcmV0dXJuIGRvbTtcblx0cmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjZWxsVW5kZXJNb3VzZSh2aWV3LCBldmVudCkge1xuXHRjb25zdCBtb3VzZVBvcyA9IHZpZXcucG9zQXRDb29yZHMoe1xuXHRcdGxlZnQ6IGV2ZW50LmNsaWVudFgsXG5cdFx0dG9wOiBldmVudC5jbGllbnRZXG5cdH0pO1xuXHRpZiAoIW1vdXNlUG9zKSByZXR1cm4gbnVsbDtcblx0bGV0IHsgaW5zaWRlLCBwb3MgfSA9IG1vdXNlUG9zO1xuXHRyZXR1cm4gaW5zaWRlID49IDAgJiYgY2VsbEFyb3VuZCh2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSkpIHx8IGNlbGxBcm91bmQodmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3RhYmxldmlldy50c1xuLyoqXG4qIEBwdWJsaWNcbiovXG52YXIgVGFibGVWaWV3ID0gY2xhc3Mge1xuXHRjb25zdHJ1Y3Rvcihub2RlLCBkZWZhdWx0Q2VsbE1pbldpZHRoKSB7XG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcblx0XHR0aGlzLmRlZmF1bHRDZWxsTWluV2lkdGggPSBkZWZhdWx0Q2VsbE1pbldpZHRoO1xuXHRcdHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHR0aGlzLmRvbS5jbGFzc05hbWUgPSBcInRhYmxlV3JhcHBlclwiO1xuXHRcdHRoaXMudGFibGUgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGFibGVcIikpO1xuXHRcdHRoaXMudGFibGUuc3R5bGUuc2V0UHJvcGVydHkoXCItLWRlZmF1bHQtY2VsbC1taW4td2lkdGhcIiwgYCR7ZGVmYXVsdENlbGxNaW5XaWR0aH1weGApO1xuXHRcdHRoaXMuY29sZ3JvdXAgPSB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjb2xncm91cFwiKSk7XG5cdFx0dXBkYXRlQ29sdW1uc09uUmVzaXplKG5vZGUsIHRoaXMuY29sZ3JvdXAsIHRoaXMudGFibGUsIGRlZmF1bHRDZWxsTWluV2lkdGgpO1xuXHRcdHRoaXMuY29udGVudERPTSA9IHRoaXMudGFibGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpKTtcblx0fVxuXHR1cGRhdGUobm9kZSkge1xuXHRcdGlmIChub2RlLnR5cGUgIT0gdGhpcy5ub2RlLnR5cGUpIHJldHVybiBmYWxzZTtcblx0XHR0aGlzLm5vZGUgPSBub2RlO1xuXHRcdHVwZGF0ZUNvbHVtbnNPblJlc2l6ZShub2RlLCB0aGlzLmNvbGdyb3VwLCB0aGlzLnRhYmxlLCB0aGlzLmRlZmF1bHRDZWxsTWluV2lkdGgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlnbm9yZU11dGF0aW9uKHJlY29yZCkge1xuXHRcdHJldHVybiByZWNvcmQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIiAmJiAocmVjb3JkLnRhcmdldCA9PSB0aGlzLnRhYmxlIHx8IHRoaXMuY29sZ3JvdXAuY29udGFpbnMocmVjb3JkLnRhcmdldCkpO1xuXHR9XG59O1xuLyoqXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiB1cGRhdGVDb2x1bW5zT25SZXNpemUobm9kZSwgY29sZ3JvdXAsIHRhYmxlLCBkZWZhdWx0Q2VsbE1pbldpZHRoLCBvdmVycmlkZUNvbCwgb3ZlcnJpZGVWYWx1ZSkge1xuXHRsZXQgdG90YWxXaWR0aCA9IDA7XG5cdGxldCBmaXhlZFdpZHRoID0gdHJ1ZTtcblx0bGV0IG5leHRET00gPSBjb2xncm91cC5maXJzdENoaWxkO1xuXHRjb25zdCByb3cgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cdGlmICghcm93KSByZXR1cm47XG5cdGZvciAobGV0IGkgPSAwLCBjb2wgPSAwOyBpIDwgcm93LmNoaWxkQ291bnQ7IGkrKykge1xuXHRcdGNvbnN0IHsgY29sc3BhbiwgY29sd2lkdGggfSA9IHJvdy5jaGlsZChpKS5hdHRycztcblx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGNvbHNwYW47IGorKywgY29sKyspIHtcblx0XHRcdGNvbnN0IGhhc1dpZHRoID0gb3ZlcnJpZGVDb2wgPT0gY29sID8gb3ZlcnJpZGVWYWx1ZSA6IGNvbHdpZHRoICYmIGNvbHdpZHRoW2pdO1xuXHRcdFx0Y29uc3QgY3NzV2lkdGggPSBoYXNXaWR0aCA/IGhhc1dpZHRoICsgXCJweFwiIDogXCJcIjtcblx0XHRcdHRvdGFsV2lkdGggKz0gaGFzV2lkdGggfHwgZGVmYXVsdENlbGxNaW5XaWR0aDtcblx0XHRcdGlmICghaGFzV2lkdGgpIGZpeGVkV2lkdGggPSBmYWxzZTtcblx0XHRcdGlmICghbmV4dERPTSkge1xuXHRcdFx0XHRjb25zdCBjb2wkMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjb2xcIik7XG5cdFx0XHRcdGNvbCQxLnN0eWxlLndpZHRoID0gY3NzV2lkdGg7XG5cdFx0XHRcdGNvbGdyb3VwLmFwcGVuZENoaWxkKGNvbCQxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChuZXh0RE9NLnN0eWxlLndpZHRoICE9IGNzc1dpZHRoKSBuZXh0RE9NLnN0eWxlLndpZHRoID0gY3NzV2lkdGg7XG5cdFx0XHRcdG5leHRET00gPSBuZXh0RE9NLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR3aGlsZSAobmV4dERPTSkge1xuXHRcdHZhciBfbmV4dERPTSRwYXJlbnROb2RlO1xuXHRcdGNvbnN0IGFmdGVyID0gbmV4dERPTS5uZXh0U2libGluZztcblx0XHQoX25leHRET00kcGFyZW50Tm9kZSA9IG5leHRET00ucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX25leHRET00kcGFyZW50Tm9kZSA9PT0gdm9pZCAwIHx8IF9uZXh0RE9NJHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobmV4dERPTSk7XG5cdFx0bmV4dERPTSA9IGFmdGVyO1xuXHR9XG5cdGlmIChmaXhlZFdpZHRoKSB7XG5cdFx0dGFibGUuc3R5bGUud2lkdGggPSB0b3RhbFdpZHRoICsgXCJweFwiO1xuXHRcdHRhYmxlLnN0eWxlLm1pbldpZHRoID0gXCJcIjtcblx0fSBlbHNlIHtcblx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IFwiXCI7XG5cdFx0dGFibGUuc3R5bGUubWluV2lkdGggPSB0b3RhbFdpZHRoICsgXCJweFwiO1xuXHR9XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9jb2x1bW5yZXNpemluZy50c1xuLyoqXG4qIEBwdWJsaWNcbiovXG5jb25zdCBjb2x1bW5SZXNpemluZ1BsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoXCJ0YWJsZUNvbHVtblJlc2l6aW5nXCIpO1xuLyoqXG4qIEBwdWJsaWNcbiovXG5mdW5jdGlvbiBjb2x1bW5SZXNpemluZyh7IGhhbmRsZVdpZHRoID0gNSwgY2VsbE1pbldpZHRoID0gMjUsIGRlZmF1bHRDZWxsTWluV2lkdGggPSAxMDAsIFZpZXcgPSBUYWJsZVZpZXcsIGxhc3RDb2x1bW5SZXNpemFibGUgPSB0cnVlIH0gPSB7fSkge1xuXHRjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luKHtcblx0XHRrZXk6IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LFxuXHRcdHN0YXRlOiB7XG5cdFx0XHRpbml0KF8sIHN0YXRlKSB7XG5cdFx0XHRcdHZhciBfcGx1Z2luJHNwZWM7XG5cdFx0XHRcdGNvbnN0IG5vZGVWaWV3cyA9IChfcGx1Z2luJHNwZWMgPSBwbHVnaW4uc3BlYykgPT09IG51bGwgfHwgX3BsdWdpbiRzcGVjID09PSB2b2lkIDAgfHwgKF9wbHVnaW4kc3BlYyA9IF9wbHVnaW4kc3BlYy5wcm9wcykgPT09IG51bGwgfHwgX3BsdWdpbiRzcGVjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGx1Z2luJHNwZWMubm9kZVZpZXdzO1xuXHRcdFx0XHRjb25zdCB0YWJsZU5hbWUgPSB0YWJsZU5vZGVUeXBlcyhzdGF0ZS5zY2hlbWEpLnRhYmxlLm5hbWU7XG5cdFx0XHRcdGlmIChWaWV3ICYmIG5vZGVWaWV3cykgbm9kZVZpZXdzW3RhYmxlTmFtZV0gPSAobm9kZSwgdmlldykgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgVmlldyhub2RlLCBkZWZhdWx0Q2VsbE1pbldpZHRoLCB2aWV3KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIG5ldyBSZXNpemVTdGF0ZSgtMSwgZmFsc2UpO1xuXHRcdFx0fSxcblx0XHRcdGFwcGx5KHRyLCBwcmV2KSB7XG5cdFx0XHRcdHJldHVybiBwcmV2LmFwcGx5KHRyKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHByb3BzOiB7XG5cdFx0XHRhdHRyaWJ1dGVzOiAoc3RhdGUpID0+IHtcblx0XHRcdFx0Y29uc3QgcGx1Z2luU3RhdGUgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSk7XG5cdFx0XHRcdHJldHVybiBwbHVnaW5TdGF0ZSAmJiBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUgPiAtMSA/IHsgY2xhc3M6IFwicmVzaXplLWN1cnNvclwiIH0gOiB7fTtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVET01FdmVudHM6IHtcblx0XHRcdFx0bW91c2Vtb3ZlOiAodmlldywgZXZlbnQpID0+IHtcblx0XHRcdFx0XHRoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQsIGhhbmRsZVdpZHRoLCBsYXN0Q29sdW1uUmVzaXphYmxlKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0bW91c2VsZWF2ZTogKHZpZXcpID0+IHtcblx0XHRcdFx0XHRoYW5kbGVNb3VzZUxlYXZlKHZpZXcpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRtb3VzZWRvd246ICh2aWV3LCBldmVudCkgPT4ge1xuXHRcdFx0XHRcdGhhbmRsZU1vdXNlRG93bih2aWV3LCBldmVudCwgY2VsbE1pbldpZHRoLCBkZWZhdWx0Q2VsbE1pbldpZHRoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlY29yYXRpb25zOiAoc3RhdGUpID0+IHtcblx0XHRcdFx0Y29uc3QgcGx1Z2luU3RhdGUgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSk7XG5cdFx0XHRcdGlmIChwbHVnaW5TdGF0ZSAmJiBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUgPiAtMSkgcmV0dXJuIGhhbmRsZURlY29yYXRpb25zKHN0YXRlLCBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUpO1xuXHRcdFx0fSxcblx0XHRcdG5vZGVWaWV3czoge31cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcGx1Z2luO1xufVxuLyoqXG4qIEBwdWJsaWNcbiovXG52YXIgUmVzaXplU3RhdGUgPSBjbGFzcyBSZXNpemVTdGF0ZSB7XG5cdGNvbnN0cnVjdG9yKGFjdGl2ZUhhbmRsZSwgZHJhZ2dpbmcpIHtcblx0XHR0aGlzLmFjdGl2ZUhhbmRsZSA9IGFjdGl2ZUhhbmRsZTtcblx0XHR0aGlzLmRyYWdnaW5nID0gZHJhZ2dpbmc7XG5cdH1cblx0YXBwbHkodHIpIHtcblx0XHRjb25zdCBzdGF0ZSA9IHRoaXM7XG5cdFx0Y29uc3QgYWN0aW9uID0gdHIuZ2V0TWV0YShjb2x1bW5SZXNpemluZ1BsdWdpbktleSk7XG5cdFx0aWYgKGFjdGlvbiAmJiBhY3Rpb24uc2V0SGFuZGxlICE9IG51bGwpIHJldHVybiBuZXcgUmVzaXplU3RhdGUoYWN0aW9uLnNldEhhbmRsZSwgZmFsc2UpO1xuXHRcdGlmIChhY3Rpb24gJiYgYWN0aW9uLnNldERyYWdnaW5nICE9PSB2b2lkIDApIHJldHVybiBuZXcgUmVzaXplU3RhdGUoc3RhdGUuYWN0aXZlSGFuZGxlLCBhY3Rpb24uc2V0RHJhZ2dpbmcpO1xuXHRcdGlmIChzdGF0ZS5hY3RpdmVIYW5kbGUgPiAtMSAmJiB0ci5kb2NDaGFuZ2VkKSB7XG5cdFx0XHRsZXQgaGFuZGxlID0gdHIubWFwcGluZy5tYXAoc3RhdGUuYWN0aXZlSGFuZGxlLCAtMSk7XG5cdFx0XHRpZiAoIXBvaW50c0F0Q2VsbCh0ci5kb2MucmVzb2x2ZShoYW5kbGUpKSkgaGFuZGxlID0gLTE7XG5cdFx0XHRyZXR1cm4gbmV3IFJlc2l6ZVN0YXRlKGhhbmRsZSwgc3RhdGUuZHJhZ2dpbmcpO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn07XG5mdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQsIGhhbmRsZVdpZHRoLCBsYXN0Q29sdW1uUmVzaXphYmxlKSB7XG5cdGlmICghdmlldy5lZGl0YWJsZSkgcmV0dXJuO1xuXHRjb25zdCBwbHVnaW5TdGF0ZSA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuXHRpZiAoIXBsdWdpblN0YXRlKSByZXR1cm47XG5cdGlmICghcGx1Z2luU3RhdGUuZHJhZ2dpbmcpIHtcblx0XHRjb25zdCB0YXJnZXQgPSBkb21DZWxsQXJvdW5kKGV2ZW50LnRhcmdldCk7XG5cdFx0bGV0IGNlbGwgPSAtMTtcblx0XHRpZiAodGFyZ2V0KSB7XG5cdFx0XHRjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRpZiAoZXZlbnQuY2xpZW50WCAtIGxlZnQgPD0gaGFuZGxlV2lkdGgpIGNlbGwgPSBlZGdlQ2VsbCh2aWV3LCBldmVudCwgXCJsZWZ0XCIsIGhhbmRsZVdpZHRoKTtcblx0XHRcdGVsc2UgaWYgKHJpZ2h0IC0gZXZlbnQuY2xpZW50WCA8PSBoYW5kbGVXaWR0aCkgY2VsbCA9IGVkZ2VDZWxsKHZpZXcsIGV2ZW50LCBcInJpZ2h0XCIsIGhhbmRsZVdpZHRoKTtcblx0XHR9XG5cdFx0aWYgKGNlbGwgIT0gcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlKSB7XG5cdFx0XHRpZiAoIWxhc3RDb2x1bW5SZXNpemFibGUgJiYgY2VsbCAhPT0gLTEpIHtcblx0XHRcdFx0Y29uc3QgJGNlbGwgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGNlbGwpO1xuXHRcdFx0XHRjb25zdCB0YWJsZSA9ICRjZWxsLm5vZGUoLTEpO1xuXHRcdFx0XHRjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuXHRcdFx0XHRjb25zdCB0YWJsZVN0YXJ0ID0gJGNlbGwuc3RhcnQoLTEpO1xuXHRcdFx0XHRpZiAobWFwLmNvbENvdW50KCRjZWxsLnBvcyAtIHRhYmxlU3RhcnQpICsgJGNlbGwubm9kZUFmdGVyLmF0dHJzLmNvbHNwYW4gLSAxID09IG1hcC53aWR0aCAtIDEpIHJldHVybjtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZUhhbmRsZSh2aWV3LCBjZWxsKTtcblx0XHR9XG5cdH1cbn1cbmZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUodmlldykge1xuXHRpZiAoIXZpZXcuZWRpdGFibGUpIHJldHVybjtcblx0Y29uc3QgcGx1Z2luU3RhdGUgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcblx0aWYgKHBsdWdpblN0YXRlICYmIHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSA+IC0xICYmICFwbHVnaW5TdGF0ZS5kcmFnZ2luZykgdXBkYXRlSGFuZGxlKHZpZXcsIC0xKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bih2aWV3LCBldmVudCwgY2VsbE1pbldpZHRoLCBkZWZhdWx0Q2VsbE1pbldpZHRoKSB7XG5cdHZhciBfdmlldyRkb20kb3duZXJEb2N1bWU7XG5cdGlmICghdmlldy5lZGl0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCB3aW4gPSAoX3ZpZXckZG9tJG93bmVyRG9jdW1lID0gdmlldy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgIT09IG51bGwgJiYgX3ZpZXckZG9tJG93bmVyRG9jdW1lICE9PSB2b2lkIDAgPyBfdmlldyRkb20kb3duZXJEb2N1bWUgOiB3aW5kb3c7XG5cdGNvbnN0IHBsdWdpblN0YXRlID0gY29sdW1uUmVzaXppbmdQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG5cdGlmICghcGx1Z2luU3RhdGUgfHwgcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlID09IC0xIHx8IHBsdWdpblN0YXRlLmRyYWdnaW5nKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IGNlbGwgPSB2aWV3LnN0YXRlLmRvYy5ub2RlQXQocGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlKTtcblx0Y29uc3Qgd2lkdGggPSBjdXJyZW50Q29sV2lkdGgodmlldywgcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlLCBjZWxsLmF0dHJzKTtcblx0dmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldE1ldGEoY29sdW1uUmVzaXppbmdQbHVnaW5LZXksIHsgc2V0RHJhZ2dpbmc6IHtcblx0XHRzdGFydFg6IGV2ZW50LmNsaWVudFgsXG5cdFx0c3RhcnRXaWR0aDogd2lkdGhcblx0fSB9KSk7XG5cdGZ1bmN0aW9uIGZpbmlzaChldmVudCQxKSB7XG5cdFx0d2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGZpbmlzaCk7XG5cdFx0d2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG5cdFx0Y29uc3QgcGx1Z2luU3RhdGUkMSA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuXHRcdGlmIChwbHVnaW5TdGF0ZSQxID09PSBudWxsIHx8IHBsdWdpblN0YXRlJDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBsdWdpblN0YXRlJDEuZHJhZ2dpbmcpIHtcblx0XHRcdHVwZGF0ZUNvbHVtbldpZHRoKHZpZXcsIHBsdWdpblN0YXRlJDEuYWN0aXZlSGFuZGxlLCBkcmFnZ2VkV2lkdGgocGx1Z2luU3RhdGUkMS5kcmFnZ2luZywgZXZlbnQkMSwgY2VsbE1pbldpZHRoKSk7XG5cdFx0XHR2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0TWV0YShjb2x1bW5SZXNpemluZ1BsdWdpbktleSwgeyBzZXREcmFnZ2luZzogbnVsbCB9KSk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG1vdmUoZXZlbnQkMSkge1xuXHRcdGlmICghZXZlbnQkMS53aGljaCkgcmV0dXJuIGZpbmlzaChldmVudCQxKTtcblx0XHRjb25zdCBwbHVnaW5TdGF0ZSQxID0gY29sdW1uUmVzaXppbmdQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG5cdFx0aWYgKCFwbHVnaW5TdGF0ZSQxKSByZXR1cm47XG5cdFx0aWYgKHBsdWdpblN0YXRlJDEuZHJhZ2dpbmcpIHtcblx0XHRcdGNvbnN0IGRyYWdnZWQgPSBkcmFnZ2VkV2lkdGgocGx1Z2luU3RhdGUkMS5kcmFnZ2luZywgZXZlbnQkMSwgY2VsbE1pbldpZHRoKTtcblx0XHRcdGRpc3BsYXlDb2x1bW5XaWR0aCh2aWV3LCBwbHVnaW5TdGF0ZSQxLmFjdGl2ZUhhbmRsZSwgZHJhZ2dlZCwgZGVmYXVsdENlbGxNaW5XaWR0aCk7XG5cdFx0fVxuXHR9XG5cdGRpc3BsYXlDb2x1bW5XaWR0aCh2aWV3LCBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUsIHdpZHRoLCBkZWZhdWx0Q2VsbE1pbldpZHRoKTtcblx0d2luLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGZpbmlzaCk7XG5cdHdpbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRyZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGN1cnJlbnRDb2xXaWR0aCh2aWV3LCBjZWxsUG9zLCB7IGNvbHNwYW4sIGNvbHdpZHRoIH0pIHtcblx0Y29uc3Qgd2lkdGggPSBjb2x3aWR0aCAmJiBjb2x3aWR0aFtjb2x3aWR0aC5sZW5ndGggLSAxXTtcblx0aWYgKHdpZHRoKSByZXR1cm4gd2lkdGg7XG5cdGNvbnN0IGRvbSA9IHZpZXcuZG9tQXRQb3MoY2VsbFBvcyk7XG5cdGxldCBkb21XaWR0aCA9IGRvbS5ub2RlLmNoaWxkTm9kZXNbZG9tLm9mZnNldF0ub2Zmc2V0V2lkdGgsIHBhcnRzID0gY29sc3Bhbjtcblx0aWYgKGNvbHdpZHRoKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzcGFuOyBpKyspIGlmIChjb2x3aWR0aFtpXSkge1xuXHRcdFx0ZG9tV2lkdGggLT0gY29sd2lkdGhbaV07XG5cdFx0XHRwYXJ0cy0tO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZG9tV2lkdGggLyBwYXJ0cztcbn1cbmZ1bmN0aW9uIGRvbUNlbGxBcm91bmQodGFyZ2V0KSB7XG5cdHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0Lm5vZGVOYW1lICE9IFwiVERcIiAmJiB0YXJnZXQubm9kZU5hbWUgIT0gXCJUSFwiKSB0YXJnZXQgPSB0YXJnZXQuY2xhc3NMaXN0ICYmIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJQcm9zZU1pcnJvclwiKSA/IG51bGwgOiB0YXJnZXQucGFyZW50Tm9kZTtcblx0cmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGVkZ2VDZWxsKHZpZXcsIGV2ZW50LCBzaWRlLCBoYW5kbGVXaWR0aCkge1xuXHRjb25zdCBvZmZzZXQgPSBzaWRlID09IFwicmlnaHRcIiA/IC1oYW5kbGVXaWR0aCA6IGhhbmRsZVdpZHRoO1xuXHRjb25zdCBmb3VuZCA9IHZpZXcucG9zQXRDb29yZHMoe1xuXHRcdGxlZnQ6IGV2ZW50LmNsaWVudFggKyBvZmZzZXQsXG5cdFx0dG9wOiBldmVudC5jbGllbnRZXG5cdH0pO1xuXHRpZiAoIWZvdW5kKSByZXR1cm4gLTE7XG5cdGNvbnN0IHsgcG9zIH0gPSBmb3VuZDtcblx0Y29uc3QgJGNlbGwgPSBjZWxsQXJvdW5kKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKSk7XG5cdGlmICghJGNlbGwpIHJldHVybiAtMTtcblx0aWYgKHNpZGUgPT0gXCJyaWdodFwiKSByZXR1cm4gJGNlbGwucG9zO1xuXHRjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQoJGNlbGwubm9kZSgtMSkpLCBzdGFydCA9ICRjZWxsLnN0YXJ0KC0xKTtcblx0Y29uc3QgaW5kZXggPSBtYXAubWFwLmluZGV4T2YoJGNlbGwucG9zIC0gc3RhcnQpO1xuXHRyZXR1cm4gaW5kZXggJSBtYXAud2lkdGggPT0gMCA/IC0xIDogc3RhcnQgKyBtYXAubWFwW2luZGV4IC0gMV07XG59XG5mdW5jdGlvbiBkcmFnZ2VkV2lkdGgoZHJhZ2dpbmcsIGV2ZW50LCByZXNpemVNaW5XaWR0aCkge1xuXHRjb25zdCBvZmZzZXQgPSBldmVudC5jbGllbnRYIC0gZHJhZ2dpbmcuc3RhcnRYO1xuXHRyZXR1cm4gTWF0aC5tYXgocmVzaXplTWluV2lkdGgsIGRyYWdnaW5nLnN0YXJ0V2lkdGggKyBvZmZzZXQpO1xufVxuZnVuY3Rpb24gdXBkYXRlSGFuZGxlKHZpZXcsIHZhbHVlKSB7XG5cdHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRNZXRhKGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LCB7IHNldEhhbmRsZTogdmFsdWUgfSkpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29sdW1uV2lkdGgodmlldywgY2VsbCwgd2lkdGgpIHtcblx0Y29uc3QgJGNlbGwgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGNlbGwpO1xuXHRjb25zdCB0YWJsZSA9ICRjZWxsLm5vZGUoLTEpLCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpLCBzdGFydCA9ICRjZWxsLnN0YXJ0KC0xKTtcblx0Y29uc3QgY29sID0gbWFwLmNvbENvdW50KCRjZWxsLnBvcyAtIHN0YXJ0KSArICRjZWxsLm5vZGVBZnRlci5hdHRycy5jb2xzcGFuIC0gMTtcblx0Y29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyO1xuXHRmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyByb3crKykge1xuXHRcdGNvbnN0IG1hcEluZGV4ID0gcm93ICogbWFwLndpZHRoICsgY29sO1xuXHRcdGlmIChyb3cgJiYgbWFwLm1hcFttYXBJbmRleF0gPT0gbWFwLm1hcFttYXBJbmRleCAtIG1hcC53aWR0aF0pIGNvbnRpbnVlO1xuXHRcdGNvbnN0IHBvcyA9IG1hcC5tYXBbbWFwSW5kZXhdO1xuXHRcdGNvbnN0IGF0dHJzID0gdGFibGUubm9kZUF0KHBvcykuYXR0cnM7XG5cdFx0Y29uc3QgaW5kZXggPSBhdHRycy5jb2xzcGFuID09IDEgPyAwIDogY29sIC0gbWFwLmNvbENvdW50KHBvcyk7XG5cdFx0aWYgKGF0dHJzLmNvbHdpZHRoICYmIGF0dHJzLmNvbHdpZHRoW2luZGV4XSA9PSB3aWR0aCkgY29udGludWU7XG5cdFx0Y29uc3QgY29sd2lkdGggPSBhdHRycy5jb2x3aWR0aCA/IGF0dHJzLmNvbHdpZHRoLnNsaWNlKCkgOiB6ZXJvZXMoYXR0cnMuY29sc3Bhbik7XG5cdFx0Y29sd2lkdGhbaW5kZXhdID0gd2lkdGg7XG5cdFx0dHIuc2V0Tm9kZU1hcmt1cChzdGFydCArIHBvcywgbnVsbCwge1xuXHRcdFx0Li4uYXR0cnMsXG5cdFx0XHRjb2x3aWR0aFxuXHRcdH0pO1xuXHR9XG5cdGlmICh0ci5kb2NDaGFuZ2VkKSB2aWV3LmRpc3BhdGNoKHRyKTtcbn1cbmZ1bmN0aW9uIGRpc3BsYXlDb2x1bW5XaWR0aCh2aWV3LCBjZWxsLCB3aWR0aCwgZGVmYXVsdENlbGxNaW5XaWR0aCkge1xuXHRjb25zdCAkY2VsbCA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoY2VsbCk7XG5cdGNvbnN0IHRhYmxlID0gJGNlbGwubm9kZSgtMSksIHN0YXJ0ID0gJGNlbGwuc3RhcnQoLTEpO1xuXHRjb25zdCBjb2wgPSBUYWJsZU1hcC5nZXQodGFibGUpLmNvbENvdW50KCRjZWxsLnBvcyAtIHN0YXJ0KSArICRjZWxsLm5vZGVBZnRlci5hdHRycy5jb2xzcGFuIC0gMTtcblx0bGV0IGRvbSA9IHZpZXcuZG9tQXRQb3MoJGNlbGwuc3RhcnQoLTEpKS5ub2RlO1xuXHR3aGlsZSAoZG9tICYmIGRvbS5ub2RlTmFtZSAhPSBcIlRBQkxFXCIpIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuXHRpZiAoIWRvbSkgcmV0dXJuO1xuXHR1cGRhdGVDb2x1bW5zT25SZXNpemUodGFibGUsIGRvbS5maXJzdENoaWxkLCBkb20sIGRlZmF1bHRDZWxsTWluV2lkdGgsIGNvbCwgd2lkdGgpO1xufVxuZnVuY3Rpb24gemVyb2VzKG4pIHtcblx0cmV0dXJuIEFycmF5KG4pLmZpbGwoMCk7XG59XG5mdW5jdGlvbiBoYW5kbGVEZWNvcmF0aW9ucyhzdGF0ZSwgY2VsbCkge1xuXHRjb25zdCBkZWNvcmF0aW9ucyA9IFtdO1xuXHRjb25zdCAkY2VsbCA9IHN0YXRlLmRvYy5yZXNvbHZlKGNlbGwpO1xuXHRjb25zdCB0YWJsZSA9ICRjZWxsLm5vZGUoLTEpO1xuXHRpZiAoIXRhYmxlKSByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eTtcblx0Y29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcblx0Y29uc3Qgc3RhcnQgPSAkY2VsbC5zdGFydCgtMSk7XG5cdGNvbnN0IGNvbCA9IG1hcC5jb2xDb3VudCgkY2VsbC5wb3MgLSBzdGFydCkgKyAkY2VsbC5ub2RlQWZ0ZXIuYXR0cnMuY29sc3BhbiAtIDE7XG5cdGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1hcC5oZWlnaHQ7IHJvdysrKSB7XG5cdFx0Y29uc3QgaW5kZXggPSBjb2wgKyByb3cgKiBtYXAud2lkdGg7XG5cdFx0aWYgKChjb2wgPT0gbWFwLndpZHRoIC0gMSB8fCBtYXAubWFwW2luZGV4XSAhPSBtYXAubWFwW2luZGV4ICsgMV0pICYmIChyb3cgPT0gMCB8fCBtYXAubWFwW2luZGV4XSAhPSBtYXAubWFwW2luZGV4IC0gbWFwLndpZHRoXSkpIHtcblx0XHRcdHZhciBfY29sdW1uUmVzaXppbmdQbHVnaW47XG5cdFx0XHRjb25zdCBjZWxsUG9zID0gbWFwLm1hcFtpbmRleF07XG5cdFx0XHRjb25zdCBwb3MgPSBzdGFydCArIGNlbGxQb3MgKyB0YWJsZS5ub2RlQXQoY2VsbFBvcykubm9kZVNpemUgLSAxO1xuXHRcdFx0Y29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdGRvbS5jbGFzc05hbWUgPSBcImNvbHVtbi1yZXNpemUtaGFuZGxlXCI7XG5cdFx0XHRpZiAoKF9jb2x1bW5SZXNpemluZ1BsdWdpbiA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKSkgPT09IG51bGwgfHwgX2NvbHVtblJlc2l6aW5nUGx1Z2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sdW1uUmVzaXppbmdQbHVnaW4uZHJhZ2dpbmcpIGRlY29yYXRpb25zLnB1c2goRGVjb3JhdGlvbi5ub2RlKHN0YXJ0ICsgY2VsbFBvcywgc3RhcnQgKyBjZWxsUG9zICsgdGFibGUubm9kZUF0KGNlbGxQb3MpLm5vZGVTaXplLCB7IGNsYXNzOiBcImNvbHVtbi1yZXNpemUtZHJhZ2dpbmdcIiB9KSk7XG5cdFx0XHRkZWNvcmF0aW9ucy5wdXNoKERlY29yYXRpb24ud2lkZ2V0KHBvcywgZG9tKSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIGRlY29yYXRpb25zKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2luZGV4LnRzXG4vKipcbiogQ3JlYXRlcyBhIFtwbHVnaW5dKGh0dHA6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpbilcbiogdGhhdCwgd2hlbiBhZGRlZCB0byBhbiBlZGl0b3IsIGVuYWJsZXMgY2VsbC1zZWxlY3Rpb24sIGhhbmRsZXNcbiogY2VsbC1iYXNlZCBjb3B5L3Bhc3RlLCBhbmQgbWFrZXMgc3VyZSB0YWJsZXMgc3RheSB3ZWxsLWZvcm1lZCAoZWFjaFxuKiByb3cgaGFzIHRoZSBzYW1lIHdpZHRoLCBhbmQgY2VsbHMgZG9uJ3Qgb3ZlcmxhcCkuXG4qXG4qIFlvdSBzaG91bGQgcHJvYmFibHkgcHV0IHRoaXMgcGx1Z2luIG5lYXIgdGhlIGVuZCBvZiB5b3VyIGFycmF5IG9mXG4qIHBsdWdpbnMsIHNpbmNlIGl0IGhhbmRsZXMgbW91c2UgYW5kIGFycm93IGtleSBldmVudHMgaW4gdGFibGVzXG4qIHJhdGhlciBicm9hZGx5LCBhbmQgb3RoZXIgcGx1Z2lucywgbGlrZSB0aGUgZ2FwIGN1cnNvciBvciB0aGVcbiogY29sdW1uLXdpZHRoIGRyYWdnaW5nIHBsdWdpbiwgbWlnaHQgd2FudCB0byBnZXQgYSB0dXJuIGZpcnN0IHRvXG4qIHBlcmZvcm0gbW9yZSBzcGVjaWZpYyBiZWhhdmlvci5cbipcbiogQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIHRhYmxlRWRpdGluZyh7IGFsbG93VGFibGVOb2RlU2VsZWN0aW9uID0gZmFsc2UgfSA9IHt9KSB7XG5cdHJldHVybiBuZXcgUGx1Z2luKHtcblx0XHRrZXk6IHRhYmxlRWRpdGluZ0tleSxcblx0XHRzdGF0ZToge1xuXHRcdFx0aW5pdCgpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9LFxuXHRcdFx0YXBwbHkodHIsIGN1cikge1xuXHRcdFx0XHRjb25zdCBzZXQgPSB0ci5nZXRNZXRhKHRhYmxlRWRpdGluZ0tleSk7XG5cdFx0XHRcdGlmIChzZXQgIT0gbnVsbCkgcmV0dXJuIHNldCA9PSAtMSA/IG51bGwgOiBzZXQ7XG5cdFx0XHRcdGlmIChjdXIgPT0gbnVsbCB8fCAhdHIuZG9jQ2hhbmdlZCkgcmV0dXJuIGN1cjtcblx0XHRcdFx0Y29uc3QgeyBkZWxldGVkLCBwb3MgfSA9IHRyLm1hcHBpbmcubWFwUmVzdWx0KGN1cik7XG5cdFx0XHRcdHJldHVybiBkZWxldGVkID8gbnVsbCA6IHBvcztcblx0XHRcdH1cblx0XHR9LFxuXHRcdHByb3BzOiB7XG5cdFx0XHRkZWNvcmF0aW9uczogZHJhd0NlbGxTZWxlY3Rpb24sXG5cdFx0XHRoYW5kbGVET01FdmVudHM6IHsgbW91c2Vkb3duOiBoYW5kbGVNb3VzZURvd24kMSB9LFxuXHRcdFx0Y3JlYXRlU2VsZWN0aW9uQmV0d2Vlbih2aWV3KSB7XG5cdFx0XHRcdHJldHVybiB0YWJsZUVkaXRpbmdLZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSkgIT0gbnVsbCA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uIDogbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVUcmlwbGVDbGljayxcblx0XHRcdGhhbmRsZUtleURvd24sXG5cdFx0XHRoYW5kbGVQYXN0ZVxuXHRcdH0sXG5cdFx0YXBwZW5kVHJhbnNhY3Rpb24oXywgb2xkU3RhdGUsIHN0YXRlKSB7XG5cdFx0XHRyZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKHN0YXRlLCBmaXhUYWJsZXMoc3RhdGUsIG9sZFN0YXRlKSwgYWxsb3dUYWJsZU5vZGVTZWxlY3Rpb24pO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgQ2VsbEJvb2ttYXJrLCBDZWxsU2VsZWN0aW9uLCBSZXNpemVTdGF0ZSwgVGFibGVNYXAsIFRhYmxlVmlldywgY2xpcENlbGxzIGFzIF9fY2xpcENlbGxzLCBpbnNlcnRDZWxscyBhcyBfX2luc2VydENlbGxzLCBwYXN0ZWRDZWxscyBhcyBfX3Bhc3RlZENlbGxzLCBhZGRDb2xTcGFuLCBhZGRDb2x1bW4sIGFkZENvbHVtbkFmdGVyLCBhZGRDb2x1bW5CZWZvcmUsIGFkZFJvdywgYWRkUm93QWZ0ZXIsIGFkZFJvd0JlZm9yZSwgY2VsbEFyb3VuZCwgY2VsbE5lYXIsIGNvbENvdW50LCBjb2x1bW5Jc0hlYWRlciwgY29sdW1uUmVzaXppbmcsIGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LCBkZWxldGVDZWxsU2VsZWN0aW9uLCBkZWxldGVDb2x1bW4sIGRlbGV0ZVJvdywgZGVsZXRlVGFibGUsIGZpbmRDZWxsLCBmaW5kQ2VsbFBvcywgZmluZENlbGxSYW5nZSwgZmluZFRhYmxlLCBmaXhUYWJsZXMsIGZpeFRhYmxlc0tleSwgZ29Ub05leHRDZWxsLCBoYW5kbGVQYXN0ZSwgaW5TYW1lVGFibGUsIGlzSW5UYWJsZSwgbWVyZ2VDZWxscywgbW92ZUNlbGxGb3J3YXJkLCBtb3ZlVGFibGVDb2x1bW4sIG1vdmVUYWJsZVJvdywgbmV4dENlbGwsIHBvaW50c0F0Q2VsbCwgcmVtb3ZlQ29sU3BhbiwgcmVtb3ZlQ29sdW1uLCByZW1vdmVSb3csIHJvd0lzSGVhZGVyLCBzZWxlY3RlZFJlY3QsIHNlbGVjdGlvbkNlbGwsIHNldENlbGxBdHRyLCBzcGxpdENlbGwsIHNwbGl0Q2VsbFdpdGhUeXBlLCB0YWJsZUVkaXRpbmcsIHRhYmxlRWRpdGluZ0tleSwgdGFibGVOb2RlVHlwZXMsIHRhYmxlTm9kZXMsIHRvZ2dsZUhlYWRlciwgdG9nZ2xlSGVhZGVyQ2VsbCwgdG9nZ2xlSGVhZGVyQ29sdW1uLCB0b2dnbGVIZWFkZXJSb3csIHVwZGF0ZUNvbHVtbnNPblJlc2l6ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/prosemirror-tables@1.8.5/node_modules/prosemirror-tables/dist/index.js\n");

/***/ })

};
;