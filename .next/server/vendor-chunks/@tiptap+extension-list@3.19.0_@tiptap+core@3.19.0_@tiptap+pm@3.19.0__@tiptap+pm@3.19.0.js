"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap+extension-list@3.19.0_@tiptap+core@3.19.0_@tiptap+pm@3.19.0__@tiptap+pm@3.19.0";
exports.ids = ["vendor-chunks/@tiptap+extension-list@3.19.0_@tiptap+core@3.19.0_@tiptap+pm@3.19.0__@tiptap+pm@3.19.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@tiptap+extension-list@3.19.0_@tiptap+core@3.19.0_@tiptap+pm@3.19.0__@tiptap+pm@3.19.0/node_modules/@tiptap/extension-list/dist/index.js":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tiptap+extension-list@3.19.0_@tiptap+core@3.19.0_@tiptap+pm@3.19.0__@tiptap+pm@3.19.0/node_modules/@tiptap/extension-list/dist/index.js ***!
  \*********************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BulletList: () => (/* binding */ BulletList),\n/* harmony export */   ListItem: () => (/* binding */ ListItem),\n/* harmony export */   ListKeymap: () => (/* binding */ ListKeymap),\n/* harmony export */   ListKit: () => (/* binding */ ListKit),\n/* harmony export */   OrderedList: () => (/* binding */ OrderedList),\n/* harmony export */   TaskItem: () => (/* binding */ TaskItem),\n/* harmony export */   TaskList: () => (/* binding */ TaskList),\n/* harmony export */   bulletListInputRegex: () => (/* binding */ bulletListInputRegex),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   listHelpers: () => (/* binding */ listHelpers_exports),\n/* harmony export */   orderedListInputRegex: () => (/* binding */ orderedListInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/.pnpm/@tiptap+core@3.19.0_@tiptap+pm@3.19.0/node_modules/@tiptap/core/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/bullet-list/bullet-list.ts\n\nvar ListItemName = \"listItem\";\nvar TextStyleName = \"textStyle\";\nvar bulletListInputRegex = /^\\s*([-+*])\\s$/;\nvar BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"bulletList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [{ tag: \"ul\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"ul\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list\" || token.ordered) {\n      return [];\n    }\n    return {\n      type: \"bulletList\",\n      content: token.items ? helpers.parseChildren(token.items) : []\n    };\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleBulletList: () => ({ commands, chain }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-8\": () => this.editor.commands.toggleBulletList()\n    };\n  },\n  addInputRules() {\n    let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n      find: bulletListInputRegex,\n      type: this.type\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName);\n        },\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/item/list-item.ts\n\nvar ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"listItem\",\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: \"bulletList\",\n      orderedListTypeName: \"orderedList\"\n    };\n  },\n  content: \"paragraph block*\",\n  defining: true,\n  parseHTML() {\n    return [\n      {\n        tag: \"li\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"li\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list_item\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list_item\") {\n      return [];\n    }\n    let content = [];\n    if (token.tokens && token.tokens.length > 0) {\n      const hasParagraphTokens = token.tokens.some((t) => t.type === \"paragraph\");\n      if (hasParagraphTokens) {\n        content = helpers.parseChildren(token.tokens);\n      } else {\n        const firstToken = token.tokens[0];\n        if (firstToken && firstToken.type === \"text\" && firstToken.tokens && firstToken.tokens.length > 0) {\n          const inlineContent = helpers.parseInline(firstToken.tokens);\n          content = [\n            {\n              type: \"paragraph\",\n              content: inlineContent\n            }\n          ];\n          if (token.tokens.length > 1) {\n            const remainingTokens = token.tokens.slice(1);\n            const additionalContent = helpers.parseChildren(remainingTokens);\n            content.push(...additionalContent);\n          }\n        } else {\n          content = helpers.parseChildren(token.tokens);\n        }\n      }\n    }\n    if (content.length === 0) {\n      content = [\n        {\n          type: \"paragraph\",\n          content: []\n        }\n      ];\n    }\n    return {\n      type: \"listItem\",\n      content\n    };\n  },\n  renderMarkdown: (node, h, ctx) => {\n    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.renderNestedMarkdownContent)(\n      node,\n      h,\n      (context) => {\n        var _a, _b;\n        if (context.parentType === \"bulletList\") {\n          return \"- \";\n        }\n        if (context.parentType === \"orderedList\") {\n          const start = ((_b = (_a = context.meta) == null ? void 0 : _a.parentAttrs) == null ? void 0 : _b.start) || 1;\n          return `${start + context.index}. `;\n        }\n        return \"- \";\n      },\n      ctx\n    );\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n  }\n});\n\n// src/keymap/list-keymap.ts\n\n\n// src/keymap/listHelpers/index.ts\nvar listHelpers_exports = {};\n__export(listHelpers_exports, {\n  findListItemPos: () => findListItemPos,\n  getNextListDepth: () => getNextListDepth,\n  handleBackspace: () => handleBackspace,\n  handleDelete: () => handleDelete,\n  hasListBefore: () => hasListBefore,\n  hasListItemAfter: () => hasListItemAfter,\n  hasListItemBefore: () => hasListItemBefore,\n  listItemHasSubList: () => listItemHasSubList,\n  nextListIsDeeper: () => nextListIsDeeper,\n  nextListIsHigher: () => nextListIsHigher\n});\n\n// src/keymap/listHelpers/findListItemPos.ts\n\nvar findListItemPos = (typeOrName, state) => {\n  const { $from } = state.selection;\n  const nodeType = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeType)(typeOrName, state.schema);\n  let currentNode = null;\n  let currentDepth = $from.depth;\n  let currentPos = $from.pos;\n  let targetDepth = null;\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth);\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth;\n    } else {\n      currentDepth -= 1;\n      currentPos -= 1;\n    }\n  }\n  if (targetDepth === null) {\n    return null;\n  }\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth };\n};\n\n// src/keymap/listHelpers/getNextListDepth.ts\n\nvar getNextListDepth = (typeOrName, state) => {\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos) {\n    return false;\n  }\n  const [, depth] = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeAtPosition)(state, typeOrName, listItemPos.$pos.pos + 4);\n  return depth;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\n\n\n// src/keymap/listHelpers/hasListBefore.ts\nvar hasListBefore = (editorState, name, parentListTypes) => {\n  const { $anchor } = editorState.selection;\n  const previousNodePos = Math.max(0, $anchor.pos - 2);\n  const previousNode = editorState.doc.resolve(previousNodePos).node();\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/hasListItemBefore.ts\nvar hasListItemBefore = (typeOrName, state) => {\n  var _a;\n  const { $anchor } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - 2);\n  if ($targetPos.index() === 0) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeBefore) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/listItemHasSubList.ts\n\nvar listItemHasSubList = (typeOrName, state, node) => {\n  if (!node) {\n    return false;\n  }\n  const nodeType = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeType)(typeOrName, state.schema);\n  let hasSubList = false;\n  node.descendants((child) => {\n    if (child.type === nodeType) {\n      hasSubList = true;\n    }\n  });\n  return hasSubList;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\nvar handleBackspace = (editor, name, parentListTypes) => {\n  if (editor.commands.undoInputRule()) {\n    return true;\n  }\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection;\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1);\n    const listDescendants = [];\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos });\n      }\n    });\n    const lastItem = listDescendants.at(-1);\n    if (!lastItem) {\n      return false;\n    }\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);\n    return editor.chain().cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end()).joinForward().run();\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name)) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtStartOfNode)(editor.state)) {\n    return false;\n  }\n  const listItemPos = findListItemPos(name, editor.state);\n  if (!listItemPos) {\n    return false;\n  }\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);\n  const prevNode = $prev.node(listItemPos.depth);\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward();\n  }\n  return editor.chain().liftListItem(name).run();\n};\n\n// src/keymap/listHelpers/handleDelete.ts\n\n\n// src/keymap/listHelpers/nextListIsDeeper.ts\nvar nextListIsDeeper = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth > listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/nextListIsHigher.ts\nvar nextListIsHigher = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth < listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/handleDelete.ts\nvar handleDelete = (editor, name) => {\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name)) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtEndOfNode)(editor.state, name)) {\n    return false;\n  }\n  const { selection } = editor.state;\n  const { $from, $to } = selection;\n  if (!selection.empty && $from.sameParent($to)) {\n    return false;\n  }\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();\n  }\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run();\n  }\n  return editor.commands.joinItemForward();\n};\n\n// src/keymap/listHelpers/hasListItemAfter.ts\nvar hasListItemAfter = (typeOrName, state) => {\n  var _a;\n  const { $anchor } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeAfter) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/list-keymap.ts\nvar ListKeymap = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"listKeymap\",\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: \"listItem\",\n          wrapperNames: [\"bulletList\", \"orderedList\"]\n        },\n        {\n          itemName: \"taskItem\",\n          wrapperNames: [\"taskList\"]\n        }\n      ]\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Delete\": ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      Backspace: ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Backspace\": ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      }\n    };\n  }\n});\n\n// src/kit/index.ts\n\n\n// src/ordered-list/ordered-list.ts\n\n\n// src/ordered-list/utils.ts\nvar ORDERED_LIST_ITEM_REGEX = /^(\\s*)(\\d+)\\.\\s+(.*)$/;\nvar INDENTED_LINE_REGEX = /^\\s/;\nfunction collectOrderedListItems(lines) {\n  const listItems = [];\n  let currentLineIndex = 0;\n  let consumed = 0;\n  while (currentLineIndex < lines.length) {\n    const line = lines[currentLineIndex];\n    const match = line.match(ORDERED_LIST_ITEM_REGEX);\n    if (!match) {\n      break;\n    }\n    const [, indent, number, content] = match;\n    const indentLevel = indent.length;\n    let itemContent = content;\n    let nextLineIndex = currentLineIndex + 1;\n    const itemLines = [line];\n    while (nextLineIndex < lines.length) {\n      const nextLine = lines[nextLineIndex];\n      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX);\n      if (nextMatch) {\n        break;\n      }\n      if (nextLine.trim() === \"\") {\n        itemLines.push(nextLine);\n        itemContent += \"\\n\";\n        nextLineIndex += 1;\n      } else if (nextLine.match(INDENTED_LINE_REGEX)) {\n        itemLines.push(nextLine);\n        itemContent += `\n${nextLine.slice(indentLevel + 2)}`;\n        nextLineIndex += 1;\n      } else {\n        break;\n      }\n    }\n    listItems.push({\n      indent: indentLevel,\n      number: parseInt(number, 10),\n      content: itemContent.trim(),\n      raw: itemLines.join(\"\\n\")\n    });\n    consumed = nextLineIndex;\n    currentLineIndex = nextLineIndex;\n  }\n  return [listItems, consumed];\n}\nfunction buildNestedStructure(items, baseIndent, lexer) {\n  var _a;\n  const result = [];\n  let currentIndex = 0;\n  while (currentIndex < items.length) {\n    const item = items[currentIndex];\n    if (item.indent === baseIndent) {\n      const contentLines = item.content.split(\"\\n\");\n      const mainText = ((_a = contentLines[0]) == null ? void 0 : _a.trim()) || \"\";\n      const tokens = [];\n      if (mainText) {\n        tokens.push({\n          type: \"paragraph\",\n          raw: mainText,\n          tokens: lexer.inlineTokens(mainText)\n        });\n      }\n      const additionalContent = contentLines.slice(1).join(\"\\n\").trim();\n      if (additionalContent) {\n        const blockTokens = lexer.blockTokens(additionalContent);\n        tokens.push(...blockTokens);\n      }\n      let lookAheadIndex = currentIndex + 1;\n      const nestedItems = [];\n      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {\n        nestedItems.push(items[lookAheadIndex]);\n        lookAheadIndex += 1;\n      }\n      if (nestedItems.length > 0) {\n        const nextIndent = Math.min(...nestedItems.map((nestedItem) => nestedItem.indent));\n        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer);\n        tokens.push({\n          type: \"list\",\n          ordered: true,\n          start: nestedItems[0].number,\n          items: nestedListItems,\n          raw: nestedItems.map((nestedItem) => nestedItem.raw).join(\"\\n\")\n        });\n      }\n      result.push({\n        type: \"list_item\",\n        raw: item.raw,\n        tokens\n      });\n      currentIndex = lookAheadIndex;\n    } else {\n      currentIndex += 1;\n    }\n  }\n  return result;\n}\nfunction parseListItems(items, helpers) {\n  return items.map((item) => {\n    if (item.type !== \"list_item\") {\n      return helpers.parseChildren([item])[0];\n    }\n    const content = [];\n    if (item.tokens && item.tokens.length > 0) {\n      item.tokens.forEach((itemToken) => {\n        if (itemToken.type === \"paragraph\" || itemToken.type === \"list\" || itemToken.type === \"blockquote\" || itemToken.type === \"code\") {\n          content.push(...helpers.parseChildren([itemToken]));\n        } else if (itemToken.type === \"text\" && itemToken.tokens) {\n          const inlineContent = helpers.parseChildren([itemToken]);\n          content.push({\n            type: \"paragraph\",\n            content: inlineContent\n          });\n        } else {\n          const parsed = helpers.parseChildren([itemToken]);\n          if (parsed.length > 0) {\n            content.push(...parsed);\n          }\n        }\n      });\n    }\n    return {\n      type: \"listItem\",\n      content\n    };\n  });\n}\n\n// src/ordered-list/ordered-list.ts\nvar ListItemName2 = \"listItem\";\nvar TextStyleName2 = \"textStyle\";\nvar orderedListInputRegex = /^(\\d+)\\.\\s$/;\nvar OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"orderedList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: (element) => {\n          return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n        }\n      },\n      type: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"type\")\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"ol\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes;\n    return start === 1 ? [\"ol\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart), 0] : [\"ol\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list\" || !token.ordered) {\n      return [];\n    }\n    const startValue = token.start || 1;\n    const content = token.items ? parseListItems(token.items, helpers) : [];\n    if (startValue !== 1) {\n      return {\n        type: \"orderedList\",\n        attrs: { start: startValue },\n        content\n      };\n    }\n    return {\n      type: \"orderedList\",\n      content\n    };\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownTokenizer: {\n    name: \"orderedList\",\n    level: \"block\",\n    start: (src) => {\n      const match = src.match(/^(\\s*)(\\d+)\\.\\s+/);\n      const index = match == null ? void 0 : match.index;\n      return index !== void 0 ? index : -1;\n    },\n    tokenize: (src, _tokens, lexer) => {\n      var _a;\n      const lines = src.split(\"\\n\");\n      const [listItems, consumed] = collectOrderedListItems(lines);\n      if (listItems.length === 0) {\n        return void 0;\n      }\n      const items = buildNestedStructure(listItems, 0, lexer);\n      if (items.length === 0) {\n        return void 0;\n      }\n      const startValue = ((_a = listItems[0]) == null ? void 0 : _a.number) || 1;\n      return {\n        type: \"list\",\n        ordered: true,\n        start: startValue,\n        items,\n        raw: lines.slice(0, consumed).join(\"\\n\")\n      };\n    }\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleOrderedList: () => ({ commands, chain }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-7\": () => this.editor.commands.toggleOrderedList()\n    };\n  },\n  addInputRules() {\n    let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: (match) => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName2) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/task-item/task-item.ts\n\nvar inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/;\nvar TaskItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"taskItem\",\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: \"taskList\",\n      a11y: void 0\n    };\n  },\n  content() {\n    return this.options.nested ? \"paragraph block*\" : \"paragraph+\";\n  },\n  defining: true,\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: (element) => {\n          const dataChecked = element.getAttribute(\"data-checked\");\n          return dataChecked === \"\" || dataChecked === \"true\";\n        },\n        renderHTML: (attributes) => ({\n          \"data-checked\": attributes.checked\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51\n      }\n    ];\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"li\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, {\n        \"data-type\": this.name\n      }),\n      [\n        \"label\",\n        [\n          \"input\",\n          {\n            type: \"checkbox\",\n            checked: node.attrs.checked ? \"checked\" : null\n          }\n        ],\n        [\"span\"]\n      ],\n      [\"div\", 0]\n    ];\n  },\n  parseMarkdown: (token, h) => {\n    const content = [];\n    if (token.tokens && token.tokens.length > 0) {\n      content.push(h.createNode(\"paragraph\", {}, h.parseInline(token.tokens)));\n    } else if (token.text) {\n      content.push(h.createNode(\"paragraph\", {}, [h.createNode(\"text\", { text: token.text })]));\n    } else {\n      content.push(h.createNode(\"paragraph\", {}, []));\n    }\n    if (token.nestedTokens && token.nestedTokens.length > 0) {\n      const nestedContent = h.parseChildren(token.nestedTokens);\n      content.push(...nestedContent);\n    }\n    return h.createNode(\"taskItem\", { checked: token.checked || false }, content);\n  },\n  renderMarkdown: (node, h) => {\n    var _a;\n    const checkedChar = ((_a = node.attrs) == null ? void 0 : _a.checked) ? \"x\" : \" \";\n    const prefix = `- [${checkedChar}] `;\n    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.renderNestedMarkdownContent)(node, h, prefix);\n  },\n  addKeyboardShortcuts() {\n    const shortcuts = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n    if (!this.options.nested) {\n      return shortcuts;\n    }\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name)\n    };\n  },\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement(\"li\");\n      const checkboxWrapper = document.createElement(\"label\");\n      const checkboxStyler = document.createElement(\"span\");\n      const checkbox = document.createElement(\"input\");\n      const content = document.createElement(\"div\");\n      const updateA11Y = (currentNode) => {\n        var _a, _b;\n        checkbox.ariaLabel = ((_b = (_a = this.options.a11y) == null ? void 0 : _a.checkboxLabel) == null ? void 0 : _b.call(_a, currentNode, checkbox.checked)) || `Task item checkbox for ${currentNode.textContent || \"empty task item\"}`;\n      };\n      updateA11Y(node);\n      checkboxWrapper.contentEditable = \"false\";\n      checkbox.type = \"checkbox\";\n      checkbox.addEventListener(\"mousedown\", (event) => event.preventDefault());\n      checkbox.addEventListener(\"change\", (event) => {\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked;\n          return;\n        }\n        const { checked } = event.target;\n        if (editor.isEditable && typeof getPos === \"function\") {\n          editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr }) => {\n            const position = getPos();\n            if (typeof position !== \"number\") {\n              return false;\n            }\n            const currentNode = tr.doc.nodeAt(position);\n            tr.setNodeMarkup(position, void 0, {\n              ...currentNode == null ? void 0 : currentNode.attrs,\n              checked\n            });\n            return true;\n          }).run();\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked;\n          }\n        }\n      });\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      listItem.dataset.checked = node.attrs.checked;\n      checkbox.checked = node.attrs.checked;\n      checkboxWrapper.append(checkbox, checkboxStyler);\n      listItem.append(checkboxWrapper, content);\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      let prevRenderedAttributeKeys = new Set(Object.keys(HTMLAttributes));\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: (updatedNode) => {\n          if (updatedNode.type !== this.type) {\n            return false;\n          }\n          listItem.dataset.checked = updatedNode.attrs.checked;\n          checkbox.checked = updatedNode.attrs.checked;\n          updateA11Y(updatedNode);\n          const extensionAttributes = editor.extensionManager.attributes;\n          const newHTMLAttributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getRenderedAttributes)(updatedNode, extensionAttributes);\n          const newKeys = new Set(Object.keys(newHTMLAttributes));\n          const staticAttrs = this.options.HTMLAttributes;\n          prevRenderedAttributeKeys.forEach((key) => {\n            if (!newKeys.has(key)) {\n              if (key in staticAttrs) {\n                listItem.setAttribute(key, staticAttrs[key]);\n              } else {\n                listItem.removeAttribute(key);\n              }\n            }\n          });\n          Object.entries(newHTMLAttributes).forEach(([key, value]) => {\n            if (value === null || value === void 0) {\n              if (key in staticAttrs) {\n                listItem.setAttribute(key, staticAttrs[key]);\n              } else {\n                listItem.removeAttribute(key);\n              }\n            } else {\n              listItem.setAttribute(key, value);\n            }\n          });\n          prevRenderedAttributeKeys = newKeys;\n          return true;\n        }\n      };\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          checked: match[match.length - 1] === \"x\"\n        })\n      })\n    ];\n  }\n});\n\n// src/task-list/task-list.ts\n\nvar TaskList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"taskList\",\n  addOptions() {\n    return {\n      itemTypeName: \"taskItem\",\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"ul\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, { \"data-type\": this.name }), 0];\n  },\n  parseMarkdown: (token, h) => {\n    return h.createNode(\"taskList\", {}, h.parseChildren(token.items || []));\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownTokenizer: {\n    name: \"taskList\",\n    level: \"block\",\n    start(src) {\n      var _a;\n      const index = (_a = src.match(/^\\s*[-+*]\\s+\\[([ xX])\\]\\s+/)) == null ? void 0 : _a.index;\n      return index !== void 0 ? index : -1;\n    },\n    tokenize(src, tokens, lexer) {\n      const parseTaskListContent = (content) => {\n        const nestedResult = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.parseIndentedBlocks)(\n          content,\n          {\n            itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n            extractItemData: (match) => ({\n              indentLevel: match[1].length,\n              mainContent: match[4],\n              checked: match[3].toLowerCase() === \"x\"\n            }),\n            createToken: (data, nestedTokens) => ({\n              type: \"taskItem\",\n              raw: \"\",\n              mainContent: data.mainContent,\n              indentLevel: data.indentLevel,\n              checked: data.checked,\n              text: data.mainContent,\n              tokens: lexer.inlineTokens(data.mainContent),\n              nestedTokens\n            }),\n            // Allow recursive nesting\n            customNestedParser: parseTaskListContent\n          },\n          lexer\n        );\n        if (nestedResult) {\n          return [\n            {\n              type: \"taskList\",\n              raw: nestedResult.raw,\n              items: nestedResult.items\n            }\n          ];\n        }\n        return lexer.blockTokens(content);\n      };\n      const result = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.parseIndentedBlocks)(\n        src,\n        {\n          itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n          extractItemData: (match) => ({\n            indentLevel: match[1].length,\n            mainContent: match[4],\n            checked: match[3].toLowerCase() === \"x\"\n          }),\n          createToken: (data, nestedTokens) => ({\n            type: \"taskItem\",\n            raw: \"\",\n            mainContent: data.mainContent,\n            indentLevel: data.indentLevel,\n            checked: data.checked,\n            text: data.mainContent,\n            tokens: lexer.inlineTokens(data.mainContent),\n            nestedTokens\n          }),\n          // Use the recursive parser for nested content\n          customNestedParser: parseTaskListContent\n        },\n        lexer\n      );\n      if (!result) {\n        return void 0;\n      }\n      return {\n        type: \"taskList\",\n        raw: result.raw,\n        items: result.items\n      };\n    }\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleTaskList: () => ({ commands }) => {\n        return commands.toggleList(this.name, this.options.itemTypeName);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-9\": () => this.editor.commands.toggleTaskList()\n    };\n  }\n});\n\n// src/kit/index.ts\nvar ListKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"listKit\",\n  addExtensions() {\n    const extensions = [];\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList));\n    }\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem));\n    }\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap));\n    }\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList));\n    }\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem));\n    }\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList));\n    }\n    return extensions;\n  }\n});\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRpcHRhcCtleHRlbnNpb24tbGlzdEAzLjE5LjBfQHRpcHRhcCtjb3JlQDMuMTkuMF9AdGlwdGFwK3BtQDMuMTkuMF9fQHRpcHRhcCtwbUAzLjE5LjAvbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ3dFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDLEdBQUc7QUFDSDtBQUNBLGNBQWMsV0FBVztBQUN6QixHQUFHO0FBQ0gsZUFBZSxnQkFBZ0I7QUFDL0Isa0JBQWtCLDZEQUFlO0FBQ2pDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQiwrREFBaUI7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQiwrREFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDK0c7QUFDL0csZUFBZSw4Q0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFD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QUNBO0FBQ0E7QUFDQSxDQUFDO0FBYUM7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzLzFyMG5mMXN0LzFyMG5mMXN0LXdlYnNpdGUvbm9kZV9tb2R1bGVzLy5wbnBtL0B0aXB0YXArZXh0ZW5zaW9uLWxpc3RAMy4xOS4wX0B0aXB0YXArY29yZUAzLjE5LjBfQHRpcHRhcCtwbUAzLjE5LjBfX0B0aXB0YXArcG1AMy4xOS4wL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2J1bGxldC1saXN0L2J1bGxldC1saXN0LnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIExpc3RJdGVtTmFtZSA9IFwibGlzdEl0ZW1cIjtcbnZhciBUZXh0U3R5bGVOYW1lID0gXCJ0ZXh0U3R5bGVcIjtcbnZhciBidWxsZXRMaXN0SW5wdXRSZWdleCA9IC9eXFxzKihbLSsqXSlcXHMkLztcbnZhciBCdWxsZXRMaXN0ID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImJ1bGxldExpc3RcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbVR5cGVOYW1lOiBcImxpc3RJdGVtXCIsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBrZWVwTWFya3M6IGZhbHNlLFxuICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgZ3JvdXA6IFwiYmxvY2sgbGlzdFwiLFxuICBjb250ZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgO1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogXCJ1bFwiIH1dO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJ1bFwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJsaXN0XCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIGlmICh0b2tlbi50eXBlICE9PSBcImxpc3RcIiB8fCB0b2tlbi5vcmRlcmVkKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImJ1bGxldExpc3RcIixcbiAgICAgIGNvbnRlbnQ6IHRva2VuLml0ZW1zID8gaGVscGVycy5wYXJzZUNoaWxkcmVuKHRva2VuLml0ZW1zKSA6IFtdXG4gICAgfTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgaWYgKCFub2RlLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gaC5yZW5kZXJDaGlsZHJlbihub2RlLmNvbnRlbnQsIFwiXFxuXCIpO1xuICB9LFxuICBtYXJrZG93bk9wdGlvbnM6IHtcbiAgICBpbmRlbnRzQ29udGVudDogdHJ1ZVxuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlQnVsbGV0TGlzdDogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluIH0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKS51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtTmFtZSwgdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lKSkucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtU2hpZnQtOFwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCdWxsZXRMaXN0KClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICBmaW5kOiBidWxsZXRMaXN0SW5wdXRSZWdleCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE1hcmtzIHx8IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBidWxsZXRMaXN0SW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvclxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaW5wdXRSdWxlXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pdGVtL2xpc3QtaXRlbS50c1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzIGFzIG1lcmdlQXR0cmlidXRlczIsIE5vZGUgYXMgTm9kZTIsIHJlbmRlck5lc3RlZE1hcmtkb3duQ29udGVudCB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBMaXN0SXRlbSA9IE5vZGUyLmNyZWF0ZSh7XG4gIG5hbWU6IFwibGlzdEl0ZW1cIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgYnVsbGV0TGlzdFR5cGVOYW1lOiBcImJ1bGxldExpc3RcIixcbiAgICAgIG9yZGVyZWRMaXN0VHlwZU5hbWU6IFwib3JkZXJlZExpc3RcIlxuICAgIH07XG4gIH0sXG4gIGNvbnRlbnQ6IFwicGFyYWdyYXBoIGJsb2NrKlwiLFxuICBkZWZpbmluZzogdHJ1ZSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJsaVwiXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1wibGlcIiwgbWVyZ2VBdHRyaWJ1dGVzMih0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5OYW1lOiBcImxpc3RfaXRlbVwiLFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJsaXN0X2l0ZW1cIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IFtdO1xuICAgIGlmICh0b2tlbi50b2tlbnMgJiYgdG9rZW4udG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGhhc1BhcmFncmFwaFRva2VucyA9IHRva2VuLnRva2Vucy5zb21lKCh0KSA9PiB0LnR5cGUgPT09IFwicGFyYWdyYXBoXCIpO1xuICAgICAgaWYgKGhhc1BhcmFncmFwaFRva2Vucykge1xuICAgICAgICBjb250ZW50ID0gaGVscGVycy5wYXJzZUNoaWxkcmVuKHRva2VuLnRva2Vucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmaXJzdFRva2VuID0gdG9rZW4udG9rZW5zWzBdO1xuICAgICAgICBpZiAoZmlyc3RUb2tlbiAmJiBmaXJzdFRva2VuLnR5cGUgPT09IFwidGV4dFwiICYmIGZpcnN0VG9rZW4udG9rZW5zICYmIGZpcnN0VG9rZW4udG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBpbmxpbmVDb250ZW50ID0gaGVscGVycy5wYXJzZUlubGluZShmaXJzdFRva2VuLnRva2Vucyk7XG4gICAgICAgICAgY29udGVudCA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgICAgICAgY29udGVudDogaW5saW5lQ29udGVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG4gICAgICAgICAgaWYgKHRva2VuLnRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdUb2tlbnMgPSB0b2tlbi50b2tlbnMuc2xpY2UoMSk7XG4gICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsQ29udGVudCA9IGhlbHBlcnMucGFyc2VDaGlsZHJlbihyZW1haW5pbmdUb2tlbnMpO1xuICAgICAgICAgICAgY29udGVudC5wdXNoKC4uLmFkZGl0aW9uYWxDb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCA9IGhlbHBlcnMucGFyc2VDaGlsZHJlbih0b2tlbi50b2tlbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGVudCA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgY29udGVudDogW11cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGlzdEl0ZW1cIixcbiAgICAgIGNvbnRlbnRcbiAgICB9O1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgsIGN0eCkgPT4ge1xuICAgIHJldHVybiByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQoXG4gICAgICBub2RlLFxuICAgICAgaCxcbiAgICAgIChjb250ZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChjb250ZXh0LnBhcmVudFR5cGUgPT09IFwiYnVsbGV0TGlzdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiLSBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5wYXJlbnRUeXBlID09PSBcIm9yZGVyZWRMaXN0XCIpIHtcbiAgICAgICAgICBjb25zdCBzdGFydCA9ICgoX2IgPSAoX2EgPSBjb250ZXh0Lm1ldGEpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wYXJlbnRBdHRycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXJ0KSB8fCAxO1xuICAgICAgICAgIHJldHVybiBgJHtzdGFydCArIGNvbnRleHQuaW5kZXh9LiBgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIi0gXCI7XG4gICAgICB9LFxuICAgICAgY3R4XG4gICAgKTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgXCJTaGlmdC1UYWJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKHRoaXMubmFtZSlcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2tleW1hcC9saXN0LWtleW1hcC50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2luZGV4LnRzXG52YXIgbGlzdEhlbHBlcnNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobGlzdEhlbHBlcnNfZXhwb3J0cywge1xuICBmaW5kTGlzdEl0ZW1Qb3M6ICgpID0+IGZpbmRMaXN0SXRlbVBvcyxcbiAgZ2V0TmV4dExpc3REZXB0aDogKCkgPT4gZ2V0TmV4dExpc3REZXB0aCxcbiAgaGFuZGxlQmFja3NwYWNlOiAoKSA9PiBoYW5kbGVCYWNrc3BhY2UsXG4gIGhhbmRsZURlbGV0ZTogKCkgPT4gaGFuZGxlRGVsZXRlLFxuICBoYXNMaXN0QmVmb3JlOiAoKSA9PiBoYXNMaXN0QmVmb3JlLFxuICBoYXNMaXN0SXRlbUFmdGVyOiAoKSA9PiBoYXNMaXN0SXRlbUFmdGVyLFxuICBoYXNMaXN0SXRlbUJlZm9yZTogKCkgPT4gaGFzTGlzdEl0ZW1CZWZvcmUsXG4gIGxpc3RJdGVtSGFzU3ViTGlzdDogKCkgPT4gbGlzdEl0ZW1IYXNTdWJMaXN0LFxuICBuZXh0TGlzdElzRGVlcGVyOiAoKSA9PiBuZXh0TGlzdElzRGVlcGVyLFxuICBuZXh0TGlzdElzSGlnaGVyOiAoKSA9PiBuZXh0TGlzdElzSGlnaGVyXG59KTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9maW5kTGlzdEl0ZW1Qb3MudHNcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIGZpbmRMaXN0SXRlbVBvcyA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICBjb25zdCB7ICRmcm9tIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0IG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgbGV0IGN1cnJlbnROb2RlID0gbnVsbDtcbiAgbGV0IGN1cnJlbnREZXB0aCA9ICRmcm9tLmRlcHRoO1xuICBsZXQgY3VycmVudFBvcyA9ICRmcm9tLnBvcztcbiAgbGV0IHRhcmdldERlcHRoID0gbnVsbDtcbiAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgdGFyZ2V0RGVwdGggPT09IG51bGwpIHtcbiAgICBjdXJyZW50Tm9kZSA9ICRmcm9tLm5vZGUoY3VycmVudERlcHRoKTtcbiAgICBpZiAoY3VycmVudE5vZGUudHlwZSA9PT0gbm9kZVR5cGUpIHtcbiAgICAgIHRhcmdldERlcHRoID0gY3VycmVudERlcHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RGVwdGggLT0gMTtcbiAgICAgIGN1cnJlbnRQb3MgLT0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKHRhcmdldERlcHRoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHsgJHBvczogc3RhdGUuZG9jLnJlc29sdmUoY3VycmVudFBvcyksIGRlcHRoOiB0YXJnZXREZXB0aCB9O1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9nZXROZXh0TGlzdERlcHRoLnRzXG5pbXBvcnQgeyBnZXROb2RlQXRQb3NpdGlvbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBnZXROZXh0TGlzdERlcHRoID0gKHR5cGVPck5hbWUsIHN0YXRlKSA9PiB7XG4gIGNvbnN0IGxpc3RJdGVtUG9zID0gZmluZExpc3RJdGVtUG9zKHR5cGVPck5hbWUsIHN0YXRlKTtcbiAgaWYgKCFsaXN0SXRlbVBvcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBbLCBkZXB0aF0gPSBnZXROb2RlQXRQb3NpdGlvbihzdGF0ZSwgdHlwZU9yTmFtZSwgbGlzdEl0ZW1Qb3MuJHBvcy5wb3MgKyA0KTtcbiAgcmV0dXJuIGRlcHRoO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYW5kbGVCYWNrc3BhY2UudHNcbmltcG9ydCB7IGlzQXRTdGFydE9mTm9kZSwgaXNOb2RlQWN0aXZlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhc0xpc3RCZWZvcmUudHNcbnZhciBoYXNMaXN0QmVmb3JlID0gKGVkaXRvclN0YXRlLCBuYW1lLCBwYXJlbnRMaXN0VHlwZXMpID0+IHtcbiAgY29uc3QgeyAkYW5jaG9yIH0gPSBlZGl0b3JTdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0IHByZXZpb3VzTm9kZVBvcyA9IE1hdGgubWF4KDAsICRhbmNob3IucG9zIC0gMik7XG4gIGNvbnN0IHByZXZpb3VzTm9kZSA9IGVkaXRvclN0YXRlLmRvYy5yZXNvbHZlKHByZXZpb3VzTm9kZVBvcykubm9kZSgpO1xuICBpZiAoIXByZXZpb3VzTm9kZSB8fCAhcGFyZW50TGlzdFR5cGVzLmluY2x1ZGVzKHByZXZpb3VzTm9kZS50eXBlLm5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYXNMaXN0SXRlbUJlZm9yZS50c1xudmFyIGhhc0xpc3RJdGVtQmVmb3JlID0gKHR5cGVPck5hbWUsIHN0YXRlKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0ICR0YXJnZXRQb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZSgkYW5jaG9yLnBvcyAtIDIpO1xuICBpZiAoJHRhcmdldFBvcy5pbmRleCgpID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoKF9hID0gJHRhcmdldFBvcy5ub2RlQmVmb3JlKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHlwZS5uYW1lKSAhPT0gdHlwZU9yTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvbGlzdEl0ZW1IYXNTdWJMaXN0LnRzXG5pbXBvcnQgeyBnZXROb2RlVHlwZSBhcyBnZXROb2RlVHlwZTIgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgbGlzdEl0ZW1IYXNTdWJMaXN0ID0gKHR5cGVPck5hbWUsIHN0YXRlLCBub2RlKSA9PiB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBub2RlVHlwZSA9IGdldE5vZGVUeXBlMih0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBsZXQgaGFzU3ViTGlzdCA9IGZhbHNlO1xuICBub2RlLmRlc2NlbmRhbnRzKChjaGlsZCkgPT4ge1xuICAgIGlmIChjaGlsZC50eXBlID09PSBub2RlVHlwZSkge1xuICAgICAgaGFzU3ViTGlzdCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhhc1N1Ykxpc3Q7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhbmRsZUJhY2tzcGFjZS50c1xudmFyIGhhbmRsZUJhY2tzcGFjZSA9IChlZGl0b3IsIG5hbWUsIHBhcmVudExpc3RUeXBlcykgPT4ge1xuICBpZiAoZWRpdG9yLmNvbW1hbmRzLnVuZG9JbnB1dFJ1bGUoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb20gIT09IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24udG8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFpc05vZGVBY3RpdmUoZWRpdG9yLnN0YXRlLCBuYW1lKSAmJiBoYXNMaXN0QmVmb3JlKGVkaXRvci5zdGF0ZSwgbmFtZSwgcGFyZW50TGlzdFR5cGVzKSkge1xuICAgIGNvbnN0IHsgJGFuY2hvciB9ID0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgICBjb25zdCAkbGlzdFBvcyA9IGVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZSgkYW5jaG9yLmJlZm9yZSgpIC0gMSk7XG4gICAgY29uc3QgbGlzdERlc2NlbmRhbnRzID0gW107XG4gICAgJGxpc3RQb3Mubm9kZSgpLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0RGVzY2VuZGFudHMucHVzaCh7IG5vZGUsIHBvcyB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBsYXN0SXRlbSA9IGxpc3REZXNjZW5kYW50cy5hdCgtMSk7XG4gICAgaWYgKCFsYXN0SXRlbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCAkbGFzdEl0ZW1Qb3MgPSBlZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUoJGxpc3RQb3Muc3RhcnQoKSArIGxhc3RJdGVtLnBvcyArIDEpO1xuICAgIHJldHVybiBlZGl0b3IuY2hhaW4oKS5jdXQoeyBmcm9tOiAkYW5jaG9yLnN0YXJ0KCkgLSAxLCB0bzogJGFuY2hvci5lbmQoKSArIDEgfSwgJGxhc3RJdGVtUG9zLmVuZCgpKS5qb2luRm9yd2FyZCgpLnJ1bigpO1xuICB9XG4gIGlmICghaXNOb2RlQWN0aXZlKGVkaXRvci5zdGF0ZSwgbmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFpc0F0U3RhcnRPZk5vZGUoZWRpdG9yLnN0YXRlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsaXN0SXRlbVBvcyA9IGZpbmRMaXN0SXRlbVBvcyhuYW1lLCBlZGl0b3Iuc3RhdGUpO1xuICBpZiAoIWxpc3RJdGVtUG9zKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0ICRwcmV2ID0gZWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKGxpc3RJdGVtUG9zLiRwb3MucG9zIC0gMik7XG4gIGNvbnN0IHByZXZOb2RlID0gJHByZXYubm9kZShsaXN0SXRlbVBvcy5kZXB0aCk7XG4gIGNvbnN0IHByZXZpb3VzTGlzdEl0ZW1IYXNTdWJMaXN0ID0gbGlzdEl0ZW1IYXNTdWJMaXN0KG5hbWUsIGVkaXRvci5zdGF0ZSwgcHJldk5vZGUpO1xuICBpZiAoaGFzTGlzdEl0ZW1CZWZvcmUobmFtZSwgZWRpdG9yLnN0YXRlKSAmJiAhcHJldmlvdXNMaXN0SXRlbUhhc1N1Ykxpc3QpIHtcbiAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmpvaW5JdGVtQmFja3dhcmQoKTtcbiAgfVxuICByZXR1cm4gZWRpdG9yLmNoYWluKCkubGlmdExpc3RJdGVtKG5hbWUpLnJ1bigpO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYW5kbGVEZWxldGUudHNcbmltcG9ydCB7IGlzQXRFbmRPZk5vZGUsIGlzTm9kZUFjdGl2ZSBhcyBpc05vZGVBY3RpdmUyIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL25leHRMaXN0SXNEZWVwZXIudHNcbnZhciBuZXh0TGlzdElzRGVlcGVyID0gKHR5cGVPck5hbWUsIHN0YXRlKSA9PiB7XG4gIGNvbnN0IGxpc3REZXB0aCA9IGdldE5leHRMaXN0RGVwdGgodHlwZU9yTmFtZSwgc3RhdGUpO1xuICBjb25zdCBsaXN0SXRlbVBvcyA9IGZpbmRMaXN0SXRlbVBvcyh0eXBlT3JOYW1lLCBzdGF0ZSk7XG4gIGlmICghbGlzdEl0ZW1Qb3MgfHwgIWxpc3REZXB0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobGlzdERlcHRoID4gbGlzdEl0ZW1Qb3MuZGVwdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL25leHRMaXN0SXNIaWdoZXIudHNcbnZhciBuZXh0TGlzdElzSGlnaGVyID0gKHR5cGVPck5hbWUsIHN0YXRlKSA9PiB7XG4gIGNvbnN0IGxpc3REZXB0aCA9IGdldE5leHRMaXN0RGVwdGgodHlwZU9yTmFtZSwgc3RhdGUpO1xuICBjb25zdCBsaXN0SXRlbVBvcyA9IGZpbmRMaXN0SXRlbVBvcyh0eXBlT3JOYW1lLCBzdGF0ZSk7XG4gIGlmICghbGlzdEl0ZW1Qb3MgfHwgIWxpc3REZXB0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobGlzdERlcHRoIDwgbGlzdEl0ZW1Qb3MuZGVwdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhbmRsZURlbGV0ZS50c1xudmFyIGhhbmRsZURlbGV0ZSA9IChlZGl0b3IsIG5hbWUpID0+IHtcbiAgaWYgKCFpc05vZGVBY3RpdmUyKGVkaXRvci5zdGF0ZSwgbmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFpc0F0RW5kT2ZOb2RlKGVkaXRvci5zdGF0ZSwgbmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IGVkaXRvci5zdGF0ZTtcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb247XG4gIGlmICghc2VsZWN0aW9uLmVtcHR5ICYmICRmcm9tLnNhbWVQYXJlbnQoJHRvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmV4dExpc3RJc0RlZXBlcihuYW1lLCBlZGl0b3Iuc3RhdGUpKSB7XG4gICAgcmV0dXJuIGVkaXRvci5jaGFpbigpLmZvY3VzKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbSArIDQpLmxpZnQobmFtZSkuam9pbkJhY2t3YXJkKCkucnVuKCk7XG4gIH1cbiAgaWYgKG5leHRMaXN0SXNIaWdoZXIobmFtZSwgZWRpdG9yLnN0YXRlKSkge1xuICAgIHJldHVybiBlZGl0b3IuY2hhaW4oKS5qb2luRm9yd2FyZCgpLmpvaW5CYWNrd2FyZCgpLnJ1bigpO1xuICB9XG4gIHJldHVybiBlZGl0b3IuY29tbWFuZHMuam9pbkl0ZW1Gb3J3YXJkKCk7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhc0xpc3RJdGVtQWZ0ZXIudHNcbnZhciBoYXNMaXN0SXRlbUFmdGVyID0gKHR5cGVPck5hbWUsIHN0YXRlKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0ICR0YXJnZXRQb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZSgkYW5jaG9yLnBvcyAtICRhbmNob3IucGFyZW50T2Zmc2V0IC0gMik7XG4gIGlmICgkdGFyZ2V0UG9zLmluZGV4KCkgPT09ICR0YXJnZXRQb3MucGFyZW50LmNoaWxkQ291bnQgLSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoKF9hID0gJHRhcmdldFBvcy5ub2RlQWZ0ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS50eXBlLm5hbWUpICE9PSB0eXBlT3JOYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0LWtleW1hcC50c1xudmFyIExpc3RLZXltYXAgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJsaXN0S2V5bWFwXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpc3RUeXBlczogW1xuICAgICAgICB7XG4gICAgICAgICAgaXRlbU5hbWU6IFwibGlzdEl0ZW1cIixcbiAgICAgICAgICB3cmFwcGVyTmFtZXM6IFtcImJ1bGxldExpc3RcIiwgXCJvcmRlcmVkTGlzdFwiXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaXRlbU5hbWU6IFwidGFza0l0ZW1cIixcbiAgICAgICAgICB3cmFwcGVyTmFtZXM6IFtcInRhc2tMaXN0XCJdXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgRGVsZXRlOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGlzdFR5cGVzLmZvckVhY2goKHsgaXRlbU5hbWUgfSkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuc2NoZW1hLm5vZGVzW2l0ZW1OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVEZWxldGUoZWRpdG9yLCBpdGVtTmFtZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgICAgfSxcbiAgICAgIFwiTW9kLURlbGV0ZVwiOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGlzdFR5cGVzLmZvckVhY2goKHsgaXRlbU5hbWUgfSkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuc2NoZW1hLm5vZGVzW2l0ZW1OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVEZWxldGUoZWRpdG9yLCBpdGVtTmFtZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgICAgfSxcbiAgICAgIEJhY2tzcGFjZTogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxpc3RUeXBlcy5mb3JFYWNoKCh7IGl0ZW1OYW1lLCB3cmFwcGVyTmFtZXMgfSkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuc2NoZW1hLm5vZGVzW2l0ZW1OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVCYWNrc3BhY2UoZWRpdG9yLCBpdGVtTmFtZSwgd3JhcHBlck5hbWVzKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgICB9LFxuICAgICAgXCJNb2QtQmFja3NwYWNlXCI6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saXN0VHlwZXMuZm9yRWFjaCgoeyBpdGVtTmFtZSwgd3JhcHBlck5hbWVzIH0pID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLnNjaGVtYS5ub2Rlc1tpdGVtTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlQmFja3NwYWNlKGVkaXRvciwgaXRlbU5hbWUsIHdyYXBwZXJOYW1lcykpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMva2l0L2luZGV4LnRzXG5pbXBvcnQgeyBFeHRlbnNpb24gYXMgRXh0ZW5zaW9uMiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcblxuLy8gc3JjL29yZGVyZWQtbGlzdC9vcmRlcmVkLWxpc3QudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyBhcyBtZXJnZUF0dHJpYnV0ZXMzLCBOb2RlIGFzIE5vZGUzLCB3cmFwcGluZ0lucHV0UnVsZSBhcyB3cmFwcGluZ0lucHV0UnVsZTIgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5cbi8vIHNyYy9vcmRlcmVkLWxpc3QvdXRpbHMudHNcbnZhciBPUkRFUkVEX0xJU1RfSVRFTV9SRUdFWCA9IC9eKFxccyopKFxcZCspXFwuXFxzKyguKikkLztcbnZhciBJTkRFTlRFRF9MSU5FX1JFR0VYID0gL15cXHMvO1xuZnVuY3Rpb24gY29sbGVjdE9yZGVyZWRMaXN0SXRlbXMobGluZXMpIHtcbiAgY29uc3QgbGlzdEl0ZW1zID0gW107XG4gIGxldCBjdXJyZW50TGluZUluZGV4ID0gMDtcbiAgbGV0IGNvbnN1bWVkID0gMDtcbiAgd2hpbGUgKGN1cnJlbnRMaW5lSW5kZXggPCBsaW5lcy5sZW5ndGgpIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbY3VycmVudExpbmVJbmRleF07XG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKE9SREVSRURfTElTVF9JVEVNX1JFR0VYKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgWywgaW5kZW50LCBudW1iZXIsIGNvbnRlbnRdID0gbWF0Y2g7XG4gICAgY29uc3QgaW5kZW50TGV2ZWwgPSBpbmRlbnQubGVuZ3RoO1xuICAgIGxldCBpdGVtQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgbGV0IG5leHRMaW5lSW5kZXggPSBjdXJyZW50TGluZUluZGV4ICsgMTtcbiAgICBjb25zdCBpdGVtTGluZXMgPSBbbGluZV07XG4gICAgd2hpbGUgKG5leHRMaW5lSW5kZXggPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5leHRMaW5lID0gbGluZXNbbmV4dExpbmVJbmRleF07XG4gICAgICBjb25zdCBuZXh0TWF0Y2ggPSBuZXh0TGluZS5tYXRjaChPUkRFUkVEX0xJU1RfSVRFTV9SRUdFWCk7XG4gICAgICBpZiAobmV4dE1hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG5leHRMaW5lLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICBpdGVtTGluZXMucHVzaChuZXh0TGluZSk7XG4gICAgICAgIGl0ZW1Db250ZW50ICs9IFwiXFxuXCI7XG4gICAgICAgIG5leHRMaW5lSW5kZXggKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dExpbmUubWF0Y2goSU5ERU5URURfTElORV9SRUdFWCkpIHtcbiAgICAgICAgaXRlbUxpbmVzLnB1c2gobmV4dExpbmUpO1xuICAgICAgICBpdGVtQ29udGVudCArPSBgXG4ke25leHRMaW5lLnNsaWNlKGluZGVudExldmVsICsgMil9YDtcbiAgICAgICAgbmV4dExpbmVJbmRleCArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGxpc3RJdGVtcy5wdXNoKHtcbiAgICAgIGluZGVudDogaW5kZW50TGV2ZWwsXG4gICAgICBudW1iZXI6IHBhcnNlSW50KG51bWJlciwgMTApLFxuICAgICAgY29udGVudDogaXRlbUNvbnRlbnQudHJpbSgpLFxuICAgICAgcmF3OiBpdGVtTGluZXMuam9pbihcIlxcblwiKVxuICAgIH0pO1xuICAgIGNvbnN1bWVkID0gbmV4dExpbmVJbmRleDtcbiAgICBjdXJyZW50TGluZUluZGV4ID0gbmV4dExpbmVJbmRleDtcbiAgfVxuICByZXR1cm4gW2xpc3RJdGVtcywgY29uc3VtZWRdO1xufVxuZnVuY3Rpb24gYnVpbGROZXN0ZWRTdHJ1Y3R1cmUoaXRlbXMsIGJhc2VJbmRlbnQsIGxleGVyKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICB3aGlsZSAoY3VycmVudEluZGV4IDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgY29uc3QgaXRlbSA9IGl0ZW1zW2N1cnJlbnRJbmRleF07XG4gICAgaWYgKGl0ZW0uaW5kZW50ID09PSBiYXNlSW5kZW50KSB7XG4gICAgICBjb25zdCBjb250ZW50TGluZXMgPSBpdGVtLmNvbnRlbnQuc3BsaXQoXCJcXG5cIik7XG4gICAgICBjb25zdCBtYWluVGV4dCA9ICgoX2EgPSBjb250ZW50TGluZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS50cmltKCkpIHx8IFwiXCI7XG4gICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgIGlmIChtYWluVGV4dCkge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgICByYXc6IG1haW5UZXh0LFxuICAgICAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKG1haW5UZXh0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFkZGl0aW9uYWxDb250ZW50ID0gY29udGVudExpbmVzLnNsaWNlKDEpLmpvaW4oXCJcXG5cIikudHJpbSgpO1xuICAgICAgaWYgKGFkZGl0aW9uYWxDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrVG9rZW5zID0gbGV4ZXIuYmxvY2tUb2tlbnMoYWRkaXRpb25hbENvbnRlbnQpO1xuICAgICAgICB0b2tlbnMucHVzaCguLi5ibG9ja1Rva2Vucyk7XG4gICAgICB9XG4gICAgICBsZXQgbG9va0FoZWFkSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgY29uc3QgbmVzdGVkSXRlbXMgPSBbXTtcbiAgICAgIHdoaWxlIChsb29rQWhlYWRJbmRleCA8IGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1tsb29rQWhlYWRJbmRleF0uaW5kZW50ID4gYmFzZUluZGVudCkge1xuICAgICAgICBuZXN0ZWRJdGVtcy5wdXNoKGl0ZW1zW2xvb2tBaGVhZEluZGV4XSk7XG4gICAgICAgIGxvb2tBaGVhZEluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAobmVzdGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0SW5kZW50ID0gTWF0aC5taW4oLi4ubmVzdGVkSXRlbXMubWFwKChuZXN0ZWRJdGVtKSA9PiBuZXN0ZWRJdGVtLmluZGVudCkpO1xuICAgICAgICBjb25zdCBuZXN0ZWRMaXN0SXRlbXMgPSBidWlsZE5lc3RlZFN0cnVjdHVyZShuZXN0ZWRJdGVtcywgbmV4dEluZGVudCwgbGV4ZXIpO1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJsaXN0XCIsXG4gICAgICAgICAgb3JkZXJlZDogdHJ1ZSxcbiAgICAgICAgICBzdGFydDogbmVzdGVkSXRlbXNbMF0ubnVtYmVyLFxuICAgICAgICAgIGl0ZW1zOiBuZXN0ZWRMaXN0SXRlbXMsXG4gICAgICAgICAgcmF3OiBuZXN0ZWRJdGVtcy5tYXAoKG5lc3RlZEl0ZW0pID0+IG5lc3RlZEl0ZW0ucmF3KS5qb2luKFwiXFxuXCIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICB0eXBlOiBcImxpc3RfaXRlbVwiLFxuICAgICAgICByYXc6IGl0ZW0ucmF3LFxuICAgICAgICB0b2tlbnNcbiAgICAgIH0pO1xuICAgICAgY3VycmVudEluZGV4ID0gbG9va0FoZWFkSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRJbmRleCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VMaXN0SXRlbXMoaXRlbXMsIGhlbHBlcnMpIHtcbiAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtLnR5cGUgIT09IFwibGlzdF9pdGVtXCIpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnBhcnNlQ2hpbGRyZW4oW2l0ZW1dKVswXTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IFtdO1xuICAgIGlmIChpdGVtLnRva2VucyAmJiBpdGVtLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICBpdGVtLnRva2Vucy5mb3JFYWNoKChpdGVtVG9rZW4pID0+IHtcbiAgICAgICAgaWYgKGl0ZW1Ub2tlbi50eXBlID09PSBcInBhcmFncmFwaFwiIHx8IGl0ZW1Ub2tlbi50eXBlID09PSBcImxpc3RcIiB8fCBpdGVtVG9rZW4udHlwZSA9PT0gXCJibG9ja3F1b3RlXCIgfHwgaXRlbVRva2VuLnR5cGUgPT09IFwiY29kZVwiKSB7XG4gICAgICAgICAgY29udGVudC5wdXNoKC4uLmhlbHBlcnMucGFyc2VDaGlsZHJlbihbaXRlbVRva2VuXSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1Ub2tlbi50eXBlID09PSBcInRleHRcIiAmJiBpdGVtVG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgY29uc3QgaW5saW5lQ29udGVudCA9IGhlbHBlcnMucGFyc2VDaGlsZHJlbihbaXRlbVRva2VuXSk7XG4gICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgICBjb250ZW50OiBpbmxpbmVDb250ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gaGVscGVycy5wYXJzZUNoaWxkcmVuKFtpdGVtVG9rZW5dKTtcbiAgICAgICAgICBpZiAocGFyc2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCguLi5wYXJzZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxpc3RJdGVtXCIsXG4gICAgICBjb250ZW50XG4gICAgfTtcbiAgfSk7XG59XG5cbi8vIHNyYy9vcmRlcmVkLWxpc3Qvb3JkZXJlZC1saXN0LnRzXG52YXIgTGlzdEl0ZW1OYW1lMiA9IFwibGlzdEl0ZW1cIjtcbnZhciBUZXh0U3R5bGVOYW1lMiA9IFwidGV4dFN0eWxlXCI7XG52YXIgb3JkZXJlZExpc3RJbnB1dFJlZ2V4ID0gL14oXFxkKylcXC5cXHMkLztcbnZhciBPcmRlcmVkTGlzdCA9IE5vZGUzLmNyZWF0ZSh7XG4gIG5hbWU6IFwib3JkZXJlZExpc3RcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbVR5cGVOYW1lOiBcImxpc3RJdGVtXCIsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBrZWVwTWFya3M6IGZhbHNlLFxuICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgZ3JvdXA6IFwiYmxvY2sgbGlzdFwiLFxuICBjb250ZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgO1xuICB9LFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwic3RhcnRcIikgPyBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZShcInN0YXJ0XCIpIHx8IFwiXCIsIDEwKSA6IDE7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0eXBlOiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwib2xcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgY29uc3QgeyBzdGFydCwgLi4uYXR0cmlidXRlc1dpdGhvdXRTdGFydCB9ID0gSFRNTEF0dHJpYnV0ZXM7XG4gICAgcmV0dXJuIHN0YXJ0ID09PSAxID8gW1wib2xcIiwgbWVyZ2VBdHRyaWJ1dGVzMyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNXaXRob3V0U3RhcnQpLCAwXSA6IFtcIm9sXCIsIG1lcmdlQXR0cmlidXRlczModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJsaXN0XCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIGlmICh0b2tlbi50eXBlICE9PSBcImxpc3RcIiB8fCAhdG9rZW4ub3JkZXJlZCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFZhbHVlID0gdG9rZW4uc3RhcnQgfHwgMTtcbiAgICBjb25zdCBjb250ZW50ID0gdG9rZW4uaXRlbXMgPyBwYXJzZUxpc3RJdGVtcyh0b2tlbi5pdGVtcywgaGVscGVycykgOiBbXTtcbiAgICBpZiAoc3RhcnRWYWx1ZSAhPT0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJvcmRlcmVkTGlzdFwiLFxuICAgICAgICBhdHRyczogeyBzdGFydDogc3RhcnRWYWx1ZSB9LFxuICAgICAgICBjb250ZW50XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcmRlcmVkTGlzdFwiLFxuICAgICAgY29udGVudFxuICAgIH07XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIGlmICghbm9kZS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGgucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50LCBcIlxcblwiKTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbml6ZXI6IHtcbiAgICBuYW1lOiBcIm9yZGVyZWRMaXN0XCIsXG4gICAgbGV2ZWw6IFwiYmxvY2tcIixcbiAgICBzdGFydDogKHNyYykgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBzcmMubWF0Y2goL14oXFxzKikoXFxkKylcXC5cXHMrLyk7XG4gICAgICBjb25zdCBpbmRleCA9IG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaC5pbmRleDtcbiAgICAgIHJldHVybiBpbmRleCAhPT0gdm9pZCAwID8gaW5kZXggOiAtMTtcbiAgICB9LFxuICAgIHRva2VuaXplOiAoc3JjLCBfdG9rZW5zLCBsZXhlcikgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgbGluZXMgPSBzcmMuc3BsaXQoXCJcXG5cIik7XG4gICAgICBjb25zdCBbbGlzdEl0ZW1zLCBjb25zdW1lZF0gPSBjb2xsZWN0T3JkZXJlZExpc3RJdGVtcyhsaW5lcyk7XG4gICAgICBpZiAobGlzdEl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBidWlsZE5lc3RlZFN0cnVjdHVyZShsaXN0SXRlbXMsIDAsIGxleGVyKTtcbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAoKF9hID0gbGlzdEl0ZW1zWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EubnVtYmVyKSB8fCAxO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJsaXN0XCIsXG4gICAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgICAgIHN0YXJ0OiBzdGFydFZhbHVlLFxuICAgICAgICBpdGVtcyxcbiAgICAgICAgcmF3OiBsaW5lcy5zbGljZSgwLCBjb25zdW1lZCkuam9pbihcIlxcblwiKVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIG1hcmtkb3duT3B0aW9uczoge1xuICAgIGluZGVudHNDb250ZW50OiB0cnVlXG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGVPcmRlcmVkTGlzdDogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluIH0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKS51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtTmFtZTIsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZTIpKS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1TaGlmdC03XCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZU9yZGVyZWRMaXN0KClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZTIoe1xuICAgICAgZmluZDogb3JkZXJlZExpc3RJbnB1dFJlZ2V4LFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgZ2V0QXR0cmlidXRlczogKG1hdGNoKSA9PiAoeyBzdGFydDogK21hdGNoWzFdIH0pLFxuICAgICAgam9pblByZWRpY2F0ZTogKG1hdGNoLCBub2RlKSA9PiBub2RlLmNoaWxkQ291bnQgKyBub2RlLmF0dHJzLnN0YXJ0ID09PSArbWF0Y2hbMV1cbiAgICB9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlMih7XG4gICAgICAgIGZpbmQ6IG9yZGVyZWRMaXN0SW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCkgPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSwgLi4udGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lMikgfSksXG4gICAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtpbnB1dFJ1bGVdO1xuICB9XG59KTtcblxuLy8gc3JjL3Rhc2staXRlbS90YXNrLWl0ZW0udHNcbmltcG9ydCB7XG4gIGdldFJlbmRlcmVkQXR0cmlidXRlcyxcbiAgbWVyZ2VBdHRyaWJ1dGVzIGFzIG1lcmdlQXR0cmlidXRlczQsXG4gIE5vZGUgYXMgTm9kZTQsXG4gIHJlbmRlck5lc3RlZE1hcmtkb3duQ29udGVudCBhcyByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQyLFxuICB3cmFwcGluZ0lucHV0UnVsZSBhcyB3cmFwcGluZ0lucHV0UnVsZTNcbn0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIGlucHV0UmVnZXggPSAvXlxccyooXFxbKFsoIHx4XSk/XFxdKVxccyQvO1xudmFyIFRhc2tJdGVtID0gTm9kZTQuY3JlYXRlKHtcbiAgbmFtZTogXCJ0YXNrSXRlbVwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXN0ZWQ6IGZhbHNlLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgdGFza0xpc3RUeXBlTmFtZTogXCJ0YXNrTGlzdFwiLFxuICAgICAgYTExeTogdm9pZCAwXG4gICAgfTtcbiAgfSxcbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm5lc3RlZCA/IFwicGFyYWdyYXBoIGJsb2NrKlwiIDogXCJwYXJhZ3JhcGgrXCI7XG4gIH0sXG4gIGRlZmluaW5nOiB0cnVlLFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGVja2VkOiB7XG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBrZWVwT25TcGxpdDogZmFsc2UsXG4gICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhQ2hlY2tlZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jaGVja2VkXCIpO1xuICAgICAgICAgIHJldHVybiBkYXRhQ2hlY2tlZCA9PT0gXCJcIiB8fCBkYXRhQ2hlY2tlZCA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlckhUTUw6IChhdHRyaWJ1dGVzKSA9PiAoe1xuICAgICAgICAgIFwiZGF0YS1jaGVja2VkXCI6IGF0dHJpYnV0ZXMuY2hlY2tlZFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IGBsaVtkYXRhLXR5cGU9XCIke3RoaXMubmFtZX1cIl1gLFxuICAgICAgICBwcmlvcml0eTogNTFcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXG4gICAgICBcImxpXCIsXG4gICAgICBtZXJnZUF0dHJpYnV0ZXM0KHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMsIHtcbiAgICAgICAgXCJkYXRhLXR5cGVcIjogdGhpcy5uYW1lXG4gICAgICB9KSxcbiAgICAgIFtcbiAgICAgICAgXCJsYWJlbFwiLFxuICAgICAgICBbXG4gICAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IG5vZGUuYXR0cnMuY2hlY2tlZCA/IFwiY2hlY2tlZFwiIDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgW1wic3BhblwiXVxuICAgICAgXSxcbiAgICAgIFtcImRpdlwiLCAwXVxuICAgIF07XG4gIH0sXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaCkgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgICBpZiAodG9rZW4udG9rZW5zICYmIHRva2VuLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb250ZW50LnB1c2goaC5jcmVhdGVOb2RlKFwicGFyYWdyYXBoXCIsIHt9LCBoLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykpKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLnRleHQpIHtcbiAgICAgIGNvbnRlbnQucHVzaChoLmNyZWF0ZU5vZGUoXCJwYXJhZ3JhcGhcIiwge30sIFtoLmNyZWF0ZU5vZGUoXCJ0ZXh0XCIsIHsgdGV4dDogdG9rZW4udGV4dCB9KV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC5wdXNoKGguY3JlYXRlTm9kZShcInBhcmFncmFwaFwiLCB7fSwgW10pKTtcbiAgICB9XG4gICAgaWYgKHRva2VuLm5lc3RlZFRva2VucyAmJiB0b2tlbi5uZXN0ZWRUb2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmVzdGVkQ29udGVudCA9IGgucGFyc2VDaGlsZHJlbih0b2tlbi5uZXN0ZWRUb2tlbnMpO1xuICAgICAgY29udGVudC5wdXNoKC4uLm5lc3RlZENvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gaC5jcmVhdGVOb2RlKFwidGFza0l0ZW1cIiwgeyBjaGVja2VkOiB0b2tlbi5jaGVja2VkIHx8IGZhbHNlIH0sIGNvbnRlbnQpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY2hlY2tlZENoYXIgPSAoKF9hID0gbm9kZS5hdHRycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNoZWNrZWQpID8gXCJ4XCIgOiBcIiBcIjtcbiAgICBjb25zdCBwcmVmaXggPSBgLSBbJHtjaGVja2VkQ2hhcn1dIGA7XG4gICAgcmV0dXJuIHJlbmRlck5lc3RlZE1hcmtkb3duQ29udGVudDIobm9kZSwgaCwgcHJlZml4KTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgY29uc3Qgc2hvcnRjdXRzID0ge1xuICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgIFwiU2hpZnQtVGFiXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSh0aGlzLm5hbWUpXG4gICAgfTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5uZXN0ZWQpIHtcbiAgICAgIHJldHVybiBzaG9ydGN1dHM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5zaG9ydGN1dHMsXG4gICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpXG4gICAgfTtcbiAgfSxcbiAgYWRkTm9kZVZpZXcoKSB7XG4gICAgcmV0dXJuICh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzLCBnZXRQb3MsIGVkaXRvciB9KSA9PiB7XG4gICAgICBjb25zdCBsaXN0SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgIGNvbnN0IGNoZWNrYm94V3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgIGNvbnN0IGNoZWNrYm94U3R5bGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29uc3QgdXBkYXRlQTExWSA9IChjdXJyZW50Tm9kZSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjaGVja2JveC5hcmlhTGFiZWwgPSAoKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmExMXkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jaGVja2JveExhYmVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgY3VycmVudE5vZGUsIGNoZWNrYm94LmNoZWNrZWQpKSB8fCBgVGFzayBpdGVtIGNoZWNrYm94IGZvciAke2N1cnJlbnROb2RlLnRleHRDb250ZW50IHx8IFwiZW1wdHkgdGFzayBpdGVtXCJ9YDtcbiAgICAgIH07XG4gICAgICB1cGRhdGVBMTFZKG5vZGUpO1xuICAgICAgY2hlY2tib3hXcmFwcGVyLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgIGNoZWNrYm94LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChldmVudCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSk7XG4gICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5pc0VkaXRhYmxlICYmICF0aGlzLm9wdGlvbnMub25SZWFkT25seUNoZWNrZWQpIHtcbiAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gIWNoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2hlY2tlZCB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAoZWRpdG9yLmlzRWRpdGFibGUgJiYgdHlwZW9mIGdldFBvcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZWRpdG9yLmNoYWluKCkuZm9jdXModm9pZCAwLCB7IHNjcm9sbEludG9WaWV3OiBmYWxzZSB9KS5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UG9zKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gdHIuZG9jLm5vZGVBdChwb3NpdGlvbik7XG4gICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvc2l0aW9uLCB2b2lkIDAsIHtcbiAgICAgICAgICAgICAgLi4uY3VycmVudE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnROb2RlLmF0dHJzLFxuICAgICAgICAgICAgICBjaGVja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0pLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWRpdG9yLmlzRWRpdGFibGUgJiYgdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub25SZWFkT25seUNoZWNrZWQobm9kZSwgY2hlY2tlZCkpIHtcbiAgICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSAhY2hlY2tib3guY2hlY2tlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgbGlzdEl0ZW0uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBsaXN0SXRlbS5kYXRhc2V0LmNoZWNrZWQgPSBub2RlLmF0dHJzLmNoZWNrZWQ7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gbm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgY2hlY2tib3hXcmFwcGVyLmFwcGVuZChjaGVja2JveCwgY2hlY2tib3hTdHlsZXIpO1xuICAgICAgbGlzdEl0ZW0uYXBwZW5kKGNoZWNrYm94V3JhcHBlciwgY29udGVudCk7XG4gICAgICBPYmplY3QuZW50cmllcyhIVE1MQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGxpc3RJdGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgbGV0IHByZXZSZW5kZXJlZEF0dHJpYnV0ZUtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKEhUTUxBdHRyaWJ1dGVzKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb206IGxpc3RJdGVtLFxuICAgICAgICBjb250ZW50RE9NOiBjb250ZW50LFxuICAgICAgICB1cGRhdGU6ICh1cGRhdGVkTm9kZSkgPT4ge1xuICAgICAgICAgIGlmICh1cGRhdGVkTm9kZS50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlzdEl0ZW0uZGF0YXNldC5jaGVja2VkID0gdXBkYXRlZE5vZGUuYXR0cnMuY2hlY2tlZDtcbiAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdXBkYXRlZE5vZGUuYXR0cnMuY2hlY2tlZDtcbiAgICAgICAgICB1cGRhdGVBMTFZKHVwZGF0ZWROb2RlKTtcbiAgICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlcztcbiAgICAgICAgICBjb25zdCBuZXdIVE1MQXR0cmlidXRlcyA9IGdldFJlbmRlcmVkQXR0cmlidXRlcyh1cGRhdGVkTm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyk7XG4gICAgICAgICAgY29uc3QgbmV3S2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMobmV3SFRNTEF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICBjb25zdCBzdGF0aWNBdHRycyA9IHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcztcbiAgICAgICAgICBwcmV2UmVuZGVyZWRBdHRyaWJ1dGVLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFuZXdLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgaW4gc3RhdGljQXR0cnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0SXRlbS5zZXRBdHRyaWJ1dGUoa2V5LCBzdGF0aWNBdHRyc1trZXldKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0SXRlbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG5ld0hUTUxBdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgaW4gc3RhdGljQXR0cnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0SXRlbS5zZXRBdHRyaWJ1dGUoa2V5LCBzdGF0aWNBdHRyc1trZXldKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0SXRlbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGlzdEl0ZW0uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByZXZSZW5kZXJlZEF0dHJpYnV0ZUtleXMgPSBuZXdLZXlzO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHdyYXBwaW5nSW5wdXRSdWxlMyh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogKG1hdGNoKSA9PiAoe1xuICAgICAgICAgIGNoZWNrZWQ6IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdID09PSBcInhcIlxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL3Rhc2stbGlzdC90YXNrLWxpc3QudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyBhcyBtZXJnZUF0dHJpYnV0ZXM1LCBOb2RlIGFzIE5vZGU1LCBwYXJzZUluZGVudGVkQmxvY2tzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIFRhc2tMaXN0ID0gTm9kZTUuY3JlYXRlKHtcbiAgbmFtZTogXCJ0YXNrTGlzdFwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtVHlwZU5hbWU6IFwidGFza0l0ZW1cIixcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrIGxpc3RcIixcbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYDtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogYHVsW2RhdGEtdHlwZT1cIiR7dGhpcy5uYW1lfVwiXWAsXG4gICAgICAgIHByaW9yaXR5OiA1MVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcInVsXCIsIG1lcmdlQXR0cmlidXRlczUodGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcywgeyBcImRhdGEtdHlwZVwiOiB0aGlzLm5hbWUgfSksIDBdO1xuICB9LFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGgpID0+IHtcbiAgICByZXR1cm4gaC5jcmVhdGVOb2RlKFwidGFza0xpc3RcIiwge30sIGgucGFyc2VDaGlsZHJlbih0b2tlbi5pdGVtcyB8fCBbXSkpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICBpZiAoIW5vZGUuY29udGVudCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBoLnJlbmRlckNoaWxkcmVuKG5vZGUuY29udGVudCwgXCJcXG5cIik7XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5pemVyOiB7XG4gICAgbmFtZTogXCJ0YXNrTGlzdFwiLFxuICAgIGxldmVsOiBcImJsb2NrXCIsXG4gICAgc3RhcnQoc3JjKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBpbmRleCA9IChfYSA9IHNyYy5tYXRjaCgvXlxccypbLSsqXVxccytcXFsoWyB4WF0pXFxdXFxzKy8pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5kZXg7XG4gICAgICByZXR1cm4gaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogLTE7XG4gICAgfSxcbiAgICB0b2tlbml6ZShzcmMsIHRva2VucywgbGV4ZXIpIHtcbiAgICAgIGNvbnN0IHBhcnNlVGFza0xpc3RDb250ZW50ID0gKGNvbnRlbnQpID0+IHtcbiAgICAgICAgY29uc3QgbmVzdGVkUmVzdWx0ID0gcGFyc2VJbmRlbnRlZEJsb2NrcyhcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW1QYXR0ZXJuOiAvXihcXHMqKShbLSsqXSlcXHMrXFxbKFsgeFhdKVxcXVxccysoLiopJC8sXG4gICAgICAgICAgICBleHRyYWN0SXRlbURhdGE6IChtYXRjaCkgPT4gKHtcbiAgICAgICAgICAgICAgaW5kZW50TGV2ZWw6IG1hdGNoWzFdLmxlbmd0aCxcbiAgICAgICAgICAgICAgbWFpbkNvbnRlbnQ6IG1hdGNoWzRdLFxuICAgICAgICAgICAgICBjaGVja2VkOiBtYXRjaFszXS50b0xvd2VyQ2FzZSgpID09PSBcInhcIlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjcmVhdGVUb2tlbjogKGRhdGEsIG5lc3RlZFRva2VucykgPT4gKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0YXNrSXRlbVwiLFxuICAgICAgICAgICAgICByYXc6IFwiXCIsXG4gICAgICAgICAgICAgIG1haW5Db250ZW50OiBkYXRhLm1haW5Db250ZW50LFxuICAgICAgICAgICAgICBpbmRlbnRMZXZlbDogZGF0YS5pbmRlbnRMZXZlbCxcbiAgICAgICAgICAgICAgY2hlY2tlZDogZGF0YS5jaGVja2VkLFxuICAgICAgICAgICAgICB0ZXh0OiBkYXRhLm1haW5Db250ZW50LFxuICAgICAgICAgICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2VucyhkYXRhLm1haW5Db250ZW50KSxcbiAgICAgICAgICAgICAgbmVzdGVkVG9rZW5zXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8vIEFsbG93IHJlY3Vyc2l2ZSBuZXN0aW5nXG4gICAgICAgICAgICBjdXN0b21OZXN0ZWRQYXJzZXI6IHBhcnNlVGFza0xpc3RDb250ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsZXhlclxuICAgICAgICApO1xuICAgICAgICBpZiAobmVzdGVkUmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0YXNrTGlzdFwiLFxuICAgICAgICAgICAgICByYXc6IG5lc3RlZFJlc3VsdC5yYXcsXG4gICAgICAgICAgICAgIGl0ZW1zOiBuZXN0ZWRSZXN1bHQuaXRlbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZXhlci5ibG9ja1Rva2Vucyhjb250ZW50KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZUluZGVudGVkQmxvY2tzKFxuICAgICAgICBzcmMsXG4gICAgICAgIHtcbiAgICAgICAgICBpdGVtUGF0dGVybjogL14oXFxzKikoWy0rKl0pXFxzK1xcWyhbIHhYXSlcXF1cXHMrKC4qKSQvLFxuICAgICAgICAgIGV4dHJhY3RJdGVtRGF0YTogKG1hdGNoKSA9PiAoe1xuICAgICAgICAgICAgaW5kZW50TGV2ZWw6IG1hdGNoWzFdLmxlbmd0aCxcbiAgICAgICAgICAgIG1haW5Db250ZW50OiBtYXRjaFs0XSxcbiAgICAgICAgICAgIGNoZWNrZWQ6IG1hdGNoWzNdLnRvTG93ZXJDYXNlKCkgPT09IFwieFwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3JlYXRlVG9rZW46IChkYXRhLCBuZXN0ZWRUb2tlbnMpID0+ICh7XG4gICAgICAgICAgICB0eXBlOiBcInRhc2tJdGVtXCIsXG4gICAgICAgICAgICByYXc6IFwiXCIsXG4gICAgICAgICAgICBtYWluQ29udGVudDogZGF0YS5tYWluQ29udGVudCxcbiAgICAgICAgICAgIGluZGVudExldmVsOiBkYXRhLmluZGVudExldmVsLFxuICAgICAgICAgICAgY2hlY2tlZDogZGF0YS5jaGVja2VkLFxuICAgICAgICAgICAgdGV4dDogZGF0YS5tYWluQ29udGVudCxcbiAgICAgICAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKGRhdGEubWFpbkNvbnRlbnQpLFxuICAgICAgICAgICAgbmVzdGVkVG9rZW5zXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLy8gVXNlIHRoZSByZWN1cnNpdmUgcGFyc2VyIGZvciBuZXN0ZWQgY29udGVudFxuICAgICAgICAgIGN1c3RvbU5lc3RlZFBhcnNlcjogcGFyc2VUYXNrTGlzdENvbnRlbnRcbiAgICAgICAgfSxcbiAgICAgICAgbGV4ZXJcbiAgICAgICk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0YXNrTGlzdFwiLFxuICAgICAgICByYXc6IHJlc3VsdC5yYXcsXG4gICAgICAgIGl0ZW1zOiByZXN1bHQuaXRlbXNcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBtYXJrZG93bk9wdGlvbnM6IHtcbiAgICBpbmRlbnRzQ29udGVudDogdHJ1ZVxuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlVGFza0xpc3Q6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtU2hpZnQtOVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVUYXNrTGlzdCgpXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9raXQvaW5kZXgudHNcbnZhciBMaXN0S2l0ID0gRXh0ZW5zaW9uMi5jcmVhdGUoe1xuICBuYW1lOiBcImxpc3RLaXRcIixcbiAgYWRkRXh0ZW5zaW9ucygpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gW107XG4gICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJ1bGxldExpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0KSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEl0ZW0gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEl0ZW0uY29uZmlndXJlKHRoaXMub3B0aW9ucy5saXN0SXRlbSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpc3RLZXltYXAgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEtleW1hcC5jb25maWd1cmUodGhpcy5vcHRpb25zLmxpc3RLZXltYXApKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vcmRlcmVkTGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChPcmRlcmVkTGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0KSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFza0l0ZW0gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVGFza0l0ZW0uY29uZmlndXJlKHRoaXMub3B0aW9ucy50YXNrSXRlbSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRhc2tMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFRhc2tMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMudGFza0xpc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbnM7XG4gIH1cbn0pO1xuZXhwb3J0IHtcbiAgQnVsbGV0TGlzdCxcbiAgTGlzdEl0ZW0sXG4gIExpc3RLZXltYXAsXG4gIExpc3RLaXQsXG4gIE9yZGVyZWRMaXN0LFxuICBUYXNrSXRlbSxcbiAgVGFza0xpc3QsXG4gIGJ1bGxldExpc3RJbnB1dFJlZ2V4LFxuICBpbnB1dFJlZ2V4LFxuICBsaXN0SGVscGVyc19leHBvcnRzIGFzIGxpc3RIZWxwZXJzLFxuICBvcmRlcmVkTGlzdElucHV0UmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@tiptap+extension-list@3.19.0_@tiptap+core@3.19.0_@tiptap+pm@3.19.0__@tiptap+pm@3.19.0/node_modules/@tiptap/extension-list/dist/index.js\n");

/***/ })

};
;